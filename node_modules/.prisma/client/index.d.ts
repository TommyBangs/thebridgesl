
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model LearnerProfile
 * 
 */
export type LearnerProfile = $Result.DefaultSelection<Prisma.$LearnerProfilePayload>
/**
 * Model Skill
 * 
 */
export type Skill = $Result.DefaultSelection<Prisma.$SkillPayload>
/**
 * Model UserSkill
 * 
 */
export type UserSkill = $Result.DefaultSelection<Prisma.$UserSkillPayload>
/**
 * Model TrendingSkill
 * 
 */
export type TrendingSkill = $Result.DefaultSelection<Prisma.$TrendingSkillPayload>
/**
 * Model Credential
 * 
 */
export type Credential = $Result.DefaultSelection<Prisma.$CredentialPayload>
/**
 * Model CredentialSkill
 * 
 */
export type CredentialSkill = $Result.DefaultSelection<Prisma.$CredentialSkillPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectMedia
 * 
 */
export type ProjectMedia = $Result.DefaultSelection<Prisma.$ProjectMediaPayload>
/**
 * Model ProjectSkill
 * 
 */
export type ProjectSkill = $Result.DefaultSelection<Prisma.$ProjectSkillPayload>
/**
 * Model ProjectCollaborator
 * 
 */
export type ProjectCollaborator = $Result.DefaultSelection<Prisma.$ProjectCollaboratorPayload>
/**
 * Model Endorsement
 * 
 */
export type Endorsement = $Result.DefaultSelection<Prisma.$EndorsementPayload>
/**
 * Model Opportunity
 * 
 */
export type Opportunity = $Result.DefaultSelection<Prisma.$OpportunityPayload>
/**
 * Model OpportunityRequirement
 * 
 */
export type OpportunityRequirement = $Result.DefaultSelection<Prisma.$OpportunityRequirementPayload>
/**
 * Model OpportunitySkill
 * 
 */
export type OpportunitySkill = $Result.DefaultSelection<Prisma.$OpportunitySkillPayload>
/**
 * Model Application
 * 
 */
export type Application = $Result.DefaultSelection<Prisma.$ApplicationPayload>
/**
 * Model Connection
 * 
 */
export type Connection = $Result.DefaultSelection<Prisma.$ConnectionPayload>
/**
 * Model ConnectionRequest
 * 
 */
export type ConnectionRequest = $Result.DefaultSelection<Prisma.$ConnectionRequestPayload>
/**
 * Model FeedItem
 * 
 */
export type FeedItem = $Result.DefaultSelection<Prisma.$FeedItemPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model CareerPath
 * 
 */
export type CareerPath = $Result.DefaultSelection<Prisma.$CareerPathPayload>
/**
 * Model CareerPathNode
 * 
 */
export type CareerPathNode = $Result.DefaultSelection<Prisma.$CareerPathNodePayload>
/**
 * Model SkillGap
 * 
 */
export type SkillGap = $Result.DefaultSelection<Prisma.$SkillGapPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model CourseSkill
 * 
 */
export type CourseSkill = $Result.DefaultSelection<Prisma.$CourseSkillPayload>
/**
 * Model VerificationRequest
 * 
 */
export type VerificationRequest = $Result.DefaultSelection<Prisma.$VerificationRequestPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  student: 'student',
  institution: 'institution',
  employer: 'employer',
  admin: 'admin'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const VerificationStatus: {
  unverified: 'unverified',
  pending: 'pending',
  verified: 'verified'
};

export type VerificationStatus = (typeof VerificationStatus)[keyof typeof VerificationStatus]


export const SkillCategory: {
  technical: 'technical',
  soft_skill: 'soft_skill',
  domain_knowledge: 'domain_knowledge',
  tools: 'tools',
  languages: 'languages'
};

export type SkillCategory = (typeof SkillCategory)[keyof typeof SkillCategory]


export const SkillLevel: {
  beginner: 'beginner',
  intermediate: 'intermediate',
  advanced: 'advanced',
  expert: 'expert'
};

export type SkillLevel = (typeof SkillLevel)[keyof typeof SkillLevel]


export const CredentialType: {
  certification: 'certification',
  degree: 'degree',
  badge: 'badge',
  course_completion: 'course_completion',
  project: 'project'
};

export type CredentialType = (typeof CredentialType)[keyof typeof CredentialType]


export const ProjectVisibility: {
  public: 'public',
  private: 'private',
  connections: 'connections'
};

export type ProjectVisibility = (typeof ProjectVisibility)[keyof typeof ProjectVisibility]


export const MediaType: {
  image: 'image',
  video: 'video',
  document: 'document'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]


export const OpportunityType: {
  job: 'job',
  internship: 'internship',
  project: 'project',
  freelance: 'freelance',
  mentorship: 'mentorship'
};

export type OpportunityType = (typeof OpportunityType)[keyof typeof OpportunityType]


export const ApplicationStatus: {
  applied: 'applied',
  viewed: 'viewed',
  shortlisted: 'shortlisted',
  rejected: 'rejected',
  accepted: 'accepted'
};

export type ApplicationStatus = (typeof ApplicationStatus)[keyof typeof ApplicationStatus]


export const ConnectionType: {
  peer: 'peer',
  alumni: 'alumni',
  mentor: 'mentor',
  recruiter: 'recruiter',
  colleague: 'colleague'
};

export type ConnectionType = (typeof ConnectionType)[keyof typeof ConnectionType]


export const ConnectionStatus: {
  pending: 'pending',
  accepted: 'accepted',
  declined: 'declined'
};

export type ConnectionStatus = (typeof ConnectionStatus)[keyof typeof ConnectionStatus]


export const FeedItemType: {
  opportunity: 'opportunity',
  skill_trending: 'skill_trending',
  network_activity: 'network_activity',
  insight: 'insight',
  recommendation: 'recommendation',
  achievement: 'achievement'
};

export type FeedItemType = (typeof FeedItemType)[keyof typeof FeedItemType]


export const Priority: {
  high: 'high',
  medium: 'medium',
  low: 'low'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const NotificationType: {
  opportunity: 'opportunity',
  connection: 'connection',
  skill: 'skill',
  project: 'project',
  credential: 'credential',
  trending: 'trending'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type VerificationStatus = $Enums.VerificationStatus

export const VerificationStatus: typeof $Enums.VerificationStatus

export type SkillCategory = $Enums.SkillCategory

export const SkillCategory: typeof $Enums.SkillCategory

export type SkillLevel = $Enums.SkillLevel

export const SkillLevel: typeof $Enums.SkillLevel

export type CredentialType = $Enums.CredentialType

export const CredentialType: typeof $Enums.CredentialType

export type ProjectVisibility = $Enums.ProjectVisibility

export const ProjectVisibility: typeof $Enums.ProjectVisibility

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

export type OpportunityType = $Enums.OpportunityType

export const OpportunityType: typeof $Enums.OpportunityType

export type ApplicationStatus = $Enums.ApplicationStatus

export const ApplicationStatus: typeof $Enums.ApplicationStatus

export type ConnectionType = $Enums.ConnectionType

export const ConnectionType: typeof $Enums.ConnectionType

export type ConnectionStatus = $Enums.ConnectionStatus

export const ConnectionStatus: typeof $Enums.ConnectionStatus

export type FeedItemType = $Enums.FeedItemType

export const FeedItemType: typeof $Enums.FeedItemType

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.learnerProfile`: Exposes CRUD operations for the **LearnerProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearnerProfiles
    * const learnerProfiles = await prisma.learnerProfile.findMany()
    * ```
    */
  get learnerProfile(): Prisma.LearnerProfileDelegate<ExtArgs>;

  /**
   * `prisma.skill`: Exposes CRUD operations for the **Skill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skill.findMany()
    * ```
    */
  get skill(): Prisma.SkillDelegate<ExtArgs>;

  /**
   * `prisma.userSkill`: Exposes CRUD operations for the **UserSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSkills
    * const userSkills = await prisma.userSkill.findMany()
    * ```
    */
  get userSkill(): Prisma.UserSkillDelegate<ExtArgs>;

  /**
   * `prisma.trendingSkill`: Exposes CRUD operations for the **TrendingSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrendingSkills
    * const trendingSkills = await prisma.trendingSkill.findMany()
    * ```
    */
  get trendingSkill(): Prisma.TrendingSkillDelegate<ExtArgs>;

  /**
   * `prisma.credential`: Exposes CRUD operations for the **Credential** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Credentials
    * const credentials = await prisma.credential.findMany()
    * ```
    */
  get credential(): Prisma.CredentialDelegate<ExtArgs>;

  /**
   * `prisma.credentialSkill`: Exposes CRUD operations for the **CredentialSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CredentialSkills
    * const credentialSkills = await prisma.credentialSkill.findMany()
    * ```
    */
  get credentialSkill(): Prisma.CredentialSkillDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.projectMedia`: Exposes CRUD operations for the **ProjectMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectMedias
    * const projectMedias = await prisma.projectMedia.findMany()
    * ```
    */
  get projectMedia(): Prisma.ProjectMediaDelegate<ExtArgs>;

  /**
   * `prisma.projectSkill`: Exposes CRUD operations for the **ProjectSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectSkills
    * const projectSkills = await prisma.projectSkill.findMany()
    * ```
    */
  get projectSkill(): Prisma.ProjectSkillDelegate<ExtArgs>;

  /**
   * `prisma.projectCollaborator`: Exposes CRUD operations for the **ProjectCollaborator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectCollaborators
    * const projectCollaborators = await prisma.projectCollaborator.findMany()
    * ```
    */
  get projectCollaborator(): Prisma.ProjectCollaboratorDelegate<ExtArgs>;

  /**
   * `prisma.endorsement`: Exposes CRUD operations for the **Endorsement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Endorsements
    * const endorsements = await prisma.endorsement.findMany()
    * ```
    */
  get endorsement(): Prisma.EndorsementDelegate<ExtArgs>;

  /**
   * `prisma.opportunity`: Exposes CRUD operations for the **Opportunity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Opportunities
    * const opportunities = await prisma.opportunity.findMany()
    * ```
    */
  get opportunity(): Prisma.OpportunityDelegate<ExtArgs>;

  /**
   * `prisma.opportunityRequirement`: Exposes CRUD operations for the **OpportunityRequirement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OpportunityRequirements
    * const opportunityRequirements = await prisma.opportunityRequirement.findMany()
    * ```
    */
  get opportunityRequirement(): Prisma.OpportunityRequirementDelegate<ExtArgs>;

  /**
   * `prisma.opportunitySkill`: Exposes CRUD operations for the **OpportunitySkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OpportunitySkills
    * const opportunitySkills = await prisma.opportunitySkill.findMany()
    * ```
    */
  get opportunitySkill(): Prisma.OpportunitySkillDelegate<ExtArgs>;

  /**
   * `prisma.application`: Exposes CRUD operations for the **Application** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applications
    * const applications = await prisma.application.findMany()
    * ```
    */
  get application(): Prisma.ApplicationDelegate<ExtArgs>;

  /**
   * `prisma.connection`: Exposes CRUD operations for the **Connection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Connections
    * const connections = await prisma.connection.findMany()
    * ```
    */
  get connection(): Prisma.ConnectionDelegate<ExtArgs>;

  /**
   * `prisma.connectionRequest`: Exposes CRUD operations for the **ConnectionRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConnectionRequests
    * const connectionRequests = await prisma.connectionRequest.findMany()
    * ```
    */
  get connectionRequest(): Prisma.ConnectionRequestDelegate<ExtArgs>;

  /**
   * `prisma.feedItem`: Exposes CRUD operations for the **FeedItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeedItems
    * const feedItems = await prisma.feedItem.findMany()
    * ```
    */
  get feedItem(): Prisma.FeedItemDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.careerPath`: Exposes CRUD operations for the **CareerPath** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CareerPaths
    * const careerPaths = await prisma.careerPath.findMany()
    * ```
    */
  get careerPath(): Prisma.CareerPathDelegate<ExtArgs>;

  /**
   * `prisma.careerPathNode`: Exposes CRUD operations for the **CareerPathNode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CareerPathNodes
    * const careerPathNodes = await prisma.careerPathNode.findMany()
    * ```
    */
  get careerPathNode(): Prisma.CareerPathNodeDelegate<ExtArgs>;

  /**
   * `prisma.skillGap`: Exposes CRUD operations for the **SkillGap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkillGaps
    * const skillGaps = await prisma.skillGap.findMany()
    * ```
    */
  get skillGap(): Prisma.SkillGapDelegate<ExtArgs>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs>;

  /**
   * `prisma.courseSkill`: Exposes CRUD operations for the **CourseSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseSkills
    * const courseSkills = await prisma.courseSkill.findMany()
    * ```
    */
  get courseSkill(): Prisma.CourseSkillDelegate<ExtArgs>;

  /**
   * `prisma.verificationRequest`: Exposes CRUD operations for the **VerificationRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationRequests
    * const verificationRequests = await prisma.verificationRequest.findMany()
    * ```
    */
  get verificationRequest(): Prisma.VerificationRequestDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    LearnerProfile: 'LearnerProfile',
    Skill: 'Skill',
    UserSkill: 'UserSkill',
    TrendingSkill: 'TrendingSkill',
    Credential: 'Credential',
    CredentialSkill: 'CredentialSkill',
    Project: 'Project',
    ProjectMedia: 'ProjectMedia',
    ProjectSkill: 'ProjectSkill',
    ProjectCollaborator: 'ProjectCollaborator',
    Endorsement: 'Endorsement',
    Opportunity: 'Opportunity',
    OpportunityRequirement: 'OpportunityRequirement',
    OpportunitySkill: 'OpportunitySkill',
    Application: 'Application',
    Connection: 'Connection',
    ConnectionRequest: 'ConnectionRequest',
    FeedItem: 'FeedItem',
    Notification: 'Notification',
    CareerPath: 'CareerPath',
    CareerPathNode: 'CareerPathNode',
    SkillGap: 'SkillGap',
    Course: 'Course',
    CourseSkill: 'CourseSkill',
    VerificationRequest: 'VerificationRequest',
    Message: 'Message'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "learnerProfile" | "skill" | "userSkill" | "trendingSkill" | "credential" | "credentialSkill" | "project" | "projectMedia" | "projectSkill" | "projectCollaborator" | "endorsement" | "opportunity" | "opportunityRequirement" | "opportunitySkill" | "application" | "connection" | "connectionRequest" | "feedItem" | "notification" | "careerPath" | "careerPathNode" | "skillGap" | "course" | "courseSkill" | "verificationRequest" | "message"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      LearnerProfile: {
        payload: Prisma.$LearnerProfilePayload<ExtArgs>
        fields: Prisma.LearnerProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearnerProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnerProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearnerProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnerProfilePayload>
          }
          findFirst: {
            args: Prisma.LearnerProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnerProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearnerProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnerProfilePayload>
          }
          findMany: {
            args: Prisma.LearnerProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnerProfilePayload>[]
          }
          create: {
            args: Prisma.LearnerProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnerProfilePayload>
          }
          createMany: {
            args: Prisma.LearnerProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearnerProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnerProfilePayload>[]
          }
          delete: {
            args: Prisma.LearnerProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnerProfilePayload>
          }
          update: {
            args: Prisma.LearnerProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnerProfilePayload>
          }
          deleteMany: {
            args: Prisma.LearnerProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearnerProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LearnerProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnerProfilePayload>
          }
          aggregate: {
            args: Prisma.LearnerProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearnerProfile>
          }
          groupBy: {
            args: Prisma.LearnerProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearnerProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearnerProfileCountArgs<ExtArgs>
            result: $Utils.Optional<LearnerProfileCountAggregateOutputType> | number
          }
        }
      }
      Skill: {
        payload: Prisma.$SkillPayload<ExtArgs>
        fields: Prisma.SkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findFirst: {
            args: Prisma.SkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findMany: {
            args: Prisma.SkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          create: {
            args: Prisma.SkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          createMany: {
            args: Prisma.SkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          delete: {
            args: Prisma.SkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          update: {
            args: Prisma.SkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          deleteMany: {
            args: Prisma.SkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          aggregate: {
            args: Prisma.SkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkill>
          }
          groupBy: {
            args: Prisma.SkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillCountArgs<ExtArgs>
            result: $Utils.Optional<SkillCountAggregateOutputType> | number
          }
        }
      }
      UserSkill: {
        payload: Prisma.$UserSkillPayload<ExtArgs>
        fields: Prisma.UserSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillPayload>
          }
          findFirst: {
            args: Prisma.UserSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillPayload>
          }
          findMany: {
            args: Prisma.UserSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillPayload>[]
          }
          create: {
            args: Prisma.UserSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillPayload>
          }
          createMany: {
            args: Prisma.UserSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillPayload>[]
          }
          delete: {
            args: Prisma.UserSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillPayload>
          }
          update: {
            args: Prisma.UserSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillPayload>
          }
          deleteMany: {
            args: Prisma.UserSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillPayload>
          }
          aggregate: {
            args: Prisma.UserSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSkill>
          }
          groupBy: {
            args: Prisma.UserSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSkillCountArgs<ExtArgs>
            result: $Utils.Optional<UserSkillCountAggregateOutputType> | number
          }
        }
      }
      TrendingSkill: {
        payload: Prisma.$TrendingSkillPayload<ExtArgs>
        fields: Prisma.TrendingSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrendingSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrendingSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingSkillPayload>
          }
          findFirst: {
            args: Prisma.TrendingSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrendingSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingSkillPayload>
          }
          findMany: {
            args: Prisma.TrendingSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingSkillPayload>[]
          }
          create: {
            args: Prisma.TrendingSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingSkillPayload>
          }
          createMany: {
            args: Prisma.TrendingSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrendingSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingSkillPayload>[]
          }
          delete: {
            args: Prisma.TrendingSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingSkillPayload>
          }
          update: {
            args: Prisma.TrendingSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingSkillPayload>
          }
          deleteMany: {
            args: Prisma.TrendingSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrendingSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrendingSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingSkillPayload>
          }
          aggregate: {
            args: Prisma.TrendingSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrendingSkill>
          }
          groupBy: {
            args: Prisma.TrendingSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrendingSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrendingSkillCountArgs<ExtArgs>
            result: $Utils.Optional<TrendingSkillCountAggregateOutputType> | number
          }
        }
      }
      Credential: {
        payload: Prisma.$CredentialPayload<ExtArgs>
        fields: Prisma.CredentialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CredentialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CredentialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          findFirst: {
            args: Prisma.CredentialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CredentialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          findMany: {
            args: Prisma.CredentialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>[]
          }
          create: {
            args: Prisma.CredentialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          createMany: {
            args: Prisma.CredentialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CredentialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>[]
          }
          delete: {
            args: Prisma.CredentialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          update: {
            args: Prisma.CredentialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          deleteMany: {
            args: Prisma.CredentialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CredentialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CredentialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          aggregate: {
            args: Prisma.CredentialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCredential>
          }
          groupBy: {
            args: Prisma.CredentialGroupByArgs<ExtArgs>
            result: $Utils.Optional<CredentialGroupByOutputType>[]
          }
          count: {
            args: Prisma.CredentialCountArgs<ExtArgs>
            result: $Utils.Optional<CredentialCountAggregateOutputType> | number
          }
        }
      }
      CredentialSkill: {
        payload: Prisma.$CredentialSkillPayload<ExtArgs>
        fields: Prisma.CredentialSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CredentialSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CredentialSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialSkillPayload>
          }
          findFirst: {
            args: Prisma.CredentialSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CredentialSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialSkillPayload>
          }
          findMany: {
            args: Prisma.CredentialSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialSkillPayload>[]
          }
          create: {
            args: Prisma.CredentialSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialSkillPayload>
          }
          createMany: {
            args: Prisma.CredentialSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CredentialSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialSkillPayload>[]
          }
          delete: {
            args: Prisma.CredentialSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialSkillPayload>
          }
          update: {
            args: Prisma.CredentialSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialSkillPayload>
          }
          deleteMany: {
            args: Prisma.CredentialSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CredentialSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CredentialSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialSkillPayload>
          }
          aggregate: {
            args: Prisma.CredentialSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCredentialSkill>
          }
          groupBy: {
            args: Prisma.CredentialSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<CredentialSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.CredentialSkillCountArgs<ExtArgs>
            result: $Utils.Optional<CredentialSkillCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectMedia: {
        payload: Prisma.$ProjectMediaPayload<ExtArgs>
        fields: Prisma.ProjectMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectMediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectMediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMediaPayload>
          }
          findFirst: {
            args: Prisma.ProjectMediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectMediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMediaPayload>
          }
          findMany: {
            args: Prisma.ProjectMediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMediaPayload>[]
          }
          create: {
            args: Prisma.ProjectMediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMediaPayload>
          }
          createMany: {
            args: Prisma.ProjectMediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectMediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMediaPayload>[]
          }
          delete: {
            args: Prisma.ProjectMediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMediaPayload>
          }
          update: {
            args: Prisma.ProjectMediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMediaPayload>
          }
          deleteMany: {
            args: Prisma.ProjectMediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectMediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectMediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMediaPayload>
          }
          aggregate: {
            args: Prisma.ProjectMediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectMedia>
          }
          groupBy: {
            args: Prisma.ProjectMediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectMediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectMediaCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectMediaCountAggregateOutputType> | number
          }
        }
      }
      ProjectSkill: {
        payload: Prisma.$ProjectSkillPayload<ExtArgs>
        fields: Prisma.ProjectSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSkillPayload>
          }
          findFirst: {
            args: Prisma.ProjectSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSkillPayload>
          }
          findMany: {
            args: Prisma.ProjectSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSkillPayload>[]
          }
          create: {
            args: Prisma.ProjectSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSkillPayload>
          }
          createMany: {
            args: Prisma.ProjectSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSkillPayload>[]
          }
          delete: {
            args: Prisma.ProjectSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSkillPayload>
          }
          update: {
            args: Prisma.ProjectSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSkillPayload>
          }
          deleteMany: {
            args: Prisma.ProjectSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSkillPayload>
          }
          aggregate: {
            args: Prisma.ProjectSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectSkill>
          }
          groupBy: {
            args: Prisma.ProjectSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectSkillCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectSkillCountAggregateOutputType> | number
          }
        }
      }
      ProjectCollaborator: {
        payload: Prisma.$ProjectCollaboratorPayload<ExtArgs>
        fields: Prisma.ProjectCollaboratorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectCollaboratorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectCollaboratorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>
          }
          findFirst: {
            args: Prisma.ProjectCollaboratorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectCollaboratorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>
          }
          findMany: {
            args: Prisma.ProjectCollaboratorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>[]
          }
          create: {
            args: Prisma.ProjectCollaboratorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>
          }
          createMany: {
            args: Prisma.ProjectCollaboratorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCollaboratorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>[]
          }
          delete: {
            args: Prisma.ProjectCollaboratorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>
          }
          update: {
            args: Prisma.ProjectCollaboratorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>
          }
          deleteMany: {
            args: Prisma.ProjectCollaboratorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectCollaboratorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectCollaboratorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>
          }
          aggregate: {
            args: Prisma.ProjectCollaboratorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectCollaborator>
          }
          groupBy: {
            args: Prisma.ProjectCollaboratorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectCollaboratorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCollaboratorCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCollaboratorCountAggregateOutputType> | number
          }
        }
      }
      Endorsement: {
        payload: Prisma.$EndorsementPayload<ExtArgs>
        fields: Prisma.EndorsementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EndorsementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndorsementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EndorsementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndorsementPayload>
          }
          findFirst: {
            args: Prisma.EndorsementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndorsementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EndorsementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndorsementPayload>
          }
          findMany: {
            args: Prisma.EndorsementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndorsementPayload>[]
          }
          create: {
            args: Prisma.EndorsementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndorsementPayload>
          }
          createMany: {
            args: Prisma.EndorsementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EndorsementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndorsementPayload>[]
          }
          delete: {
            args: Prisma.EndorsementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndorsementPayload>
          }
          update: {
            args: Prisma.EndorsementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndorsementPayload>
          }
          deleteMany: {
            args: Prisma.EndorsementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EndorsementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EndorsementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndorsementPayload>
          }
          aggregate: {
            args: Prisma.EndorsementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEndorsement>
          }
          groupBy: {
            args: Prisma.EndorsementGroupByArgs<ExtArgs>
            result: $Utils.Optional<EndorsementGroupByOutputType>[]
          }
          count: {
            args: Prisma.EndorsementCountArgs<ExtArgs>
            result: $Utils.Optional<EndorsementCountAggregateOutputType> | number
          }
        }
      }
      Opportunity: {
        payload: Prisma.$OpportunityPayload<ExtArgs>
        fields: Prisma.OpportunityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpportunityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpportunityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          findFirst: {
            args: Prisma.OpportunityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpportunityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          findMany: {
            args: Prisma.OpportunityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>[]
          }
          create: {
            args: Prisma.OpportunityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          createMany: {
            args: Prisma.OpportunityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OpportunityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>[]
          }
          delete: {
            args: Prisma.OpportunityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          update: {
            args: Prisma.OpportunityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          deleteMany: {
            args: Prisma.OpportunityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpportunityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OpportunityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          aggregate: {
            args: Prisma.OpportunityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpportunity>
          }
          groupBy: {
            args: Prisma.OpportunityGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpportunityGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpportunityCountArgs<ExtArgs>
            result: $Utils.Optional<OpportunityCountAggregateOutputType> | number
          }
        }
      }
      OpportunityRequirement: {
        payload: Prisma.$OpportunityRequirementPayload<ExtArgs>
        fields: Prisma.OpportunityRequirementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpportunityRequirementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityRequirementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpportunityRequirementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityRequirementPayload>
          }
          findFirst: {
            args: Prisma.OpportunityRequirementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityRequirementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpportunityRequirementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityRequirementPayload>
          }
          findMany: {
            args: Prisma.OpportunityRequirementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityRequirementPayload>[]
          }
          create: {
            args: Prisma.OpportunityRequirementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityRequirementPayload>
          }
          createMany: {
            args: Prisma.OpportunityRequirementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OpportunityRequirementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityRequirementPayload>[]
          }
          delete: {
            args: Prisma.OpportunityRequirementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityRequirementPayload>
          }
          update: {
            args: Prisma.OpportunityRequirementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityRequirementPayload>
          }
          deleteMany: {
            args: Prisma.OpportunityRequirementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpportunityRequirementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OpportunityRequirementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityRequirementPayload>
          }
          aggregate: {
            args: Prisma.OpportunityRequirementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpportunityRequirement>
          }
          groupBy: {
            args: Prisma.OpportunityRequirementGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpportunityRequirementGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpportunityRequirementCountArgs<ExtArgs>
            result: $Utils.Optional<OpportunityRequirementCountAggregateOutputType> | number
          }
        }
      }
      OpportunitySkill: {
        payload: Prisma.$OpportunitySkillPayload<ExtArgs>
        fields: Prisma.OpportunitySkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpportunitySkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunitySkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpportunitySkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunitySkillPayload>
          }
          findFirst: {
            args: Prisma.OpportunitySkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunitySkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpportunitySkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunitySkillPayload>
          }
          findMany: {
            args: Prisma.OpportunitySkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunitySkillPayload>[]
          }
          create: {
            args: Prisma.OpportunitySkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunitySkillPayload>
          }
          createMany: {
            args: Prisma.OpportunitySkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OpportunitySkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunitySkillPayload>[]
          }
          delete: {
            args: Prisma.OpportunitySkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunitySkillPayload>
          }
          update: {
            args: Prisma.OpportunitySkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunitySkillPayload>
          }
          deleteMany: {
            args: Prisma.OpportunitySkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpportunitySkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OpportunitySkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunitySkillPayload>
          }
          aggregate: {
            args: Prisma.OpportunitySkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpportunitySkill>
          }
          groupBy: {
            args: Prisma.OpportunitySkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpportunitySkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpportunitySkillCountArgs<ExtArgs>
            result: $Utils.Optional<OpportunitySkillCountAggregateOutputType> | number
          }
        }
      }
      Application: {
        payload: Prisma.$ApplicationPayload<ExtArgs>
        fields: Prisma.ApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          findFirst: {
            args: Prisma.ApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          findMany: {
            args: Prisma.ApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[]
          }
          create: {
            args: Prisma.ApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          createMany: {
            args: Prisma.ApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[]
          }
          delete: {
            args: Prisma.ApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          update: {
            args: Prisma.ApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          deleteMany: {
            args: Prisma.ApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          aggregate: {
            args: Prisma.ApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplication>
          }
          groupBy: {
            args: Prisma.ApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationCountAggregateOutputType> | number
          }
        }
      }
      Connection: {
        payload: Prisma.$ConnectionPayload<ExtArgs>
        fields: Prisma.ConnectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConnectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConnectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          findFirst: {
            args: Prisma.ConnectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConnectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          findMany: {
            args: Prisma.ConnectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>[]
          }
          create: {
            args: Prisma.ConnectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          createMany: {
            args: Prisma.ConnectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConnectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>[]
          }
          delete: {
            args: Prisma.ConnectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          update: {
            args: Prisma.ConnectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          deleteMany: {
            args: Prisma.ConnectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConnectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConnectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          aggregate: {
            args: Prisma.ConnectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConnection>
          }
          groupBy: {
            args: Prisma.ConnectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConnectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConnectionCountArgs<ExtArgs>
            result: $Utils.Optional<ConnectionCountAggregateOutputType> | number
          }
        }
      }
      ConnectionRequest: {
        payload: Prisma.$ConnectionRequestPayload<ExtArgs>
        fields: Prisma.ConnectionRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConnectionRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConnectionRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionRequestPayload>
          }
          findFirst: {
            args: Prisma.ConnectionRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConnectionRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionRequestPayload>
          }
          findMany: {
            args: Prisma.ConnectionRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionRequestPayload>[]
          }
          create: {
            args: Prisma.ConnectionRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionRequestPayload>
          }
          createMany: {
            args: Prisma.ConnectionRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConnectionRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionRequestPayload>[]
          }
          delete: {
            args: Prisma.ConnectionRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionRequestPayload>
          }
          update: {
            args: Prisma.ConnectionRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionRequestPayload>
          }
          deleteMany: {
            args: Prisma.ConnectionRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConnectionRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConnectionRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionRequestPayload>
          }
          aggregate: {
            args: Prisma.ConnectionRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConnectionRequest>
          }
          groupBy: {
            args: Prisma.ConnectionRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConnectionRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConnectionRequestCountArgs<ExtArgs>
            result: $Utils.Optional<ConnectionRequestCountAggregateOutputType> | number
          }
        }
      }
      FeedItem: {
        payload: Prisma.$FeedItemPayload<ExtArgs>
        fields: Prisma.FeedItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedItemPayload>
          }
          findFirst: {
            args: Prisma.FeedItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedItemPayload>
          }
          findMany: {
            args: Prisma.FeedItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedItemPayload>[]
          }
          create: {
            args: Prisma.FeedItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedItemPayload>
          }
          createMany: {
            args: Prisma.FeedItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedItemPayload>[]
          }
          delete: {
            args: Prisma.FeedItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedItemPayload>
          }
          update: {
            args: Prisma.FeedItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedItemPayload>
          }
          deleteMany: {
            args: Prisma.FeedItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeedItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedItemPayload>
          }
          aggregate: {
            args: Prisma.FeedItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedItem>
          }
          groupBy: {
            args: Prisma.FeedItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedItemCountArgs<ExtArgs>
            result: $Utils.Optional<FeedItemCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      CareerPath: {
        payload: Prisma.$CareerPathPayload<ExtArgs>
        fields: Prisma.CareerPathFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CareerPathFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPathPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CareerPathFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPathPayload>
          }
          findFirst: {
            args: Prisma.CareerPathFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPathPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CareerPathFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPathPayload>
          }
          findMany: {
            args: Prisma.CareerPathFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPathPayload>[]
          }
          create: {
            args: Prisma.CareerPathCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPathPayload>
          }
          createMany: {
            args: Prisma.CareerPathCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CareerPathCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPathPayload>[]
          }
          delete: {
            args: Prisma.CareerPathDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPathPayload>
          }
          update: {
            args: Prisma.CareerPathUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPathPayload>
          }
          deleteMany: {
            args: Prisma.CareerPathDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CareerPathUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CareerPathUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPathPayload>
          }
          aggregate: {
            args: Prisma.CareerPathAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCareerPath>
          }
          groupBy: {
            args: Prisma.CareerPathGroupByArgs<ExtArgs>
            result: $Utils.Optional<CareerPathGroupByOutputType>[]
          }
          count: {
            args: Prisma.CareerPathCountArgs<ExtArgs>
            result: $Utils.Optional<CareerPathCountAggregateOutputType> | number
          }
        }
      }
      CareerPathNode: {
        payload: Prisma.$CareerPathNodePayload<ExtArgs>
        fields: Prisma.CareerPathNodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CareerPathNodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPathNodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CareerPathNodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPathNodePayload>
          }
          findFirst: {
            args: Prisma.CareerPathNodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPathNodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CareerPathNodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPathNodePayload>
          }
          findMany: {
            args: Prisma.CareerPathNodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPathNodePayload>[]
          }
          create: {
            args: Prisma.CareerPathNodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPathNodePayload>
          }
          createMany: {
            args: Prisma.CareerPathNodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CareerPathNodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPathNodePayload>[]
          }
          delete: {
            args: Prisma.CareerPathNodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPathNodePayload>
          }
          update: {
            args: Prisma.CareerPathNodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPathNodePayload>
          }
          deleteMany: {
            args: Prisma.CareerPathNodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CareerPathNodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CareerPathNodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPathNodePayload>
          }
          aggregate: {
            args: Prisma.CareerPathNodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCareerPathNode>
          }
          groupBy: {
            args: Prisma.CareerPathNodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CareerPathNodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CareerPathNodeCountArgs<ExtArgs>
            result: $Utils.Optional<CareerPathNodeCountAggregateOutputType> | number
          }
        }
      }
      SkillGap: {
        payload: Prisma.$SkillGapPayload<ExtArgs>
        fields: Prisma.SkillGapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillGapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillGapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillGapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillGapPayload>
          }
          findFirst: {
            args: Prisma.SkillGapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillGapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillGapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillGapPayload>
          }
          findMany: {
            args: Prisma.SkillGapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillGapPayload>[]
          }
          create: {
            args: Prisma.SkillGapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillGapPayload>
          }
          createMany: {
            args: Prisma.SkillGapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkillGapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillGapPayload>[]
          }
          delete: {
            args: Prisma.SkillGapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillGapPayload>
          }
          update: {
            args: Prisma.SkillGapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillGapPayload>
          }
          deleteMany: {
            args: Prisma.SkillGapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillGapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SkillGapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillGapPayload>
          }
          aggregate: {
            args: Prisma.SkillGapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkillGap>
          }
          groupBy: {
            args: Prisma.SkillGapGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillGapGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillGapCountArgs<ExtArgs>
            result: $Utils.Optional<SkillGapCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      CourseSkill: {
        payload: Prisma.$CourseSkillPayload<ExtArgs>
        fields: Prisma.CourseSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseSkillPayload>
          }
          findFirst: {
            args: Prisma.CourseSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseSkillPayload>
          }
          findMany: {
            args: Prisma.CourseSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseSkillPayload>[]
          }
          create: {
            args: Prisma.CourseSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseSkillPayload>
          }
          createMany: {
            args: Prisma.CourseSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseSkillPayload>[]
          }
          delete: {
            args: Prisma.CourseSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseSkillPayload>
          }
          update: {
            args: Prisma.CourseSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseSkillPayload>
          }
          deleteMany: {
            args: Prisma.CourseSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseSkillPayload>
          }
          aggregate: {
            args: Prisma.CourseSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseSkill>
          }
          groupBy: {
            args: Prisma.CourseSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseSkillCountArgs<ExtArgs>
            result: $Utils.Optional<CourseSkillCountAggregateOutputType> | number
          }
        }
      }
      VerificationRequest: {
        payload: Prisma.$VerificationRequestPayload<ExtArgs>
        fields: Prisma.VerificationRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationRequestPayload>
          }
          findFirst: {
            args: Prisma.VerificationRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationRequestPayload>
          }
          findMany: {
            args: Prisma.VerificationRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationRequestPayload>[]
          }
          create: {
            args: Prisma.VerificationRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationRequestPayload>
          }
          createMany: {
            args: Prisma.VerificationRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationRequestPayload>[]
          }
          delete: {
            args: Prisma.VerificationRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationRequestPayload>
          }
          update: {
            args: Prisma.VerificationRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationRequestPayload>
          }
          deleteMany: {
            args: Prisma.VerificationRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationRequestPayload>
          }
          aggregate: {
            args: Prisma.VerificationRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationRequest>
          }
          groupBy: {
            args: Prisma.VerificationRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationRequestCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationRequestCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    userSkills: number
    credentials: number
    projects: number
    applications: number
    connectionsSent: number
    connectionsReceived: number
    connectionRequestsSent: number
    connectionRequestsReceived: number
    feedItems: number
    notifications: number
    careerPaths: number
    messagesSent: number
    messagesReceived: number
    projectCollaborations: number
    endorsements: number
    verificationRequests: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userSkills?: boolean | UserCountOutputTypeCountUserSkillsArgs
    credentials?: boolean | UserCountOutputTypeCountCredentialsArgs
    projects?: boolean | UserCountOutputTypeCountProjectsArgs
    applications?: boolean | UserCountOutputTypeCountApplicationsArgs
    connectionsSent?: boolean | UserCountOutputTypeCountConnectionsSentArgs
    connectionsReceived?: boolean | UserCountOutputTypeCountConnectionsReceivedArgs
    connectionRequestsSent?: boolean | UserCountOutputTypeCountConnectionRequestsSentArgs
    connectionRequestsReceived?: boolean | UserCountOutputTypeCountConnectionRequestsReceivedArgs
    feedItems?: boolean | UserCountOutputTypeCountFeedItemsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    careerPaths?: boolean | UserCountOutputTypeCountCareerPathsArgs
    messagesSent?: boolean | UserCountOutputTypeCountMessagesSentArgs
    messagesReceived?: boolean | UserCountOutputTypeCountMessagesReceivedArgs
    projectCollaborations?: boolean | UserCountOutputTypeCountProjectCollaborationsArgs
    endorsements?: boolean | UserCountOutputTypeCountEndorsementsArgs
    verificationRequests?: boolean | UserCountOutputTypeCountVerificationRequestsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSkillWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCredentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CredentialWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConnectionsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConnectionsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConnectionRequestsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConnectionRequestsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCareerPathsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CareerPathWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectCollaborationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectCollaboratorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEndorsementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EndorsementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVerificationRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationRequestWhereInput
  }


  /**
   * Count Type SkillCountOutputType
   */

  export type SkillCountOutputType = {
    userSkills: number
    credentialSkills: number
    projectSkills: number
    opportunitySkills: number
    courseSkills: number
    skillGaps: number
  }

  export type SkillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userSkills?: boolean | SkillCountOutputTypeCountUserSkillsArgs
    credentialSkills?: boolean | SkillCountOutputTypeCountCredentialSkillsArgs
    projectSkills?: boolean | SkillCountOutputTypeCountProjectSkillsArgs
    opportunitySkills?: boolean | SkillCountOutputTypeCountOpportunitySkillsArgs
    courseSkills?: boolean | SkillCountOutputTypeCountCourseSkillsArgs
    skillGaps?: boolean | SkillCountOutputTypeCountSkillGapsArgs
  }

  // Custom InputTypes
  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCountOutputType
     */
    select?: SkillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountUserSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSkillWhereInput
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountCredentialSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CredentialSkillWhereInput
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountProjectSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectSkillWhereInput
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountOpportunitySkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunitySkillWhereInput
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountCourseSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseSkillWhereInput
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountSkillGapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillGapWhereInput
  }


  /**
   * Count Type CredentialCountOutputType
   */

  export type CredentialCountOutputType = {
    skills: number
    verificationRequests: number
  }

  export type CredentialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills?: boolean | CredentialCountOutputTypeCountSkillsArgs
    verificationRequests?: boolean | CredentialCountOutputTypeCountVerificationRequestsArgs
  }

  // Custom InputTypes
  /**
   * CredentialCountOutputType without action
   */
  export type CredentialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialCountOutputType
     */
    select?: CredentialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CredentialCountOutputType without action
   */
  export type CredentialCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CredentialSkillWhereInput
  }

  /**
   * CredentialCountOutputType without action
   */
  export type CredentialCountOutputTypeCountVerificationRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationRequestWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    media: number
    skills: number
    collaborators: number
    endorsements: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | ProjectCountOutputTypeCountMediaArgs
    skills?: boolean | ProjectCountOutputTypeCountSkillsArgs
    collaborators?: boolean | ProjectCountOutputTypeCountCollaboratorsArgs
    endorsements?: boolean | ProjectCountOutputTypeCountEndorsementsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMediaWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectSkillWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountCollaboratorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectCollaboratorWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountEndorsementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EndorsementWhereInput
  }


  /**
   * Count Type OpportunityCountOutputType
   */

  export type OpportunityCountOutputType = {
    requirements: number
    skills: number
    applications: number
  }

  export type OpportunityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirements?: boolean | OpportunityCountOutputTypeCountRequirementsArgs
    skills?: boolean | OpportunityCountOutputTypeCountSkillsArgs
    applications?: boolean | OpportunityCountOutputTypeCountApplicationsArgs
  }

  // Custom InputTypes
  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityCountOutputType
     */
    select?: OpportunityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeCountRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityRequirementWhereInput
  }

  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunitySkillWhereInput
  }

  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
  }


  /**
   * Count Type CareerPathCountOutputType
   */

  export type CareerPathCountOutputType = {
    nodes: number
    skillGaps: number
  }

  export type CareerPathCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nodes?: boolean | CareerPathCountOutputTypeCountNodesArgs
    skillGaps?: boolean | CareerPathCountOutputTypeCountSkillGapsArgs
  }

  // Custom InputTypes
  /**
   * CareerPathCountOutputType without action
   */
  export type CareerPathCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPathCountOutputType
     */
    select?: CareerPathCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CareerPathCountOutputType without action
   */
  export type CareerPathCountOutputTypeCountNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CareerPathNodeWhereInput
  }

  /**
   * CareerPathCountOutputType without action
   */
  export type CareerPathCountOutputTypeCountSkillGapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillGapWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    skills: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills?: boolean | CourseCountOutputTypeCountSkillsArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseSkillWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    passwordHash: string | null
    avatar: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    passwordHash: string | null
    avatar: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    passwordHash: number
    avatar: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    avatar?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    avatar?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    avatar?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    passwordHash: string
    avatar: string | null
    role: $Enums.UserRole
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    avatar?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    learnerProfile?: boolean | User$learnerProfileArgs<ExtArgs>
    userSkills?: boolean | User$userSkillsArgs<ExtArgs>
    credentials?: boolean | User$credentialsArgs<ExtArgs>
    projects?: boolean | User$projectsArgs<ExtArgs>
    applications?: boolean | User$applicationsArgs<ExtArgs>
    connectionsSent?: boolean | User$connectionsSentArgs<ExtArgs>
    connectionsReceived?: boolean | User$connectionsReceivedArgs<ExtArgs>
    connectionRequestsSent?: boolean | User$connectionRequestsSentArgs<ExtArgs>
    connectionRequestsReceived?: boolean | User$connectionRequestsReceivedArgs<ExtArgs>
    feedItems?: boolean | User$feedItemsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    careerPaths?: boolean | User$careerPathsArgs<ExtArgs>
    messagesSent?: boolean | User$messagesSentArgs<ExtArgs>
    messagesReceived?: boolean | User$messagesReceivedArgs<ExtArgs>
    projectCollaborations?: boolean | User$projectCollaborationsArgs<ExtArgs>
    endorsements?: boolean | User$endorsementsArgs<ExtArgs>
    verificationRequests?: boolean | User$verificationRequestsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    avatar?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    avatar?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learnerProfile?: boolean | User$learnerProfileArgs<ExtArgs>
    userSkills?: boolean | User$userSkillsArgs<ExtArgs>
    credentials?: boolean | User$credentialsArgs<ExtArgs>
    projects?: boolean | User$projectsArgs<ExtArgs>
    applications?: boolean | User$applicationsArgs<ExtArgs>
    connectionsSent?: boolean | User$connectionsSentArgs<ExtArgs>
    connectionsReceived?: boolean | User$connectionsReceivedArgs<ExtArgs>
    connectionRequestsSent?: boolean | User$connectionRequestsSentArgs<ExtArgs>
    connectionRequestsReceived?: boolean | User$connectionRequestsReceivedArgs<ExtArgs>
    feedItems?: boolean | User$feedItemsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    careerPaths?: boolean | User$careerPathsArgs<ExtArgs>
    messagesSent?: boolean | User$messagesSentArgs<ExtArgs>
    messagesReceived?: boolean | User$messagesReceivedArgs<ExtArgs>
    projectCollaborations?: boolean | User$projectCollaborationsArgs<ExtArgs>
    endorsements?: boolean | User$endorsementsArgs<ExtArgs>
    verificationRequests?: boolean | User$verificationRequestsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      learnerProfile: Prisma.$LearnerProfilePayload<ExtArgs> | null
      userSkills: Prisma.$UserSkillPayload<ExtArgs>[]
      credentials: Prisma.$CredentialPayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      applications: Prisma.$ApplicationPayload<ExtArgs>[]
      connectionsSent: Prisma.$ConnectionPayload<ExtArgs>[]
      connectionsReceived: Prisma.$ConnectionPayload<ExtArgs>[]
      connectionRequestsSent: Prisma.$ConnectionRequestPayload<ExtArgs>[]
      connectionRequestsReceived: Prisma.$ConnectionRequestPayload<ExtArgs>[]
      feedItems: Prisma.$FeedItemPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      careerPaths: Prisma.$CareerPathPayload<ExtArgs>[]
      messagesSent: Prisma.$MessagePayload<ExtArgs>[]
      messagesReceived: Prisma.$MessagePayload<ExtArgs>[]
      projectCollaborations: Prisma.$ProjectCollaboratorPayload<ExtArgs>[]
      endorsements: Prisma.$EndorsementPayload<ExtArgs>[]
      verificationRequests: Prisma.$VerificationRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      passwordHash: string
      avatar: string | null
      role: $Enums.UserRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    learnerProfile<T extends User$learnerProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$learnerProfileArgs<ExtArgs>>): Prisma__LearnerProfileClient<$Result.GetResult<Prisma.$LearnerProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    userSkills<T extends User$userSkillsArgs<ExtArgs> = {}>(args?: Subset<T, User$userSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "findMany"> | Null>
    credentials<T extends User$credentialsArgs<ExtArgs> = {}>(args?: Subset<T, User$credentialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findMany"> | Null>
    projects<T extends User$projectsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    applications<T extends User$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, User$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    connectionsSent<T extends User$connectionsSentArgs<ExtArgs> = {}>(args?: Subset<T, User$connectionsSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findMany"> | Null>
    connectionsReceived<T extends User$connectionsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$connectionsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findMany"> | Null>
    connectionRequestsSent<T extends User$connectionRequestsSentArgs<ExtArgs> = {}>(args?: Subset<T, User$connectionRequestsSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionRequestPayload<ExtArgs>, T, "findMany"> | Null>
    connectionRequestsReceived<T extends User$connectionRequestsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$connectionRequestsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionRequestPayload<ExtArgs>, T, "findMany"> | Null>
    feedItems<T extends User$feedItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$feedItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    careerPaths<T extends User$careerPathsArgs<ExtArgs> = {}>(args?: Subset<T, User$careerPathsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareerPathPayload<ExtArgs>, T, "findMany"> | Null>
    messagesSent<T extends User$messagesSentArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    messagesReceived<T extends User$messagesReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    projectCollaborations<T extends User$projectCollaborationsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectCollaborationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "findMany"> | Null>
    endorsements<T extends User$endorsementsArgs<ExtArgs> = {}>(args?: Subset<T, User$endorsementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EndorsementPayload<ExtArgs>, T, "findMany"> | Null>
    verificationRequests<T extends User$verificationRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$verificationRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationRequestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.learnerProfile
   */
  export type User$learnerProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnerProfile
     */
    select?: LearnerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerProfileInclude<ExtArgs> | null
    where?: LearnerProfileWhereInput
  }

  /**
   * User.userSkills
   */
  export type User$userSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillInclude<ExtArgs> | null
    where?: UserSkillWhereInput
    orderBy?: UserSkillOrderByWithRelationInput | UserSkillOrderByWithRelationInput[]
    cursor?: UserSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSkillScalarFieldEnum | UserSkillScalarFieldEnum[]
  }

  /**
   * User.credentials
   */
  export type User$credentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    where?: CredentialWhereInput
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    cursor?: CredentialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CredentialScalarFieldEnum | CredentialScalarFieldEnum[]
  }

  /**
   * User.projects
   */
  export type User$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.applications
   */
  export type User$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    cursor?: ApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * User.connectionsSent
   */
  export type User$connectionsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    where?: ConnectionWhereInput
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    cursor?: ConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * User.connectionsReceived
   */
  export type User$connectionsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    where?: ConnectionWhereInput
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    cursor?: ConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * User.connectionRequestsSent
   */
  export type User$connectionRequestsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionRequest
     */
    select?: ConnectionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionRequestInclude<ExtArgs> | null
    where?: ConnectionRequestWhereInput
    orderBy?: ConnectionRequestOrderByWithRelationInput | ConnectionRequestOrderByWithRelationInput[]
    cursor?: ConnectionRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConnectionRequestScalarFieldEnum | ConnectionRequestScalarFieldEnum[]
  }

  /**
   * User.connectionRequestsReceived
   */
  export type User$connectionRequestsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionRequest
     */
    select?: ConnectionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionRequestInclude<ExtArgs> | null
    where?: ConnectionRequestWhereInput
    orderBy?: ConnectionRequestOrderByWithRelationInput | ConnectionRequestOrderByWithRelationInput[]
    cursor?: ConnectionRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConnectionRequestScalarFieldEnum | ConnectionRequestScalarFieldEnum[]
  }

  /**
   * User.feedItems
   */
  export type User$feedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemInclude<ExtArgs> | null
    where?: FeedItemWhereInput
    orderBy?: FeedItemOrderByWithRelationInput | FeedItemOrderByWithRelationInput[]
    cursor?: FeedItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedItemScalarFieldEnum | FeedItemScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.careerPaths
   */
  export type User$careerPathsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPath
     */
    select?: CareerPathSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerPathInclude<ExtArgs> | null
    where?: CareerPathWhereInput
    orderBy?: CareerPathOrderByWithRelationInput | CareerPathOrderByWithRelationInput[]
    cursor?: CareerPathWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CareerPathScalarFieldEnum | CareerPathScalarFieldEnum[]
  }

  /**
   * User.messagesSent
   */
  export type User$messagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.messagesReceived
   */
  export type User$messagesReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.projectCollaborations
   */
  export type User$projectCollaborationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    where?: ProjectCollaboratorWhereInput
    orderBy?: ProjectCollaboratorOrderByWithRelationInput | ProjectCollaboratorOrderByWithRelationInput[]
    cursor?: ProjectCollaboratorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectCollaboratorScalarFieldEnum | ProjectCollaboratorScalarFieldEnum[]
  }

  /**
   * User.endorsements
   */
  export type User$endorsementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endorsement
     */
    select?: EndorsementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndorsementInclude<ExtArgs> | null
    where?: EndorsementWhereInput
    orderBy?: EndorsementOrderByWithRelationInput | EndorsementOrderByWithRelationInput[]
    cursor?: EndorsementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EndorsementScalarFieldEnum | EndorsementScalarFieldEnum[]
  }

  /**
   * User.verificationRequests
   */
  export type User$verificationRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationRequestInclude<ExtArgs> | null
    where?: VerificationRequestWhereInput
    orderBy?: VerificationRequestOrderByWithRelationInput | VerificationRequestOrderByWithRelationInput[]
    cursor?: VerificationRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerificationRequestScalarFieldEnum | VerificationRequestScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model LearnerProfile
   */

  export type AggregateLearnerProfile = {
    _count: LearnerProfileCountAggregateOutputType | null
    _avg: LearnerProfileAvgAggregateOutputType | null
    _sum: LearnerProfileSumAggregateOutputType | null
    _min: LearnerProfileMinAggregateOutputType | null
    _max: LearnerProfileMaxAggregateOutputType | null
  }

  export type LearnerProfileAvgAggregateOutputType = {
    graduationYear: number | null
    skillsMatchPercentage: number | null
  }

  export type LearnerProfileSumAggregateOutputType = {
    graduationYear: number | null
    skillsMatchPercentage: number | null
  }

  export type LearnerProfileMinAggregateOutputType = {
    userId: string | null
    bio: string | null
    location: string | null
    university: string | null
    major: string | null
    graduationYear: number | null
    skillsMatchPercentage: number | null
    verificationStatus: $Enums.VerificationStatus | null
  }

  export type LearnerProfileMaxAggregateOutputType = {
    userId: string | null
    bio: string | null
    location: string | null
    university: string | null
    major: string | null
    graduationYear: number | null
    skillsMatchPercentage: number | null
    verificationStatus: $Enums.VerificationStatus | null
  }

  export type LearnerProfileCountAggregateOutputType = {
    userId: number
    bio: number
    location: number
    university: number
    major: number
    graduationYear: number
    skillsMatchPercentage: number
    verificationStatus: number
    _all: number
  }


  export type LearnerProfileAvgAggregateInputType = {
    graduationYear?: true
    skillsMatchPercentage?: true
  }

  export type LearnerProfileSumAggregateInputType = {
    graduationYear?: true
    skillsMatchPercentage?: true
  }

  export type LearnerProfileMinAggregateInputType = {
    userId?: true
    bio?: true
    location?: true
    university?: true
    major?: true
    graduationYear?: true
    skillsMatchPercentage?: true
    verificationStatus?: true
  }

  export type LearnerProfileMaxAggregateInputType = {
    userId?: true
    bio?: true
    location?: true
    university?: true
    major?: true
    graduationYear?: true
    skillsMatchPercentage?: true
    verificationStatus?: true
  }

  export type LearnerProfileCountAggregateInputType = {
    userId?: true
    bio?: true
    location?: true
    university?: true
    major?: true
    graduationYear?: true
    skillsMatchPercentage?: true
    verificationStatus?: true
    _all?: true
  }

  export type LearnerProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearnerProfile to aggregate.
     */
    where?: LearnerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearnerProfiles to fetch.
     */
    orderBy?: LearnerProfileOrderByWithRelationInput | LearnerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearnerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearnerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearnerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearnerProfiles
    **/
    _count?: true | LearnerProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LearnerProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LearnerProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearnerProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearnerProfileMaxAggregateInputType
  }

  export type GetLearnerProfileAggregateType<T extends LearnerProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateLearnerProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearnerProfile[P]>
      : GetScalarType<T[P], AggregateLearnerProfile[P]>
  }




  export type LearnerProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearnerProfileWhereInput
    orderBy?: LearnerProfileOrderByWithAggregationInput | LearnerProfileOrderByWithAggregationInput[]
    by: LearnerProfileScalarFieldEnum[] | LearnerProfileScalarFieldEnum
    having?: LearnerProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearnerProfileCountAggregateInputType | true
    _avg?: LearnerProfileAvgAggregateInputType
    _sum?: LearnerProfileSumAggregateInputType
    _min?: LearnerProfileMinAggregateInputType
    _max?: LearnerProfileMaxAggregateInputType
  }

  export type LearnerProfileGroupByOutputType = {
    userId: string
    bio: string | null
    location: string | null
    university: string | null
    major: string | null
    graduationYear: number | null
    skillsMatchPercentage: number
    verificationStatus: $Enums.VerificationStatus
    _count: LearnerProfileCountAggregateOutputType | null
    _avg: LearnerProfileAvgAggregateOutputType | null
    _sum: LearnerProfileSumAggregateOutputType | null
    _min: LearnerProfileMinAggregateOutputType | null
    _max: LearnerProfileMaxAggregateOutputType | null
  }

  type GetLearnerProfileGroupByPayload<T extends LearnerProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearnerProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearnerProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearnerProfileGroupByOutputType[P]>
            : GetScalarType<T[P], LearnerProfileGroupByOutputType[P]>
        }
      >
    >


  export type LearnerProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    bio?: boolean
    location?: boolean
    university?: boolean
    major?: boolean
    graduationYear?: boolean
    skillsMatchPercentage?: boolean
    verificationStatus?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learnerProfile"]>

  export type LearnerProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    bio?: boolean
    location?: boolean
    university?: boolean
    major?: boolean
    graduationYear?: boolean
    skillsMatchPercentage?: boolean
    verificationStatus?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learnerProfile"]>

  export type LearnerProfileSelectScalar = {
    userId?: boolean
    bio?: boolean
    location?: boolean
    university?: boolean
    major?: boolean
    graduationYear?: boolean
    skillsMatchPercentage?: boolean
    verificationStatus?: boolean
  }

  export type LearnerProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LearnerProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LearnerProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearnerProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      bio: string | null
      location: string | null
      university: string | null
      major: string | null
      graduationYear: number | null
      skillsMatchPercentage: number
      verificationStatus: $Enums.VerificationStatus
    }, ExtArgs["result"]["learnerProfile"]>
    composites: {}
  }

  type LearnerProfileGetPayload<S extends boolean | null | undefined | LearnerProfileDefaultArgs> = $Result.GetResult<Prisma.$LearnerProfilePayload, S>

  type LearnerProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LearnerProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LearnerProfileCountAggregateInputType | true
    }

  export interface LearnerProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearnerProfile'], meta: { name: 'LearnerProfile' } }
    /**
     * Find zero or one LearnerProfile that matches the filter.
     * @param {LearnerProfileFindUniqueArgs} args - Arguments to find a LearnerProfile
     * @example
     * // Get one LearnerProfile
     * const learnerProfile = await prisma.learnerProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearnerProfileFindUniqueArgs>(args: SelectSubset<T, LearnerProfileFindUniqueArgs<ExtArgs>>): Prisma__LearnerProfileClient<$Result.GetResult<Prisma.$LearnerProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LearnerProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LearnerProfileFindUniqueOrThrowArgs} args - Arguments to find a LearnerProfile
     * @example
     * // Get one LearnerProfile
     * const learnerProfile = await prisma.learnerProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearnerProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, LearnerProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearnerProfileClient<$Result.GetResult<Prisma.$LearnerProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LearnerProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnerProfileFindFirstArgs} args - Arguments to find a LearnerProfile
     * @example
     * // Get one LearnerProfile
     * const learnerProfile = await prisma.learnerProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearnerProfileFindFirstArgs>(args?: SelectSubset<T, LearnerProfileFindFirstArgs<ExtArgs>>): Prisma__LearnerProfileClient<$Result.GetResult<Prisma.$LearnerProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LearnerProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnerProfileFindFirstOrThrowArgs} args - Arguments to find a LearnerProfile
     * @example
     * // Get one LearnerProfile
     * const learnerProfile = await prisma.learnerProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearnerProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, LearnerProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearnerProfileClient<$Result.GetResult<Prisma.$LearnerProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LearnerProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnerProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearnerProfiles
     * const learnerProfiles = await prisma.learnerProfile.findMany()
     * 
     * // Get first 10 LearnerProfiles
     * const learnerProfiles = await prisma.learnerProfile.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const learnerProfileWithUserIdOnly = await prisma.learnerProfile.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends LearnerProfileFindManyArgs>(args?: SelectSubset<T, LearnerProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearnerProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LearnerProfile.
     * @param {LearnerProfileCreateArgs} args - Arguments to create a LearnerProfile.
     * @example
     * // Create one LearnerProfile
     * const LearnerProfile = await prisma.learnerProfile.create({
     *   data: {
     *     // ... data to create a LearnerProfile
     *   }
     * })
     * 
     */
    create<T extends LearnerProfileCreateArgs>(args: SelectSubset<T, LearnerProfileCreateArgs<ExtArgs>>): Prisma__LearnerProfileClient<$Result.GetResult<Prisma.$LearnerProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LearnerProfiles.
     * @param {LearnerProfileCreateManyArgs} args - Arguments to create many LearnerProfiles.
     * @example
     * // Create many LearnerProfiles
     * const learnerProfile = await prisma.learnerProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearnerProfileCreateManyArgs>(args?: SelectSubset<T, LearnerProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearnerProfiles and returns the data saved in the database.
     * @param {LearnerProfileCreateManyAndReturnArgs} args - Arguments to create many LearnerProfiles.
     * @example
     * // Create many LearnerProfiles
     * const learnerProfile = await prisma.learnerProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearnerProfiles and only return the `userId`
     * const learnerProfileWithUserIdOnly = await prisma.learnerProfile.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearnerProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, LearnerProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearnerProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LearnerProfile.
     * @param {LearnerProfileDeleteArgs} args - Arguments to delete one LearnerProfile.
     * @example
     * // Delete one LearnerProfile
     * const LearnerProfile = await prisma.learnerProfile.delete({
     *   where: {
     *     // ... filter to delete one LearnerProfile
     *   }
     * })
     * 
     */
    delete<T extends LearnerProfileDeleteArgs>(args: SelectSubset<T, LearnerProfileDeleteArgs<ExtArgs>>): Prisma__LearnerProfileClient<$Result.GetResult<Prisma.$LearnerProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LearnerProfile.
     * @param {LearnerProfileUpdateArgs} args - Arguments to update one LearnerProfile.
     * @example
     * // Update one LearnerProfile
     * const learnerProfile = await prisma.learnerProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearnerProfileUpdateArgs>(args: SelectSubset<T, LearnerProfileUpdateArgs<ExtArgs>>): Prisma__LearnerProfileClient<$Result.GetResult<Prisma.$LearnerProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LearnerProfiles.
     * @param {LearnerProfileDeleteManyArgs} args - Arguments to filter LearnerProfiles to delete.
     * @example
     * // Delete a few LearnerProfiles
     * const { count } = await prisma.learnerProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearnerProfileDeleteManyArgs>(args?: SelectSubset<T, LearnerProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearnerProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnerProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearnerProfiles
     * const learnerProfile = await prisma.learnerProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearnerProfileUpdateManyArgs>(args: SelectSubset<T, LearnerProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LearnerProfile.
     * @param {LearnerProfileUpsertArgs} args - Arguments to update or create a LearnerProfile.
     * @example
     * // Update or create a LearnerProfile
     * const learnerProfile = await prisma.learnerProfile.upsert({
     *   create: {
     *     // ... data to create a LearnerProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearnerProfile we want to update
     *   }
     * })
     */
    upsert<T extends LearnerProfileUpsertArgs>(args: SelectSubset<T, LearnerProfileUpsertArgs<ExtArgs>>): Prisma__LearnerProfileClient<$Result.GetResult<Prisma.$LearnerProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LearnerProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnerProfileCountArgs} args - Arguments to filter LearnerProfiles to count.
     * @example
     * // Count the number of LearnerProfiles
     * const count = await prisma.learnerProfile.count({
     *   where: {
     *     // ... the filter for the LearnerProfiles we want to count
     *   }
     * })
    **/
    count<T extends LearnerProfileCountArgs>(
      args?: Subset<T, LearnerProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearnerProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearnerProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnerProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearnerProfileAggregateArgs>(args: Subset<T, LearnerProfileAggregateArgs>): Prisma.PrismaPromise<GetLearnerProfileAggregateType<T>>

    /**
     * Group by LearnerProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnerProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearnerProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearnerProfileGroupByArgs['orderBy'] }
        : { orderBy?: LearnerProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearnerProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearnerProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearnerProfile model
   */
  readonly fields: LearnerProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearnerProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearnerProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearnerProfile model
   */ 
  interface LearnerProfileFieldRefs {
    readonly userId: FieldRef<"LearnerProfile", 'String'>
    readonly bio: FieldRef<"LearnerProfile", 'String'>
    readonly location: FieldRef<"LearnerProfile", 'String'>
    readonly university: FieldRef<"LearnerProfile", 'String'>
    readonly major: FieldRef<"LearnerProfile", 'String'>
    readonly graduationYear: FieldRef<"LearnerProfile", 'Int'>
    readonly skillsMatchPercentage: FieldRef<"LearnerProfile", 'Int'>
    readonly verificationStatus: FieldRef<"LearnerProfile", 'VerificationStatus'>
  }
    

  // Custom InputTypes
  /**
   * LearnerProfile findUnique
   */
  export type LearnerProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnerProfile
     */
    select?: LearnerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerProfileInclude<ExtArgs> | null
    /**
     * Filter, which LearnerProfile to fetch.
     */
    where: LearnerProfileWhereUniqueInput
  }

  /**
   * LearnerProfile findUniqueOrThrow
   */
  export type LearnerProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnerProfile
     */
    select?: LearnerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerProfileInclude<ExtArgs> | null
    /**
     * Filter, which LearnerProfile to fetch.
     */
    where: LearnerProfileWhereUniqueInput
  }

  /**
   * LearnerProfile findFirst
   */
  export type LearnerProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnerProfile
     */
    select?: LearnerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerProfileInclude<ExtArgs> | null
    /**
     * Filter, which LearnerProfile to fetch.
     */
    where?: LearnerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearnerProfiles to fetch.
     */
    orderBy?: LearnerProfileOrderByWithRelationInput | LearnerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearnerProfiles.
     */
    cursor?: LearnerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearnerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearnerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearnerProfiles.
     */
    distinct?: LearnerProfileScalarFieldEnum | LearnerProfileScalarFieldEnum[]
  }

  /**
   * LearnerProfile findFirstOrThrow
   */
  export type LearnerProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnerProfile
     */
    select?: LearnerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerProfileInclude<ExtArgs> | null
    /**
     * Filter, which LearnerProfile to fetch.
     */
    where?: LearnerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearnerProfiles to fetch.
     */
    orderBy?: LearnerProfileOrderByWithRelationInput | LearnerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearnerProfiles.
     */
    cursor?: LearnerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearnerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearnerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearnerProfiles.
     */
    distinct?: LearnerProfileScalarFieldEnum | LearnerProfileScalarFieldEnum[]
  }

  /**
   * LearnerProfile findMany
   */
  export type LearnerProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnerProfile
     */
    select?: LearnerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerProfileInclude<ExtArgs> | null
    /**
     * Filter, which LearnerProfiles to fetch.
     */
    where?: LearnerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearnerProfiles to fetch.
     */
    orderBy?: LearnerProfileOrderByWithRelationInput | LearnerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearnerProfiles.
     */
    cursor?: LearnerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearnerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearnerProfiles.
     */
    skip?: number
    distinct?: LearnerProfileScalarFieldEnum | LearnerProfileScalarFieldEnum[]
  }

  /**
   * LearnerProfile create
   */
  export type LearnerProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnerProfile
     */
    select?: LearnerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a LearnerProfile.
     */
    data: XOR<LearnerProfileCreateInput, LearnerProfileUncheckedCreateInput>
  }

  /**
   * LearnerProfile createMany
   */
  export type LearnerProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearnerProfiles.
     */
    data: LearnerProfileCreateManyInput | LearnerProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearnerProfile createManyAndReturn
   */
  export type LearnerProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnerProfile
     */
    select?: LearnerProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LearnerProfiles.
     */
    data: LearnerProfileCreateManyInput | LearnerProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearnerProfile update
   */
  export type LearnerProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnerProfile
     */
    select?: LearnerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a LearnerProfile.
     */
    data: XOR<LearnerProfileUpdateInput, LearnerProfileUncheckedUpdateInput>
    /**
     * Choose, which LearnerProfile to update.
     */
    where: LearnerProfileWhereUniqueInput
  }

  /**
   * LearnerProfile updateMany
   */
  export type LearnerProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearnerProfiles.
     */
    data: XOR<LearnerProfileUpdateManyMutationInput, LearnerProfileUncheckedUpdateManyInput>
    /**
     * Filter which LearnerProfiles to update
     */
    where?: LearnerProfileWhereInput
  }

  /**
   * LearnerProfile upsert
   */
  export type LearnerProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnerProfile
     */
    select?: LearnerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the LearnerProfile to update in case it exists.
     */
    where: LearnerProfileWhereUniqueInput
    /**
     * In case the LearnerProfile found by the `where` argument doesn't exist, create a new LearnerProfile with this data.
     */
    create: XOR<LearnerProfileCreateInput, LearnerProfileUncheckedCreateInput>
    /**
     * In case the LearnerProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearnerProfileUpdateInput, LearnerProfileUncheckedUpdateInput>
  }

  /**
   * LearnerProfile delete
   */
  export type LearnerProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnerProfile
     */
    select?: LearnerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerProfileInclude<ExtArgs> | null
    /**
     * Filter which LearnerProfile to delete.
     */
    where: LearnerProfileWhereUniqueInput
  }

  /**
   * LearnerProfile deleteMany
   */
  export type LearnerProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearnerProfiles to delete
     */
    where?: LearnerProfileWhereInput
  }

  /**
   * LearnerProfile without action
   */
  export type LearnerProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnerProfile
     */
    select?: LearnerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerProfileInclude<ExtArgs> | null
  }


  /**
   * Model Skill
   */

  export type AggregateSkill = {
    _count: SkillCountAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  export type SkillMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: $Enums.SkillCategory | null
    description: string | null
    verified: boolean | null
    trending: boolean | null
  }

  export type SkillMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: $Enums.SkillCategory | null
    description: string | null
    verified: boolean | null
    trending: boolean | null
  }

  export type SkillCountAggregateOutputType = {
    id: number
    name: number
    category: number
    description: number
    verified: number
    trending: number
    _all: number
  }


  export type SkillMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    description?: true
    verified?: true
    trending?: true
  }

  export type SkillMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    description?: true
    verified?: true
    trending?: true
  }

  export type SkillCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    description?: true
    verified?: true
    trending?: true
    _all?: true
  }

  export type SkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skill to aggregate.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Skills
    **/
    _count?: true | SkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillMaxAggregateInputType
  }

  export type GetSkillAggregateType<T extends SkillAggregateArgs> = {
        [P in keyof T & keyof AggregateSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkill[P]>
      : GetScalarType<T[P], AggregateSkill[P]>
  }




  export type SkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithAggregationInput | SkillOrderByWithAggregationInput[]
    by: SkillScalarFieldEnum[] | SkillScalarFieldEnum
    having?: SkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillCountAggregateInputType | true
    _min?: SkillMinAggregateInputType
    _max?: SkillMaxAggregateInputType
  }

  export type SkillGroupByOutputType = {
    id: string
    name: string
    category: $Enums.SkillCategory
    description: string | null
    verified: boolean
    trending: boolean
    _count: SkillCountAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  type GetSkillGroupByPayload<T extends SkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillGroupByOutputType[P]>
            : GetScalarType<T[P], SkillGroupByOutputType[P]>
        }
      >
    >


  export type SkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    verified?: boolean
    trending?: boolean
    userSkills?: boolean | Skill$userSkillsArgs<ExtArgs>
    credentialSkills?: boolean | Skill$credentialSkillsArgs<ExtArgs>
    projectSkills?: boolean | Skill$projectSkillsArgs<ExtArgs>
    opportunitySkills?: boolean | Skill$opportunitySkillsArgs<ExtArgs>
    courseSkills?: boolean | Skill$courseSkillsArgs<ExtArgs>
    trendingData?: boolean | Skill$trendingDataArgs<ExtArgs>
    skillGaps?: boolean | Skill$skillGapsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    verified?: boolean
    trending?: boolean
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    verified?: boolean
    trending?: boolean
  }

  export type SkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userSkills?: boolean | Skill$userSkillsArgs<ExtArgs>
    credentialSkills?: boolean | Skill$credentialSkillsArgs<ExtArgs>
    projectSkills?: boolean | Skill$projectSkillsArgs<ExtArgs>
    opportunitySkills?: boolean | Skill$opportunitySkillsArgs<ExtArgs>
    courseSkills?: boolean | Skill$courseSkillsArgs<ExtArgs>
    trendingData?: boolean | Skill$trendingDataArgs<ExtArgs>
    skillGaps?: boolean | Skill$skillGapsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Skill"
    objects: {
      userSkills: Prisma.$UserSkillPayload<ExtArgs>[]
      credentialSkills: Prisma.$CredentialSkillPayload<ExtArgs>[]
      projectSkills: Prisma.$ProjectSkillPayload<ExtArgs>[]
      opportunitySkills: Prisma.$OpportunitySkillPayload<ExtArgs>[]
      courseSkills: Prisma.$CourseSkillPayload<ExtArgs>[]
      trendingData: Prisma.$TrendingSkillPayload<ExtArgs> | null
      skillGaps: Prisma.$SkillGapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: $Enums.SkillCategory
      description: string | null
      verified: boolean
      trending: boolean
    }, ExtArgs["result"]["skill"]>
    composites: {}
  }

  type SkillGetPayload<S extends boolean | null | undefined | SkillDefaultArgs> = $Result.GetResult<Prisma.$SkillPayload, S>

  type SkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SkillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SkillCountAggregateInputType | true
    }

  export interface SkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Skill'], meta: { name: 'Skill' } }
    /**
     * Find zero or one Skill that matches the filter.
     * @param {SkillFindUniqueArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillFindUniqueArgs>(args: SelectSubset<T, SkillFindUniqueArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Skill that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SkillFindUniqueOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Skill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillFindFirstArgs>(args?: SelectSubset<T, SkillFindFirstArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Skill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skill.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillWithIdOnly = await prisma.skill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillFindManyArgs>(args?: SelectSubset<T, SkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Skill.
     * @param {SkillCreateArgs} args - Arguments to create a Skill.
     * @example
     * // Create one Skill
     * const Skill = await prisma.skill.create({
     *   data: {
     *     // ... data to create a Skill
     *   }
     * })
     * 
     */
    create<T extends SkillCreateArgs>(args: SelectSubset<T, SkillCreateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Skills.
     * @param {SkillCreateManyArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillCreateManyArgs>(args?: SelectSubset<T, SkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Skills and returns the data saved in the database.
     * @param {SkillCreateManyAndReturnArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Skills and only return the `id`
     * const skillWithIdOnly = await prisma.skill.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkillCreateManyAndReturnArgs>(args?: SelectSubset<T, SkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Skill.
     * @param {SkillDeleteArgs} args - Arguments to delete one Skill.
     * @example
     * // Delete one Skill
     * const Skill = await prisma.skill.delete({
     *   where: {
     *     // ... filter to delete one Skill
     *   }
     * })
     * 
     */
    delete<T extends SkillDeleteArgs>(args: SelectSubset<T, SkillDeleteArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Skill.
     * @param {SkillUpdateArgs} args - Arguments to update one Skill.
     * @example
     * // Update one Skill
     * const skill = await prisma.skill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillUpdateArgs>(args: SelectSubset<T, SkillUpdateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Skills.
     * @param {SkillDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillDeleteManyArgs>(args?: SelectSubset<T, SkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillUpdateManyArgs>(args: SelectSubset<T, SkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Skill.
     * @param {SkillUpsertArgs} args - Arguments to update or create a Skill.
     * @example
     * // Update or create a Skill
     * const skill = await prisma.skill.upsert({
     *   create: {
     *     // ... data to create a Skill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skill we want to update
     *   }
     * })
     */
    upsert<T extends SkillUpsertArgs>(args: SelectSubset<T, SkillUpsertArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skill.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends SkillCountArgs>(
      args?: Subset<T, SkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillAggregateArgs>(args: Subset<T, SkillAggregateArgs>): Prisma.PrismaPromise<GetSkillAggregateType<T>>

    /**
     * Group by Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillGroupByArgs['orderBy'] }
        : { orderBy?: SkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Skill model
   */
  readonly fields: SkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Skill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userSkills<T extends Skill$userSkillsArgs<ExtArgs> = {}>(args?: Subset<T, Skill$userSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "findMany"> | Null>
    credentialSkills<T extends Skill$credentialSkillsArgs<ExtArgs> = {}>(args?: Subset<T, Skill$credentialSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialSkillPayload<ExtArgs>, T, "findMany"> | Null>
    projectSkills<T extends Skill$projectSkillsArgs<ExtArgs> = {}>(args?: Subset<T, Skill$projectSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSkillPayload<ExtArgs>, T, "findMany"> | Null>
    opportunitySkills<T extends Skill$opportunitySkillsArgs<ExtArgs> = {}>(args?: Subset<T, Skill$opportunitySkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunitySkillPayload<ExtArgs>, T, "findMany"> | Null>
    courseSkills<T extends Skill$courseSkillsArgs<ExtArgs> = {}>(args?: Subset<T, Skill$courseSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "findMany"> | Null>
    trendingData<T extends Skill$trendingDataArgs<ExtArgs> = {}>(args?: Subset<T, Skill$trendingDataArgs<ExtArgs>>): Prisma__TrendingSkillClient<$Result.GetResult<Prisma.$TrendingSkillPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    skillGaps<T extends Skill$skillGapsArgs<ExtArgs> = {}>(args?: Subset<T, Skill$skillGapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillGapPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Skill model
   */ 
  interface SkillFieldRefs {
    readonly id: FieldRef<"Skill", 'String'>
    readonly name: FieldRef<"Skill", 'String'>
    readonly category: FieldRef<"Skill", 'SkillCategory'>
    readonly description: FieldRef<"Skill", 'String'>
    readonly verified: FieldRef<"Skill", 'Boolean'>
    readonly trending: FieldRef<"Skill", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Skill findUnique
   */
  export type SkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findUniqueOrThrow
   */
  export type SkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findFirst
   */
  export type SkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findFirstOrThrow
   */
  export type SkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findMany
   */
  export type SkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill create
   */
  export type SkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to create a Skill.
     */
    data: XOR<SkillCreateInput, SkillUncheckedCreateInput>
  }

  /**
   * Skill createMany
   */
  export type SkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Skill createManyAndReturn
   */
  export type SkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Skill update
   */
  export type SkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to update a Skill.
     */
    data: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
    /**
     * Choose, which Skill to update.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill updateMany
   */
  export type SkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
  }

  /**
   * Skill upsert
   */
  export type SkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The filter to search for the Skill to update in case it exists.
     */
    where: SkillWhereUniqueInput
    /**
     * In case the Skill found by the `where` argument doesn't exist, create a new Skill with this data.
     */
    create: XOR<SkillCreateInput, SkillUncheckedCreateInput>
    /**
     * In case the Skill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
  }

  /**
   * Skill delete
   */
  export type SkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter which Skill to delete.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill deleteMany
   */
  export type SkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skills to delete
     */
    where?: SkillWhereInput
  }

  /**
   * Skill.userSkills
   */
  export type Skill$userSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillInclude<ExtArgs> | null
    where?: UserSkillWhereInput
    orderBy?: UserSkillOrderByWithRelationInput | UserSkillOrderByWithRelationInput[]
    cursor?: UserSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSkillScalarFieldEnum | UserSkillScalarFieldEnum[]
  }

  /**
   * Skill.credentialSkills
   */
  export type Skill$credentialSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialSkill
     */
    select?: CredentialSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialSkillInclude<ExtArgs> | null
    where?: CredentialSkillWhereInput
    orderBy?: CredentialSkillOrderByWithRelationInput | CredentialSkillOrderByWithRelationInput[]
    cursor?: CredentialSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CredentialSkillScalarFieldEnum | CredentialSkillScalarFieldEnum[]
  }

  /**
   * Skill.projectSkills
   */
  export type Skill$projectSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillInclude<ExtArgs> | null
    where?: ProjectSkillWhereInput
    orderBy?: ProjectSkillOrderByWithRelationInput | ProjectSkillOrderByWithRelationInput[]
    cursor?: ProjectSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectSkillScalarFieldEnum | ProjectSkillScalarFieldEnum[]
  }

  /**
   * Skill.opportunitySkills
   */
  export type Skill$opportunitySkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunitySkill
     */
    select?: OpportunitySkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunitySkillInclude<ExtArgs> | null
    where?: OpportunitySkillWhereInput
    orderBy?: OpportunitySkillOrderByWithRelationInput | OpportunitySkillOrderByWithRelationInput[]
    cursor?: OpportunitySkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpportunitySkillScalarFieldEnum | OpportunitySkillScalarFieldEnum[]
  }

  /**
   * Skill.courseSkills
   */
  export type Skill$courseSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillInclude<ExtArgs> | null
    where?: CourseSkillWhereInput
    orderBy?: CourseSkillOrderByWithRelationInput | CourseSkillOrderByWithRelationInput[]
    cursor?: CourseSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseSkillScalarFieldEnum | CourseSkillScalarFieldEnum[]
  }

  /**
   * Skill.trendingData
   */
  export type Skill$trendingDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendingSkill
     */
    select?: TrendingSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrendingSkillInclude<ExtArgs> | null
    where?: TrendingSkillWhereInput
  }

  /**
   * Skill.skillGaps
   */
  export type Skill$skillGapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillGap
     */
    select?: SkillGapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillGapInclude<ExtArgs> | null
    where?: SkillGapWhereInput
    orderBy?: SkillGapOrderByWithRelationInput | SkillGapOrderByWithRelationInput[]
    cursor?: SkillGapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillGapScalarFieldEnum | SkillGapScalarFieldEnum[]
  }

  /**
   * Skill without action
   */
  export type SkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
  }


  /**
   * Model UserSkill
   */

  export type AggregateUserSkill = {
    _count: UserSkillCountAggregateOutputType | null
    _avg: UserSkillAvgAggregateOutputType | null
    _sum: UserSkillSumAggregateOutputType | null
    _min: UserSkillMinAggregateOutputType | null
    _max: UserSkillMaxAggregateOutputType | null
  }

  export type UserSkillAvgAggregateOutputType = {
    endorsements: number | null
  }

  export type UserSkillSumAggregateOutputType = {
    endorsements: number | null
  }

  export type UserSkillMinAggregateOutputType = {
    id: string | null
    userId: string | null
    skillId: string | null
    level: $Enums.SkillLevel | null
    endorsements: number | null
    verified: boolean | null
    addedAt: Date | null
  }

  export type UserSkillMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    skillId: string | null
    level: $Enums.SkillLevel | null
    endorsements: number | null
    verified: boolean | null
    addedAt: Date | null
  }

  export type UserSkillCountAggregateOutputType = {
    id: number
    userId: number
    skillId: number
    level: number
    endorsements: number
    verified: number
    addedAt: number
    _all: number
  }


  export type UserSkillAvgAggregateInputType = {
    endorsements?: true
  }

  export type UserSkillSumAggregateInputType = {
    endorsements?: true
  }

  export type UserSkillMinAggregateInputType = {
    id?: true
    userId?: true
    skillId?: true
    level?: true
    endorsements?: true
    verified?: true
    addedAt?: true
  }

  export type UserSkillMaxAggregateInputType = {
    id?: true
    userId?: true
    skillId?: true
    level?: true
    endorsements?: true
    verified?: true
    addedAt?: true
  }

  export type UserSkillCountAggregateInputType = {
    id?: true
    userId?: true
    skillId?: true
    level?: true
    endorsements?: true
    verified?: true
    addedAt?: true
    _all?: true
  }

  export type UserSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSkill to aggregate.
     */
    where?: UserSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkills to fetch.
     */
    orderBy?: UserSkillOrderByWithRelationInput | UserSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSkills
    **/
    _count?: true | UserSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSkillMaxAggregateInputType
  }

  export type GetUserSkillAggregateType<T extends UserSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSkill[P]>
      : GetScalarType<T[P], AggregateUserSkill[P]>
  }




  export type UserSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSkillWhereInput
    orderBy?: UserSkillOrderByWithAggregationInput | UserSkillOrderByWithAggregationInput[]
    by: UserSkillScalarFieldEnum[] | UserSkillScalarFieldEnum
    having?: UserSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSkillCountAggregateInputType | true
    _avg?: UserSkillAvgAggregateInputType
    _sum?: UserSkillSumAggregateInputType
    _min?: UserSkillMinAggregateInputType
    _max?: UserSkillMaxAggregateInputType
  }

  export type UserSkillGroupByOutputType = {
    id: string
    userId: string
    skillId: string
    level: $Enums.SkillLevel
    endorsements: number
    verified: boolean
    addedAt: Date
    _count: UserSkillCountAggregateOutputType | null
    _avg: UserSkillAvgAggregateOutputType | null
    _sum: UserSkillSumAggregateOutputType | null
    _min: UserSkillMinAggregateOutputType | null
    _max: UserSkillMaxAggregateOutputType | null
  }

  type GetUserSkillGroupByPayload<T extends UserSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSkillGroupByOutputType[P]>
            : GetScalarType<T[P], UserSkillGroupByOutputType[P]>
        }
      >
    >


  export type UserSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    skillId?: boolean
    level?: boolean
    endorsements?: boolean
    verified?: boolean
    addedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSkill"]>

  export type UserSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    skillId?: boolean
    level?: boolean
    endorsements?: boolean
    verified?: boolean
    addedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSkill"]>

  export type UserSkillSelectScalar = {
    id?: boolean
    userId?: boolean
    skillId?: boolean
    level?: boolean
    endorsements?: boolean
    verified?: boolean
    addedAt?: boolean
  }

  export type UserSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type UserSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }

  export type $UserSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSkill"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      skillId: string
      level: $Enums.SkillLevel
      endorsements: number
      verified: boolean
      addedAt: Date
    }, ExtArgs["result"]["userSkill"]>
    composites: {}
  }

  type UserSkillGetPayload<S extends boolean | null | undefined | UserSkillDefaultArgs> = $Result.GetResult<Prisma.$UserSkillPayload, S>

  type UserSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserSkillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserSkillCountAggregateInputType | true
    }

  export interface UserSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSkill'], meta: { name: 'UserSkill' } }
    /**
     * Find zero or one UserSkill that matches the filter.
     * @param {UserSkillFindUniqueArgs} args - Arguments to find a UserSkill
     * @example
     * // Get one UserSkill
     * const userSkill = await prisma.userSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSkillFindUniqueArgs>(args: SelectSubset<T, UserSkillFindUniqueArgs<ExtArgs>>): Prisma__UserSkillClient<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserSkill that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserSkillFindUniqueOrThrowArgs} args - Arguments to find a UserSkill
     * @example
     * // Get one UserSkill
     * const userSkill = await prisma.userSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSkillClient<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillFindFirstArgs} args - Arguments to find a UserSkill
     * @example
     * // Get one UserSkill
     * const userSkill = await prisma.userSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSkillFindFirstArgs>(args?: SelectSubset<T, UserSkillFindFirstArgs<ExtArgs>>): Prisma__UserSkillClient<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillFindFirstOrThrowArgs} args - Arguments to find a UserSkill
     * @example
     * // Get one UserSkill
     * const userSkill = await prisma.userSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSkillClient<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSkills
     * const userSkills = await prisma.userSkill.findMany()
     * 
     * // Get first 10 UserSkills
     * const userSkills = await prisma.userSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSkillWithIdOnly = await prisma.userSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSkillFindManyArgs>(args?: SelectSubset<T, UserSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserSkill.
     * @param {UserSkillCreateArgs} args - Arguments to create a UserSkill.
     * @example
     * // Create one UserSkill
     * const UserSkill = await prisma.userSkill.create({
     *   data: {
     *     // ... data to create a UserSkill
     *   }
     * })
     * 
     */
    create<T extends UserSkillCreateArgs>(args: SelectSubset<T, UserSkillCreateArgs<ExtArgs>>): Prisma__UserSkillClient<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserSkills.
     * @param {UserSkillCreateManyArgs} args - Arguments to create many UserSkills.
     * @example
     * // Create many UserSkills
     * const userSkill = await prisma.userSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSkillCreateManyArgs>(args?: SelectSubset<T, UserSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSkills and returns the data saved in the database.
     * @param {UserSkillCreateManyAndReturnArgs} args - Arguments to create many UserSkills.
     * @example
     * // Create many UserSkills
     * const userSkill = await prisma.userSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSkills and only return the `id`
     * const userSkillWithIdOnly = await prisma.userSkill.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserSkill.
     * @param {UserSkillDeleteArgs} args - Arguments to delete one UserSkill.
     * @example
     * // Delete one UserSkill
     * const UserSkill = await prisma.userSkill.delete({
     *   where: {
     *     // ... filter to delete one UserSkill
     *   }
     * })
     * 
     */
    delete<T extends UserSkillDeleteArgs>(args: SelectSubset<T, UserSkillDeleteArgs<ExtArgs>>): Prisma__UserSkillClient<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserSkill.
     * @param {UserSkillUpdateArgs} args - Arguments to update one UserSkill.
     * @example
     * // Update one UserSkill
     * const userSkill = await prisma.userSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSkillUpdateArgs>(args: SelectSubset<T, UserSkillUpdateArgs<ExtArgs>>): Prisma__UserSkillClient<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserSkills.
     * @param {UserSkillDeleteManyArgs} args - Arguments to filter UserSkills to delete.
     * @example
     * // Delete a few UserSkills
     * const { count } = await prisma.userSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSkillDeleteManyArgs>(args?: SelectSubset<T, UserSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSkills
     * const userSkill = await prisma.userSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSkillUpdateManyArgs>(args: SelectSubset<T, UserSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSkill.
     * @param {UserSkillUpsertArgs} args - Arguments to update or create a UserSkill.
     * @example
     * // Update or create a UserSkill
     * const userSkill = await prisma.userSkill.upsert({
     *   create: {
     *     // ... data to create a UserSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSkill we want to update
     *   }
     * })
     */
    upsert<T extends UserSkillUpsertArgs>(args: SelectSubset<T, UserSkillUpsertArgs<ExtArgs>>): Prisma__UserSkillClient<$Result.GetResult<Prisma.$UserSkillPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillCountArgs} args - Arguments to filter UserSkills to count.
     * @example
     * // Count the number of UserSkills
     * const count = await prisma.userSkill.count({
     *   where: {
     *     // ... the filter for the UserSkills we want to count
     *   }
     * })
    **/
    count<T extends UserSkillCountArgs>(
      args?: Subset<T, UserSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSkillAggregateArgs>(args: Subset<T, UserSkillAggregateArgs>): Prisma.PrismaPromise<GetUserSkillAggregateType<T>>

    /**
     * Group by UserSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSkillGroupByArgs['orderBy'] }
        : { orderBy?: UserSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSkill model
   */
  readonly fields: UserSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSkill model
   */ 
  interface UserSkillFieldRefs {
    readonly id: FieldRef<"UserSkill", 'String'>
    readonly userId: FieldRef<"UserSkill", 'String'>
    readonly skillId: FieldRef<"UserSkill", 'String'>
    readonly level: FieldRef<"UserSkill", 'SkillLevel'>
    readonly endorsements: FieldRef<"UserSkill", 'Int'>
    readonly verified: FieldRef<"UserSkill", 'Boolean'>
    readonly addedAt: FieldRef<"UserSkill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSkill findUnique
   */
  export type UserSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillInclude<ExtArgs> | null
    /**
     * Filter, which UserSkill to fetch.
     */
    where: UserSkillWhereUniqueInput
  }

  /**
   * UserSkill findUniqueOrThrow
   */
  export type UserSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillInclude<ExtArgs> | null
    /**
     * Filter, which UserSkill to fetch.
     */
    where: UserSkillWhereUniqueInput
  }

  /**
   * UserSkill findFirst
   */
  export type UserSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillInclude<ExtArgs> | null
    /**
     * Filter, which UserSkill to fetch.
     */
    where?: UserSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkills to fetch.
     */
    orderBy?: UserSkillOrderByWithRelationInput | UserSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSkills.
     */
    cursor?: UserSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSkills.
     */
    distinct?: UserSkillScalarFieldEnum | UserSkillScalarFieldEnum[]
  }

  /**
   * UserSkill findFirstOrThrow
   */
  export type UserSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillInclude<ExtArgs> | null
    /**
     * Filter, which UserSkill to fetch.
     */
    where?: UserSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkills to fetch.
     */
    orderBy?: UserSkillOrderByWithRelationInput | UserSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSkills.
     */
    cursor?: UserSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSkills.
     */
    distinct?: UserSkillScalarFieldEnum | UserSkillScalarFieldEnum[]
  }

  /**
   * UserSkill findMany
   */
  export type UserSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillInclude<ExtArgs> | null
    /**
     * Filter, which UserSkills to fetch.
     */
    where?: UserSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkills to fetch.
     */
    orderBy?: UserSkillOrderByWithRelationInput | UserSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSkills.
     */
    cursor?: UserSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkills.
     */
    skip?: number
    distinct?: UserSkillScalarFieldEnum | UserSkillScalarFieldEnum[]
  }

  /**
   * UserSkill create
   */
  export type UserSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSkill.
     */
    data: XOR<UserSkillCreateInput, UserSkillUncheckedCreateInput>
  }

  /**
   * UserSkill createMany
   */
  export type UserSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSkills.
     */
    data: UserSkillCreateManyInput | UserSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSkill createManyAndReturn
   */
  export type UserSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserSkills.
     */
    data: UserSkillCreateManyInput | UserSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSkill update
   */
  export type UserSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSkill.
     */
    data: XOR<UserSkillUpdateInput, UserSkillUncheckedUpdateInput>
    /**
     * Choose, which UserSkill to update.
     */
    where: UserSkillWhereUniqueInput
  }

  /**
   * UserSkill updateMany
   */
  export type UserSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSkills.
     */
    data: XOR<UserSkillUpdateManyMutationInput, UserSkillUncheckedUpdateManyInput>
    /**
     * Filter which UserSkills to update
     */
    where?: UserSkillWhereInput
  }

  /**
   * UserSkill upsert
   */
  export type UserSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSkill to update in case it exists.
     */
    where: UserSkillWhereUniqueInput
    /**
     * In case the UserSkill found by the `where` argument doesn't exist, create a new UserSkill with this data.
     */
    create: XOR<UserSkillCreateInput, UserSkillUncheckedCreateInput>
    /**
     * In case the UserSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSkillUpdateInput, UserSkillUncheckedUpdateInput>
  }

  /**
   * UserSkill delete
   */
  export type UserSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillInclude<ExtArgs> | null
    /**
     * Filter which UserSkill to delete.
     */
    where: UserSkillWhereUniqueInput
  }

  /**
   * UserSkill deleteMany
   */
  export type UserSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSkills to delete
     */
    where?: UserSkillWhereInput
  }

  /**
   * UserSkill without action
   */
  export type UserSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkill
     */
    select?: UserSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillInclude<ExtArgs> | null
  }


  /**
   * Model TrendingSkill
   */

  export type AggregateTrendingSkill = {
    _count: TrendingSkillCountAggregateOutputType | null
    _avg: TrendingSkillAvgAggregateOutputType | null
    _sum: TrendingSkillSumAggregateOutputType | null
    _min: TrendingSkillMinAggregateOutputType | null
    _max: TrendingSkillMaxAggregateOutputType | null
  }

  export type TrendingSkillAvgAggregateOutputType = {
    demandPercentage: Decimal | null
    growthRate: Decimal | null
    averageSalary: number | null
    openPositions: number | null
  }

  export type TrendingSkillSumAggregateOutputType = {
    demandPercentage: Decimal | null
    growthRate: Decimal | null
    averageSalary: bigint | null
    openPositions: number | null
  }

  export type TrendingSkillMinAggregateOutputType = {
    skillId: string | null
    demandPercentage: Decimal | null
    growthRate: Decimal | null
    averageSalary: bigint | null
    openPositions: number | null
    updatedAt: Date | null
  }

  export type TrendingSkillMaxAggregateOutputType = {
    skillId: string | null
    demandPercentage: Decimal | null
    growthRate: Decimal | null
    averageSalary: bigint | null
    openPositions: number | null
    updatedAt: Date | null
  }

  export type TrendingSkillCountAggregateOutputType = {
    skillId: number
    demandPercentage: number
    growthRate: number
    averageSalary: number
    openPositions: number
    updatedAt: number
    _all: number
  }


  export type TrendingSkillAvgAggregateInputType = {
    demandPercentage?: true
    growthRate?: true
    averageSalary?: true
    openPositions?: true
  }

  export type TrendingSkillSumAggregateInputType = {
    demandPercentage?: true
    growthRate?: true
    averageSalary?: true
    openPositions?: true
  }

  export type TrendingSkillMinAggregateInputType = {
    skillId?: true
    demandPercentage?: true
    growthRate?: true
    averageSalary?: true
    openPositions?: true
    updatedAt?: true
  }

  export type TrendingSkillMaxAggregateInputType = {
    skillId?: true
    demandPercentage?: true
    growthRate?: true
    averageSalary?: true
    openPositions?: true
    updatedAt?: true
  }

  export type TrendingSkillCountAggregateInputType = {
    skillId?: true
    demandPercentage?: true
    growthRate?: true
    averageSalary?: true
    openPositions?: true
    updatedAt?: true
    _all?: true
  }

  export type TrendingSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrendingSkill to aggregate.
     */
    where?: TrendingSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrendingSkills to fetch.
     */
    orderBy?: TrendingSkillOrderByWithRelationInput | TrendingSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrendingSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrendingSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrendingSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrendingSkills
    **/
    _count?: true | TrendingSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrendingSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrendingSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrendingSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrendingSkillMaxAggregateInputType
  }

  export type GetTrendingSkillAggregateType<T extends TrendingSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateTrendingSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrendingSkill[P]>
      : GetScalarType<T[P], AggregateTrendingSkill[P]>
  }




  export type TrendingSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrendingSkillWhereInput
    orderBy?: TrendingSkillOrderByWithAggregationInput | TrendingSkillOrderByWithAggregationInput[]
    by: TrendingSkillScalarFieldEnum[] | TrendingSkillScalarFieldEnum
    having?: TrendingSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrendingSkillCountAggregateInputType | true
    _avg?: TrendingSkillAvgAggregateInputType
    _sum?: TrendingSkillSumAggregateInputType
    _min?: TrendingSkillMinAggregateInputType
    _max?: TrendingSkillMaxAggregateInputType
  }

  export type TrendingSkillGroupByOutputType = {
    skillId: string
    demandPercentage: Decimal
    growthRate: Decimal
    averageSalary: bigint
    openPositions: number
    updatedAt: Date
    _count: TrendingSkillCountAggregateOutputType | null
    _avg: TrendingSkillAvgAggregateOutputType | null
    _sum: TrendingSkillSumAggregateOutputType | null
    _min: TrendingSkillMinAggregateOutputType | null
    _max: TrendingSkillMaxAggregateOutputType | null
  }

  type GetTrendingSkillGroupByPayload<T extends TrendingSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrendingSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrendingSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrendingSkillGroupByOutputType[P]>
            : GetScalarType<T[P], TrendingSkillGroupByOutputType[P]>
        }
      >
    >


  export type TrendingSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    skillId?: boolean
    demandPercentage?: boolean
    growthRate?: boolean
    averageSalary?: boolean
    openPositions?: boolean
    updatedAt?: boolean
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trendingSkill"]>

  export type TrendingSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    skillId?: boolean
    demandPercentage?: boolean
    growthRate?: boolean
    averageSalary?: boolean
    openPositions?: boolean
    updatedAt?: boolean
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trendingSkill"]>

  export type TrendingSkillSelectScalar = {
    skillId?: boolean
    demandPercentage?: boolean
    growthRate?: boolean
    averageSalary?: boolean
    openPositions?: boolean
    updatedAt?: boolean
  }

  export type TrendingSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type TrendingSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }

  export type $TrendingSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrendingSkill"
    objects: {
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      skillId: string
      demandPercentage: Prisma.Decimal
      growthRate: Prisma.Decimal
      averageSalary: bigint
      openPositions: number
      updatedAt: Date
    }, ExtArgs["result"]["trendingSkill"]>
    composites: {}
  }

  type TrendingSkillGetPayload<S extends boolean | null | undefined | TrendingSkillDefaultArgs> = $Result.GetResult<Prisma.$TrendingSkillPayload, S>

  type TrendingSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrendingSkillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrendingSkillCountAggregateInputType | true
    }

  export interface TrendingSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrendingSkill'], meta: { name: 'TrendingSkill' } }
    /**
     * Find zero or one TrendingSkill that matches the filter.
     * @param {TrendingSkillFindUniqueArgs} args - Arguments to find a TrendingSkill
     * @example
     * // Get one TrendingSkill
     * const trendingSkill = await prisma.trendingSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrendingSkillFindUniqueArgs>(args: SelectSubset<T, TrendingSkillFindUniqueArgs<ExtArgs>>): Prisma__TrendingSkillClient<$Result.GetResult<Prisma.$TrendingSkillPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TrendingSkill that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrendingSkillFindUniqueOrThrowArgs} args - Arguments to find a TrendingSkill
     * @example
     * // Get one TrendingSkill
     * const trendingSkill = await prisma.trendingSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrendingSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, TrendingSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrendingSkillClient<$Result.GetResult<Prisma.$TrendingSkillPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TrendingSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendingSkillFindFirstArgs} args - Arguments to find a TrendingSkill
     * @example
     * // Get one TrendingSkill
     * const trendingSkill = await prisma.trendingSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrendingSkillFindFirstArgs>(args?: SelectSubset<T, TrendingSkillFindFirstArgs<ExtArgs>>): Prisma__TrendingSkillClient<$Result.GetResult<Prisma.$TrendingSkillPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TrendingSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendingSkillFindFirstOrThrowArgs} args - Arguments to find a TrendingSkill
     * @example
     * // Get one TrendingSkill
     * const trendingSkill = await prisma.trendingSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrendingSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, TrendingSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrendingSkillClient<$Result.GetResult<Prisma.$TrendingSkillPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TrendingSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendingSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrendingSkills
     * const trendingSkills = await prisma.trendingSkill.findMany()
     * 
     * // Get first 10 TrendingSkills
     * const trendingSkills = await prisma.trendingSkill.findMany({ take: 10 })
     * 
     * // Only select the `skillId`
     * const trendingSkillWithSkillIdOnly = await prisma.trendingSkill.findMany({ select: { skillId: true } })
     * 
     */
    findMany<T extends TrendingSkillFindManyArgs>(args?: SelectSubset<T, TrendingSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrendingSkillPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TrendingSkill.
     * @param {TrendingSkillCreateArgs} args - Arguments to create a TrendingSkill.
     * @example
     * // Create one TrendingSkill
     * const TrendingSkill = await prisma.trendingSkill.create({
     *   data: {
     *     // ... data to create a TrendingSkill
     *   }
     * })
     * 
     */
    create<T extends TrendingSkillCreateArgs>(args: SelectSubset<T, TrendingSkillCreateArgs<ExtArgs>>): Prisma__TrendingSkillClient<$Result.GetResult<Prisma.$TrendingSkillPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TrendingSkills.
     * @param {TrendingSkillCreateManyArgs} args - Arguments to create many TrendingSkills.
     * @example
     * // Create many TrendingSkills
     * const trendingSkill = await prisma.trendingSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrendingSkillCreateManyArgs>(args?: SelectSubset<T, TrendingSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrendingSkills and returns the data saved in the database.
     * @param {TrendingSkillCreateManyAndReturnArgs} args - Arguments to create many TrendingSkills.
     * @example
     * // Create many TrendingSkills
     * const trendingSkill = await prisma.trendingSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrendingSkills and only return the `skillId`
     * const trendingSkillWithSkillIdOnly = await prisma.trendingSkill.createManyAndReturn({ 
     *   select: { skillId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrendingSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, TrendingSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrendingSkillPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TrendingSkill.
     * @param {TrendingSkillDeleteArgs} args - Arguments to delete one TrendingSkill.
     * @example
     * // Delete one TrendingSkill
     * const TrendingSkill = await prisma.trendingSkill.delete({
     *   where: {
     *     // ... filter to delete one TrendingSkill
     *   }
     * })
     * 
     */
    delete<T extends TrendingSkillDeleteArgs>(args: SelectSubset<T, TrendingSkillDeleteArgs<ExtArgs>>): Prisma__TrendingSkillClient<$Result.GetResult<Prisma.$TrendingSkillPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TrendingSkill.
     * @param {TrendingSkillUpdateArgs} args - Arguments to update one TrendingSkill.
     * @example
     * // Update one TrendingSkill
     * const trendingSkill = await prisma.trendingSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrendingSkillUpdateArgs>(args: SelectSubset<T, TrendingSkillUpdateArgs<ExtArgs>>): Prisma__TrendingSkillClient<$Result.GetResult<Prisma.$TrendingSkillPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TrendingSkills.
     * @param {TrendingSkillDeleteManyArgs} args - Arguments to filter TrendingSkills to delete.
     * @example
     * // Delete a few TrendingSkills
     * const { count } = await prisma.trendingSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrendingSkillDeleteManyArgs>(args?: SelectSubset<T, TrendingSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrendingSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendingSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrendingSkills
     * const trendingSkill = await prisma.trendingSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrendingSkillUpdateManyArgs>(args: SelectSubset<T, TrendingSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrendingSkill.
     * @param {TrendingSkillUpsertArgs} args - Arguments to update or create a TrendingSkill.
     * @example
     * // Update or create a TrendingSkill
     * const trendingSkill = await prisma.trendingSkill.upsert({
     *   create: {
     *     // ... data to create a TrendingSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrendingSkill we want to update
     *   }
     * })
     */
    upsert<T extends TrendingSkillUpsertArgs>(args: SelectSubset<T, TrendingSkillUpsertArgs<ExtArgs>>): Prisma__TrendingSkillClient<$Result.GetResult<Prisma.$TrendingSkillPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TrendingSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendingSkillCountArgs} args - Arguments to filter TrendingSkills to count.
     * @example
     * // Count the number of TrendingSkills
     * const count = await prisma.trendingSkill.count({
     *   where: {
     *     // ... the filter for the TrendingSkills we want to count
     *   }
     * })
    **/
    count<T extends TrendingSkillCountArgs>(
      args?: Subset<T, TrendingSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrendingSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrendingSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendingSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrendingSkillAggregateArgs>(args: Subset<T, TrendingSkillAggregateArgs>): Prisma.PrismaPromise<GetTrendingSkillAggregateType<T>>

    /**
     * Group by TrendingSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendingSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrendingSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrendingSkillGroupByArgs['orderBy'] }
        : { orderBy?: TrendingSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrendingSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrendingSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrendingSkill model
   */
  readonly fields: TrendingSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrendingSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrendingSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrendingSkill model
   */ 
  interface TrendingSkillFieldRefs {
    readonly skillId: FieldRef<"TrendingSkill", 'String'>
    readonly demandPercentage: FieldRef<"TrendingSkill", 'Decimal'>
    readonly growthRate: FieldRef<"TrendingSkill", 'Decimal'>
    readonly averageSalary: FieldRef<"TrendingSkill", 'BigInt'>
    readonly openPositions: FieldRef<"TrendingSkill", 'Int'>
    readonly updatedAt: FieldRef<"TrendingSkill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrendingSkill findUnique
   */
  export type TrendingSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendingSkill
     */
    select?: TrendingSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrendingSkillInclude<ExtArgs> | null
    /**
     * Filter, which TrendingSkill to fetch.
     */
    where: TrendingSkillWhereUniqueInput
  }

  /**
   * TrendingSkill findUniqueOrThrow
   */
  export type TrendingSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendingSkill
     */
    select?: TrendingSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrendingSkillInclude<ExtArgs> | null
    /**
     * Filter, which TrendingSkill to fetch.
     */
    where: TrendingSkillWhereUniqueInput
  }

  /**
   * TrendingSkill findFirst
   */
  export type TrendingSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendingSkill
     */
    select?: TrendingSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrendingSkillInclude<ExtArgs> | null
    /**
     * Filter, which TrendingSkill to fetch.
     */
    where?: TrendingSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrendingSkills to fetch.
     */
    orderBy?: TrendingSkillOrderByWithRelationInput | TrendingSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrendingSkills.
     */
    cursor?: TrendingSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrendingSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrendingSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrendingSkills.
     */
    distinct?: TrendingSkillScalarFieldEnum | TrendingSkillScalarFieldEnum[]
  }

  /**
   * TrendingSkill findFirstOrThrow
   */
  export type TrendingSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendingSkill
     */
    select?: TrendingSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrendingSkillInclude<ExtArgs> | null
    /**
     * Filter, which TrendingSkill to fetch.
     */
    where?: TrendingSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrendingSkills to fetch.
     */
    orderBy?: TrendingSkillOrderByWithRelationInput | TrendingSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrendingSkills.
     */
    cursor?: TrendingSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrendingSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrendingSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrendingSkills.
     */
    distinct?: TrendingSkillScalarFieldEnum | TrendingSkillScalarFieldEnum[]
  }

  /**
   * TrendingSkill findMany
   */
  export type TrendingSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendingSkill
     */
    select?: TrendingSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrendingSkillInclude<ExtArgs> | null
    /**
     * Filter, which TrendingSkills to fetch.
     */
    where?: TrendingSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrendingSkills to fetch.
     */
    orderBy?: TrendingSkillOrderByWithRelationInput | TrendingSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrendingSkills.
     */
    cursor?: TrendingSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrendingSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrendingSkills.
     */
    skip?: number
    distinct?: TrendingSkillScalarFieldEnum | TrendingSkillScalarFieldEnum[]
  }

  /**
   * TrendingSkill create
   */
  export type TrendingSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendingSkill
     */
    select?: TrendingSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrendingSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a TrendingSkill.
     */
    data: XOR<TrendingSkillCreateInput, TrendingSkillUncheckedCreateInput>
  }

  /**
   * TrendingSkill createMany
   */
  export type TrendingSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrendingSkills.
     */
    data: TrendingSkillCreateManyInput | TrendingSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrendingSkill createManyAndReturn
   */
  export type TrendingSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendingSkill
     */
    select?: TrendingSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TrendingSkills.
     */
    data: TrendingSkillCreateManyInput | TrendingSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrendingSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrendingSkill update
   */
  export type TrendingSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendingSkill
     */
    select?: TrendingSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrendingSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a TrendingSkill.
     */
    data: XOR<TrendingSkillUpdateInput, TrendingSkillUncheckedUpdateInput>
    /**
     * Choose, which TrendingSkill to update.
     */
    where: TrendingSkillWhereUniqueInput
  }

  /**
   * TrendingSkill updateMany
   */
  export type TrendingSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrendingSkills.
     */
    data: XOR<TrendingSkillUpdateManyMutationInput, TrendingSkillUncheckedUpdateManyInput>
    /**
     * Filter which TrendingSkills to update
     */
    where?: TrendingSkillWhereInput
  }

  /**
   * TrendingSkill upsert
   */
  export type TrendingSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendingSkill
     */
    select?: TrendingSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrendingSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the TrendingSkill to update in case it exists.
     */
    where: TrendingSkillWhereUniqueInput
    /**
     * In case the TrendingSkill found by the `where` argument doesn't exist, create a new TrendingSkill with this data.
     */
    create: XOR<TrendingSkillCreateInput, TrendingSkillUncheckedCreateInput>
    /**
     * In case the TrendingSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrendingSkillUpdateInput, TrendingSkillUncheckedUpdateInput>
  }

  /**
   * TrendingSkill delete
   */
  export type TrendingSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendingSkill
     */
    select?: TrendingSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrendingSkillInclude<ExtArgs> | null
    /**
     * Filter which TrendingSkill to delete.
     */
    where: TrendingSkillWhereUniqueInput
  }

  /**
   * TrendingSkill deleteMany
   */
  export type TrendingSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrendingSkills to delete
     */
    where?: TrendingSkillWhereInput
  }

  /**
   * TrendingSkill without action
   */
  export type TrendingSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendingSkill
     */
    select?: TrendingSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrendingSkillInclude<ExtArgs> | null
  }


  /**
   * Model Credential
   */

  export type AggregateCredential = {
    _count: CredentialCountAggregateOutputType | null
    _min: CredentialMinAggregateOutputType | null
    _max: CredentialMaxAggregateOutputType | null
  }

  export type CredentialMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    issuer: string | null
    type: $Enums.CredentialType | null
    issueDate: Date | null
    expiryDate: Date | null
    verified: boolean | null
    blockchainHash: string | null
    qrCode: string | null
    createdAt: Date | null
  }

  export type CredentialMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    issuer: string | null
    type: $Enums.CredentialType | null
    issueDate: Date | null
    expiryDate: Date | null
    verified: boolean | null
    blockchainHash: string | null
    qrCode: string | null
    createdAt: Date | null
  }

  export type CredentialCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    issuer: number
    type: number
    issueDate: number
    expiryDate: number
    verified: number
    blockchainHash: number
    qrCode: number
    createdAt: number
    _all: number
  }


  export type CredentialMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    issuer?: true
    type?: true
    issueDate?: true
    expiryDate?: true
    verified?: true
    blockchainHash?: true
    qrCode?: true
    createdAt?: true
  }

  export type CredentialMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    issuer?: true
    type?: true
    issueDate?: true
    expiryDate?: true
    verified?: true
    blockchainHash?: true
    qrCode?: true
    createdAt?: true
  }

  export type CredentialCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    issuer?: true
    type?: true
    issueDate?: true
    expiryDate?: true
    verified?: true
    blockchainHash?: true
    qrCode?: true
    createdAt?: true
    _all?: true
  }

  export type CredentialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Credential to aggregate.
     */
    where?: CredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credentials to fetch.
     */
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Credentials
    **/
    _count?: true | CredentialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CredentialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CredentialMaxAggregateInputType
  }

  export type GetCredentialAggregateType<T extends CredentialAggregateArgs> = {
        [P in keyof T & keyof AggregateCredential]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredential[P]>
      : GetScalarType<T[P], AggregateCredential[P]>
  }




  export type CredentialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CredentialWhereInput
    orderBy?: CredentialOrderByWithAggregationInput | CredentialOrderByWithAggregationInput[]
    by: CredentialScalarFieldEnum[] | CredentialScalarFieldEnum
    having?: CredentialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CredentialCountAggregateInputType | true
    _min?: CredentialMinAggregateInputType
    _max?: CredentialMaxAggregateInputType
  }

  export type CredentialGroupByOutputType = {
    id: string
    userId: string
    title: string
    issuer: string
    type: $Enums.CredentialType
    issueDate: Date
    expiryDate: Date | null
    verified: boolean
    blockchainHash: string | null
    qrCode: string | null
    createdAt: Date
    _count: CredentialCountAggregateOutputType | null
    _min: CredentialMinAggregateOutputType | null
    _max: CredentialMaxAggregateOutputType | null
  }

  type GetCredentialGroupByPayload<T extends CredentialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CredentialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CredentialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CredentialGroupByOutputType[P]>
            : GetScalarType<T[P], CredentialGroupByOutputType[P]>
        }
      >
    >


  export type CredentialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    issuer?: boolean
    type?: boolean
    issueDate?: boolean
    expiryDate?: boolean
    verified?: boolean
    blockchainHash?: boolean
    qrCode?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    skills?: boolean | Credential$skillsArgs<ExtArgs>
    verificationRequests?: boolean | Credential$verificationRequestsArgs<ExtArgs>
    _count?: boolean | CredentialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credential"]>

  export type CredentialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    issuer?: boolean
    type?: boolean
    issueDate?: boolean
    expiryDate?: boolean
    verified?: boolean
    blockchainHash?: boolean
    qrCode?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credential"]>

  export type CredentialSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    issuer?: boolean
    type?: boolean
    issueDate?: boolean
    expiryDate?: boolean
    verified?: boolean
    blockchainHash?: boolean
    qrCode?: boolean
    createdAt?: boolean
  }

  export type CredentialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    skills?: boolean | Credential$skillsArgs<ExtArgs>
    verificationRequests?: boolean | Credential$verificationRequestsArgs<ExtArgs>
    _count?: boolean | CredentialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CredentialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CredentialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Credential"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      skills: Prisma.$CredentialSkillPayload<ExtArgs>[]
      verificationRequests: Prisma.$VerificationRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      issuer: string
      type: $Enums.CredentialType
      issueDate: Date
      expiryDate: Date | null
      verified: boolean
      blockchainHash: string | null
      qrCode: string | null
      createdAt: Date
    }, ExtArgs["result"]["credential"]>
    composites: {}
  }

  type CredentialGetPayload<S extends boolean | null | undefined | CredentialDefaultArgs> = $Result.GetResult<Prisma.$CredentialPayload, S>

  type CredentialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CredentialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CredentialCountAggregateInputType | true
    }

  export interface CredentialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Credential'], meta: { name: 'Credential' } }
    /**
     * Find zero or one Credential that matches the filter.
     * @param {CredentialFindUniqueArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CredentialFindUniqueArgs>(args: SelectSubset<T, CredentialFindUniqueArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Credential that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CredentialFindUniqueOrThrowArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CredentialFindUniqueOrThrowArgs>(args: SelectSubset<T, CredentialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Credential that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialFindFirstArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CredentialFindFirstArgs>(args?: SelectSubset<T, CredentialFindFirstArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Credential that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialFindFirstOrThrowArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CredentialFindFirstOrThrowArgs>(args?: SelectSubset<T, CredentialFindFirstOrThrowArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Credentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Credentials
     * const credentials = await prisma.credential.findMany()
     * 
     * // Get first 10 Credentials
     * const credentials = await prisma.credential.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const credentialWithIdOnly = await prisma.credential.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CredentialFindManyArgs>(args?: SelectSubset<T, CredentialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Credential.
     * @param {CredentialCreateArgs} args - Arguments to create a Credential.
     * @example
     * // Create one Credential
     * const Credential = await prisma.credential.create({
     *   data: {
     *     // ... data to create a Credential
     *   }
     * })
     * 
     */
    create<T extends CredentialCreateArgs>(args: SelectSubset<T, CredentialCreateArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Credentials.
     * @param {CredentialCreateManyArgs} args - Arguments to create many Credentials.
     * @example
     * // Create many Credentials
     * const credential = await prisma.credential.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CredentialCreateManyArgs>(args?: SelectSubset<T, CredentialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Credentials and returns the data saved in the database.
     * @param {CredentialCreateManyAndReturnArgs} args - Arguments to create many Credentials.
     * @example
     * // Create many Credentials
     * const credential = await prisma.credential.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Credentials and only return the `id`
     * const credentialWithIdOnly = await prisma.credential.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CredentialCreateManyAndReturnArgs>(args?: SelectSubset<T, CredentialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Credential.
     * @param {CredentialDeleteArgs} args - Arguments to delete one Credential.
     * @example
     * // Delete one Credential
     * const Credential = await prisma.credential.delete({
     *   where: {
     *     // ... filter to delete one Credential
     *   }
     * })
     * 
     */
    delete<T extends CredentialDeleteArgs>(args: SelectSubset<T, CredentialDeleteArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Credential.
     * @param {CredentialUpdateArgs} args - Arguments to update one Credential.
     * @example
     * // Update one Credential
     * const credential = await prisma.credential.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CredentialUpdateArgs>(args: SelectSubset<T, CredentialUpdateArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Credentials.
     * @param {CredentialDeleteManyArgs} args - Arguments to filter Credentials to delete.
     * @example
     * // Delete a few Credentials
     * const { count } = await prisma.credential.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CredentialDeleteManyArgs>(args?: SelectSubset<T, CredentialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Credentials
     * const credential = await prisma.credential.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CredentialUpdateManyArgs>(args: SelectSubset<T, CredentialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Credential.
     * @param {CredentialUpsertArgs} args - Arguments to update or create a Credential.
     * @example
     * // Update or create a Credential
     * const credential = await prisma.credential.upsert({
     *   create: {
     *     // ... data to create a Credential
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Credential we want to update
     *   }
     * })
     */
    upsert<T extends CredentialUpsertArgs>(args: SelectSubset<T, CredentialUpsertArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Credentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialCountArgs} args - Arguments to filter Credentials to count.
     * @example
     * // Count the number of Credentials
     * const count = await prisma.credential.count({
     *   where: {
     *     // ... the filter for the Credentials we want to count
     *   }
     * })
    **/
    count<T extends CredentialCountArgs>(
      args?: Subset<T, CredentialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CredentialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Credential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CredentialAggregateArgs>(args: Subset<T, CredentialAggregateArgs>): Prisma.PrismaPromise<GetCredentialAggregateType<T>>

    /**
     * Group by Credential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CredentialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CredentialGroupByArgs['orderBy'] }
        : { orderBy?: CredentialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CredentialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCredentialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Credential model
   */
  readonly fields: CredentialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Credential.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CredentialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    skills<T extends Credential$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Credential$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialSkillPayload<ExtArgs>, T, "findMany"> | Null>
    verificationRequests<T extends Credential$verificationRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Credential$verificationRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationRequestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Credential model
   */ 
  interface CredentialFieldRefs {
    readonly id: FieldRef<"Credential", 'String'>
    readonly userId: FieldRef<"Credential", 'String'>
    readonly title: FieldRef<"Credential", 'String'>
    readonly issuer: FieldRef<"Credential", 'String'>
    readonly type: FieldRef<"Credential", 'CredentialType'>
    readonly issueDate: FieldRef<"Credential", 'DateTime'>
    readonly expiryDate: FieldRef<"Credential", 'DateTime'>
    readonly verified: FieldRef<"Credential", 'Boolean'>
    readonly blockchainHash: FieldRef<"Credential", 'String'>
    readonly qrCode: FieldRef<"Credential", 'String'>
    readonly createdAt: FieldRef<"Credential", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Credential findUnique
   */
  export type CredentialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credential to fetch.
     */
    where: CredentialWhereUniqueInput
  }

  /**
   * Credential findUniqueOrThrow
   */
  export type CredentialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credential to fetch.
     */
    where: CredentialWhereUniqueInput
  }

  /**
   * Credential findFirst
   */
  export type CredentialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credential to fetch.
     */
    where?: CredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credentials to fetch.
     */
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Credentials.
     */
    cursor?: CredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Credentials.
     */
    distinct?: CredentialScalarFieldEnum | CredentialScalarFieldEnum[]
  }

  /**
   * Credential findFirstOrThrow
   */
  export type CredentialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credential to fetch.
     */
    where?: CredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credentials to fetch.
     */
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Credentials.
     */
    cursor?: CredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Credentials.
     */
    distinct?: CredentialScalarFieldEnum | CredentialScalarFieldEnum[]
  }

  /**
   * Credential findMany
   */
  export type CredentialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credentials to fetch.
     */
    where?: CredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credentials to fetch.
     */
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Credentials.
     */
    cursor?: CredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credentials.
     */
    skip?: number
    distinct?: CredentialScalarFieldEnum | CredentialScalarFieldEnum[]
  }

  /**
   * Credential create
   */
  export type CredentialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * The data needed to create a Credential.
     */
    data: XOR<CredentialCreateInput, CredentialUncheckedCreateInput>
  }

  /**
   * Credential createMany
   */
  export type CredentialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Credentials.
     */
    data: CredentialCreateManyInput | CredentialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Credential createManyAndReturn
   */
  export type CredentialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Credentials.
     */
    data: CredentialCreateManyInput | CredentialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Credential update
   */
  export type CredentialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * The data needed to update a Credential.
     */
    data: XOR<CredentialUpdateInput, CredentialUncheckedUpdateInput>
    /**
     * Choose, which Credential to update.
     */
    where: CredentialWhereUniqueInput
  }

  /**
   * Credential updateMany
   */
  export type CredentialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Credentials.
     */
    data: XOR<CredentialUpdateManyMutationInput, CredentialUncheckedUpdateManyInput>
    /**
     * Filter which Credentials to update
     */
    where?: CredentialWhereInput
  }

  /**
   * Credential upsert
   */
  export type CredentialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * The filter to search for the Credential to update in case it exists.
     */
    where: CredentialWhereUniqueInput
    /**
     * In case the Credential found by the `where` argument doesn't exist, create a new Credential with this data.
     */
    create: XOR<CredentialCreateInput, CredentialUncheckedCreateInput>
    /**
     * In case the Credential was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CredentialUpdateInput, CredentialUncheckedUpdateInput>
  }

  /**
   * Credential delete
   */
  export type CredentialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter which Credential to delete.
     */
    where: CredentialWhereUniqueInput
  }

  /**
   * Credential deleteMany
   */
  export type CredentialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Credentials to delete
     */
    where?: CredentialWhereInput
  }

  /**
   * Credential.skills
   */
  export type Credential$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialSkill
     */
    select?: CredentialSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialSkillInclude<ExtArgs> | null
    where?: CredentialSkillWhereInput
    orderBy?: CredentialSkillOrderByWithRelationInput | CredentialSkillOrderByWithRelationInput[]
    cursor?: CredentialSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CredentialSkillScalarFieldEnum | CredentialSkillScalarFieldEnum[]
  }

  /**
   * Credential.verificationRequests
   */
  export type Credential$verificationRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationRequestInclude<ExtArgs> | null
    where?: VerificationRequestWhereInput
    orderBy?: VerificationRequestOrderByWithRelationInput | VerificationRequestOrderByWithRelationInput[]
    cursor?: VerificationRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerificationRequestScalarFieldEnum | VerificationRequestScalarFieldEnum[]
  }

  /**
   * Credential without action
   */
  export type CredentialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
  }


  /**
   * Model CredentialSkill
   */

  export type AggregateCredentialSkill = {
    _count: CredentialSkillCountAggregateOutputType | null
    _min: CredentialSkillMinAggregateOutputType | null
    _max: CredentialSkillMaxAggregateOutputType | null
  }

  export type CredentialSkillMinAggregateOutputType = {
    credentialId: string | null
    skillId: string | null
  }

  export type CredentialSkillMaxAggregateOutputType = {
    credentialId: string | null
    skillId: string | null
  }

  export type CredentialSkillCountAggregateOutputType = {
    credentialId: number
    skillId: number
    _all: number
  }


  export type CredentialSkillMinAggregateInputType = {
    credentialId?: true
    skillId?: true
  }

  export type CredentialSkillMaxAggregateInputType = {
    credentialId?: true
    skillId?: true
  }

  export type CredentialSkillCountAggregateInputType = {
    credentialId?: true
    skillId?: true
    _all?: true
  }

  export type CredentialSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CredentialSkill to aggregate.
     */
    where?: CredentialSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CredentialSkills to fetch.
     */
    orderBy?: CredentialSkillOrderByWithRelationInput | CredentialSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CredentialSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CredentialSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CredentialSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CredentialSkills
    **/
    _count?: true | CredentialSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CredentialSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CredentialSkillMaxAggregateInputType
  }

  export type GetCredentialSkillAggregateType<T extends CredentialSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateCredentialSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredentialSkill[P]>
      : GetScalarType<T[P], AggregateCredentialSkill[P]>
  }




  export type CredentialSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CredentialSkillWhereInput
    orderBy?: CredentialSkillOrderByWithAggregationInput | CredentialSkillOrderByWithAggregationInput[]
    by: CredentialSkillScalarFieldEnum[] | CredentialSkillScalarFieldEnum
    having?: CredentialSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CredentialSkillCountAggregateInputType | true
    _min?: CredentialSkillMinAggregateInputType
    _max?: CredentialSkillMaxAggregateInputType
  }

  export type CredentialSkillGroupByOutputType = {
    credentialId: string
    skillId: string
    _count: CredentialSkillCountAggregateOutputType | null
    _min: CredentialSkillMinAggregateOutputType | null
    _max: CredentialSkillMaxAggregateOutputType | null
  }

  type GetCredentialSkillGroupByPayload<T extends CredentialSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CredentialSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CredentialSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CredentialSkillGroupByOutputType[P]>
            : GetScalarType<T[P], CredentialSkillGroupByOutputType[P]>
        }
      >
    >


  export type CredentialSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    credentialId?: boolean
    skillId?: boolean
    credential?: boolean | CredentialDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credentialSkill"]>

  export type CredentialSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    credentialId?: boolean
    skillId?: boolean
    credential?: boolean | CredentialDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credentialSkill"]>

  export type CredentialSkillSelectScalar = {
    credentialId?: boolean
    skillId?: boolean
  }

  export type CredentialSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credential?: boolean | CredentialDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type CredentialSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credential?: boolean | CredentialDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }

  export type $CredentialSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CredentialSkill"
    objects: {
      credential: Prisma.$CredentialPayload<ExtArgs>
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      credentialId: string
      skillId: string
    }, ExtArgs["result"]["credentialSkill"]>
    composites: {}
  }

  type CredentialSkillGetPayload<S extends boolean | null | undefined | CredentialSkillDefaultArgs> = $Result.GetResult<Prisma.$CredentialSkillPayload, S>

  type CredentialSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CredentialSkillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CredentialSkillCountAggregateInputType | true
    }

  export interface CredentialSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CredentialSkill'], meta: { name: 'CredentialSkill' } }
    /**
     * Find zero or one CredentialSkill that matches the filter.
     * @param {CredentialSkillFindUniqueArgs} args - Arguments to find a CredentialSkill
     * @example
     * // Get one CredentialSkill
     * const credentialSkill = await prisma.credentialSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CredentialSkillFindUniqueArgs>(args: SelectSubset<T, CredentialSkillFindUniqueArgs<ExtArgs>>): Prisma__CredentialSkillClient<$Result.GetResult<Prisma.$CredentialSkillPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CredentialSkill that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CredentialSkillFindUniqueOrThrowArgs} args - Arguments to find a CredentialSkill
     * @example
     * // Get one CredentialSkill
     * const credentialSkill = await prisma.credentialSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CredentialSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, CredentialSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CredentialSkillClient<$Result.GetResult<Prisma.$CredentialSkillPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CredentialSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialSkillFindFirstArgs} args - Arguments to find a CredentialSkill
     * @example
     * // Get one CredentialSkill
     * const credentialSkill = await prisma.credentialSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CredentialSkillFindFirstArgs>(args?: SelectSubset<T, CredentialSkillFindFirstArgs<ExtArgs>>): Prisma__CredentialSkillClient<$Result.GetResult<Prisma.$CredentialSkillPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CredentialSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialSkillFindFirstOrThrowArgs} args - Arguments to find a CredentialSkill
     * @example
     * // Get one CredentialSkill
     * const credentialSkill = await prisma.credentialSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CredentialSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, CredentialSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__CredentialSkillClient<$Result.GetResult<Prisma.$CredentialSkillPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CredentialSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CredentialSkills
     * const credentialSkills = await prisma.credentialSkill.findMany()
     * 
     * // Get first 10 CredentialSkills
     * const credentialSkills = await prisma.credentialSkill.findMany({ take: 10 })
     * 
     * // Only select the `credentialId`
     * const credentialSkillWithCredentialIdOnly = await prisma.credentialSkill.findMany({ select: { credentialId: true } })
     * 
     */
    findMany<T extends CredentialSkillFindManyArgs>(args?: SelectSubset<T, CredentialSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialSkillPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CredentialSkill.
     * @param {CredentialSkillCreateArgs} args - Arguments to create a CredentialSkill.
     * @example
     * // Create one CredentialSkill
     * const CredentialSkill = await prisma.credentialSkill.create({
     *   data: {
     *     // ... data to create a CredentialSkill
     *   }
     * })
     * 
     */
    create<T extends CredentialSkillCreateArgs>(args: SelectSubset<T, CredentialSkillCreateArgs<ExtArgs>>): Prisma__CredentialSkillClient<$Result.GetResult<Prisma.$CredentialSkillPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CredentialSkills.
     * @param {CredentialSkillCreateManyArgs} args - Arguments to create many CredentialSkills.
     * @example
     * // Create many CredentialSkills
     * const credentialSkill = await prisma.credentialSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CredentialSkillCreateManyArgs>(args?: SelectSubset<T, CredentialSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CredentialSkills and returns the data saved in the database.
     * @param {CredentialSkillCreateManyAndReturnArgs} args - Arguments to create many CredentialSkills.
     * @example
     * // Create many CredentialSkills
     * const credentialSkill = await prisma.credentialSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CredentialSkills and only return the `credentialId`
     * const credentialSkillWithCredentialIdOnly = await prisma.credentialSkill.createManyAndReturn({ 
     *   select: { credentialId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CredentialSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, CredentialSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialSkillPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CredentialSkill.
     * @param {CredentialSkillDeleteArgs} args - Arguments to delete one CredentialSkill.
     * @example
     * // Delete one CredentialSkill
     * const CredentialSkill = await prisma.credentialSkill.delete({
     *   where: {
     *     // ... filter to delete one CredentialSkill
     *   }
     * })
     * 
     */
    delete<T extends CredentialSkillDeleteArgs>(args: SelectSubset<T, CredentialSkillDeleteArgs<ExtArgs>>): Prisma__CredentialSkillClient<$Result.GetResult<Prisma.$CredentialSkillPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CredentialSkill.
     * @param {CredentialSkillUpdateArgs} args - Arguments to update one CredentialSkill.
     * @example
     * // Update one CredentialSkill
     * const credentialSkill = await prisma.credentialSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CredentialSkillUpdateArgs>(args: SelectSubset<T, CredentialSkillUpdateArgs<ExtArgs>>): Prisma__CredentialSkillClient<$Result.GetResult<Prisma.$CredentialSkillPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CredentialSkills.
     * @param {CredentialSkillDeleteManyArgs} args - Arguments to filter CredentialSkills to delete.
     * @example
     * // Delete a few CredentialSkills
     * const { count } = await prisma.credentialSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CredentialSkillDeleteManyArgs>(args?: SelectSubset<T, CredentialSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CredentialSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CredentialSkills
     * const credentialSkill = await prisma.credentialSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CredentialSkillUpdateManyArgs>(args: SelectSubset<T, CredentialSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CredentialSkill.
     * @param {CredentialSkillUpsertArgs} args - Arguments to update or create a CredentialSkill.
     * @example
     * // Update or create a CredentialSkill
     * const credentialSkill = await prisma.credentialSkill.upsert({
     *   create: {
     *     // ... data to create a CredentialSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CredentialSkill we want to update
     *   }
     * })
     */
    upsert<T extends CredentialSkillUpsertArgs>(args: SelectSubset<T, CredentialSkillUpsertArgs<ExtArgs>>): Prisma__CredentialSkillClient<$Result.GetResult<Prisma.$CredentialSkillPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CredentialSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialSkillCountArgs} args - Arguments to filter CredentialSkills to count.
     * @example
     * // Count the number of CredentialSkills
     * const count = await prisma.credentialSkill.count({
     *   where: {
     *     // ... the filter for the CredentialSkills we want to count
     *   }
     * })
    **/
    count<T extends CredentialSkillCountArgs>(
      args?: Subset<T, CredentialSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CredentialSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CredentialSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CredentialSkillAggregateArgs>(args: Subset<T, CredentialSkillAggregateArgs>): Prisma.PrismaPromise<GetCredentialSkillAggregateType<T>>

    /**
     * Group by CredentialSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CredentialSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CredentialSkillGroupByArgs['orderBy'] }
        : { orderBy?: CredentialSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CredentialSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCredentialSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CredentialSkill model
   */
  readonly fields: CredentialSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CredentialSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CredentialSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    credential<T extends CredentialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CredentialDefaultArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CredentialSkill model
   */ 
  interface CredentialSkillFieldRefs {
    readonly credentialId: FieldRef<"CredentialSkill", 'String'>
    readonly skillId: FieldRef<"CredentialSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CredentialSkill findUnique
   */
  export type CredentialSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialSkill
     */
    select?: CredentialSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialSkillInclude<ExtArgs> | null
    /**
     * Filter, which CredentialSkill to fetch.
     */
    where: CredentialSkillWhereUniqueInput
  }

  /**
   * CredentialSkill findUniqueOrThrow
   */
  export type CredentialSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialSkill
     */
    select?: CredentialSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialSkillInclude<ExtArgs> | null
    /**
     * Filter, which CredentialSkill to fetch.
     */
    where: CredentialSkillWhereUniqueInput
  }

  /**
   * CredentialSkill findFirst
   */
  export type CredentialSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialSkill
     */
    select?: CredentialSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialSkillInclude<ExtArgs> | null
    /**
     * Filter, which CredentialSkill to fetch.
     */
    where?: CredentialSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CredentialSkills to fetch.
     */
    orderBy?: CredentialSkillOrderByWithRelationInput | CredentialSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CredentialSkills.
     */
    cursor?: CredentialSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CredentialSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CredentialSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CredentialSkills.
     */
    distinct?: CredentialSkillScalarFieldEnum | CredentialSkillScalarFieldEnum[]
  }

  /**
   * CredentialSkill findFirstOrThrow
   */
  export type CredentialSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialSkill
     */
    select?: CredentialSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialSkillInclude<ExtArgs> | null
    /**
     * Filter, which CredentialSkill to fetch.
     */
    where?: CredentialSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CredentialSkills to fetch.
     */
    orderBy?: CredentialSkillOrderByWithRelationInput | CredentialSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CredentialSkills.
     */
    cursor?: CredentialSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CredentialSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CredentialSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CredentialSkills.
     */
    distinct?: CredentialSkillScalarFieldEnum | CredentialSkillScalarFieldEnum[]
  }

  /**
   * CredentialSkill findMany
   */
  export type CredentialSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialSkill
     */
    select?: CredentialSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialSkillInclude<ExtArgs> | null
    /**
     * Filter, which CredentialSkills to fetch.
     */
    where?: CredentialSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CredentialSkills to fetch.
     */
    orderBy?: CredentialSkillOrderByWithRelationInput | CredentialSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CredentialSkills.
     */
    cursor?: CredentialSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CredentialSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CredentialSkills.
     */
    skip?: number
    distinct?: CredentialSkillScalarFieldEnum | CredentialSkillScalarFieldEnum[]
  }

  /**
   * CredentialSkill create
   */
  export type CredentialSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialSkill
     */
    select?: CredentialSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a CredentialSkill.
     */
    data: XOR<CredentialSkillCreateInput, CredentialSkillUncheckedCreateInput>
  }

  /**
   * CredentialSkill createMany
   */
  export type CredentialSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CredentialSkills.
     */
    data: CredentialSkillCreateManyInput | CredentialSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CredentialSkill createManyAndReturn
   */
  export type CredentialSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialSkill
     */
    select?: CredentialSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CredentialSkills.
     */
    data: CredentialSkillCreateManyInput | CredentialSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CredentialSkill update
   */
  export type CredentialSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialSkill
     */
    select?: CredentialSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a CredentialSkill.
     */
    data: XOR<CredentialSkillUpdateInput, CredentialSkillUncheckedUpdateInput>
    /**
     * Choose, which CredentialSkill to update.
     */
    where: CredentialSkillWhereUniqueInput
  }

  /**
   * CredentialSkill updateMany
   */
  export type CredentialSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CredentialSkills.
     */
    data: XOR<CredentialSkillUpdateManyMutationInput, CredentialSkillUncheckedUpdateManyInput>
    /**
     * Filter which CredentialSkills to update
     */
    where?: CredentialSkillWhereInput
  }

  /**
   * CredentialSkill upsert
   */
  export type CredentialSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialSkill
     */
    select?: CredentialSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the CredentialSkill to update in case it exists.
     */
    where: CredentialSkillWhereUniqueInput
    /**
     * In case the CredentialSkill found by the `where` argument doesn't exist, create a new CredentialSkill with this data.
     */
    create: XOR<CredentialSkillCreateInput, CredentialSkillUncheckedCreateInput>
    /**
     * In case the CredentialSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CredentialSkillUpdateInput, CredentialSkillUncheckedUpdateInput>
  }

  /**
   * CredentialSkill delete
   */
  export type CredentialSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialSkill
     */
    select?: CredentialSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialSkillInclude<ExtArgs> | null
    /**
     * Filter which CredentialSkill to delete.
     */
    where: CredentialSkillWhereUniqueInput
  }

  /**
   * CredentialSkill deleteMany
   */
  export type CredentialSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CredentialSkills to delete
     */
    where?: CredentialSkillWhereInput
  }

  /**
   * CredentialSkill without action
   */
  export type CredentialSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialSkill
     */
    select?: CredentialSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialSkillInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    visibility: $Enums.ProjectVisibility | null
    verified: boolean | null
    githubUrl: string | null
    liveUrl: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    visibility: $Enums.ProjectVisibility | null
    verified: boolean | null
    githubUrl: string | null
    liveUrl: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    description: number
    visibility: number
    verified: number
    githubUrl: number
    liveUrl: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    visibility?: true
    verified?: true
    githubUrl?: true
    liveUrl?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    visibility?: true
    verified?: true
    githubUrl?: true
    liveUrl?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    visibility?: true
    verified?: true
    githubUrl?: true
    liveUrl?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    userId: string
    title: string
    description: string
    visibility: $Enums.ProjectVisibility
    verified: boolean
    githubUrl: string | null
    liveUrl: string | null
    startDate: Date
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    visibility?: boolean
    verified?: boolean
    githubUrl?: boolean
    liveUrl?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    media?: boolean | Project$mediaArgs<ExtArgs>
    skills?: boolean | Project$skillsArgs<ExtArgs>
    collaborators?: boolean | Project$collaboratorsArgs<ExtArgs>
    endorsements?: boolean | Project$endorsementsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    visibility?: boolean
    verified?: boolean
    githubUrl?: boolean
    liveUrl?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    visibility?: boolean
    verified?: boolean
    githubUrl?: boolean
    liveUrl?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    media?: boolean | Project$mediaArgs<ExtArgs>
    skills?: boolean | Project$skillsArgs<ExtArgs>
    collaborators?: boolean | Project$collaboratorsArgs<ExtArgs>
    endorsements?: boolean | Project$endorsementsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      media: Prisma.$ProjectMediaPayload<ExtArgs>[]
      skills: Prisma.$ProjectSkillPayload<ExtArgs>[]
      collaborators: Prisma.$ProjectCollaboratorPayload<ExtArgs>[]
      endorsements: Prisma.$EndorsementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      description: string
      visibility: $Enums.ProjectVisibility
      verified: boolean
      githubUrl: string | null
      liveUrl: string | null
      startDate: Date
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    media<T extends Project$mediaArgs<ExtArgs> = {}>(args?: Subset<T, Project$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMediaPayload<ExtArgs>, T, "findMany"> | Null>
    skills<T extends Project$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Project$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSkillPayload<ExtArgs>, T, "findMany"> | Null>
    collaborators<T extends Project$collaboratorsArgs<ExtArgs> = {}>(args?: Subset<T, Project$collaboratorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "findMany"> | Null>
    endorsements<T extends Project$endorsementsArgs<ExtArgs> = {}>(args?: Subset<T, Project$endorsementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EndorsementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly userId: FieldRef<"Project", 'String'>
    readonly title: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly visibility: FieldRef<"Project", 'ProjectVisibility'>
    readonly verified: FieldRef<"Project", 'Boolean'>
    readonly githubUrl: FieldRef<"Project", 'String'>
    readonly liveUrl: FieldRef<"Project", 'String'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly endDate: FieldRef<"Project", 'DateTime'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project.media
   */
  export type Project$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMedia
     */
    select?: ProjectMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMediaInclude<ExtArgs> | null
    where?: ProjectMediaWhereInput
    orderBy?: ProjectMediaOrderByWithRelationInput | ProjectMediaOrderByWithRelationInput[]
    cursor?: ProjectMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMediaScalarFieldEnum | ProjectMediaScalarFieldEnum[]
  }

  /**
   * Project.skills
   */
  export type Project$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillInclude<ExtArgs> | null
    where?: ProjectSkillWhereInput
    orderBy?: ProjectSkillOrderByWithRelationInput | ProjectSkillOrderByWithRelationInput[]
    cursor?: ProjectSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectSkillScalarFieldEnum | ProjectSkillScalarFieldEnum[]
  }

  /**
   * Project.collaborators
   */
  export type Project$collaboratorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    where?: ProjectCollaboratorWhereInput
    orderBy?: ProjectCollaboratorOrderByWithRelationInput | ProjectCollaboratorOrderByWithRelationInput[]
    cursor?: ProjectCollaboratorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectCollaboratorScalarFieldEnum | ProjectCollaboratorScalarFieldEnum[]
  }

  /**
   * Project.endorsements
   */
  export type Project$endorsementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endorsement
     */
    select?: EndorsementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndorsementInclude<ExtArgs> | null
    where?: EndorsementWhereInput
    orderBy?: EndorsementOrderByWithRelationInput | EndorsementOrderByWithRelationInput[]
    cursor?: EndorsementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EndorsementScalarFieldEnum | EndorsementScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectMedia
   */

  export type AggregateProjectMedia = {
    _count: ProjectMediaCountAggregateOutputType | null
    _avg: ProjectMediaAvgAggregateOutputType | null
    _sum: ProjectMediaSumAggregateOutputType | null
    _min: ProjectMediaMinAggregateOutputType | null
    _max: ProjectMediaMaxAggregateOutputType | null
  }

  export type ProjectMediaAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type ProjectMediaSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type ProjectMediaMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    type: $Enums.MediaType | null
    url: string | null
    thumbnail: string | null
    caption: string | null
    displayOrder: number | null
  }

  export type ProjectMediaMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    type: $Enums.MediaType | null
    url: string | null
    thumbnail: string | null
    caption: string | null
    displayOrder: number | null
  }

  export type ProjectMediaCountAggregateOutputType = {
    id: number
    projectId: number
    type: number
    url: number
    thumbnail: number
    caption: number
    displayOrder: number
    _all: number
  }


  export type ProjectMediaAvgAggregateInputType = {
    displayOrder?: true
  }

  export type ProjectMediaSumAggregateInputType = {
    displayOrder?: true
  }

  export type ProjectMediaMinAggregateInputType = {
    id?: true
    projectId?: true
    type?: true
    url?: true
    thumbnail?: true
    caption?: true
    displayOrder?: true
  }

  export type ProjectMediaMaxAggregateInputType = {
    id?: true
    projectId?: true
    type?: true
    url?: true
    thumbnail?: true
    caption?: true
    displayOrder?: true
  }

  export type ProjectMediaCountAggregateInputType = {
    id?: true
    projectId?: true
    type?: true
    url?: true
    thumbnail?: true
    caption?: true
    displayOrder?: true
    _all?: true
  }

  export type ProjectMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMedia to aggregate.
     */
    where?: ProjectMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMedias to fetch.
     */
    orderBy?: ProjectMediaOrderByWithRelationInput | ProjectMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectMedias
    **/
    _count?: true | ProjectMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectMediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectMediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMediaMaxAggregateInputType
  }

  export type GetProjectMediaAggregateType<T extends ProjectMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectMedia[P]>
      : GetScalarType<T[P], AggregateProjectMedia[P]>
  }




  export type ProjectMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMediaWhereInput
    orderBy?: ProjectMediaOrderByWithAggregationInput | ProjectMediaOrderByWithAggregationInput[]
    by: ProjectMediaScalarFieldEnum[] | ProjectMediaScalarFieldEnum
    having?: ProjectMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectMediaCountAggregateInputType | true
    _avg?: ProjectMediaAvgAggregateInputType
    _sum?: ProjectMediaSumAggregateInputType
    _min?: ProjectMediaMinAggregateInputType
    _max?: ProjectMediaMaxAggregateInputType
  }

  export type ProjectMediaGroupByOutputType = {
    id: string
    projectId: string
    type: $Enums.MediaType
    url: string
    thumbnail: string | null
    caption: string | null
    displayOrder: number
    _count: ProjectMediaCountAggregateOutputType | null
    _avg: ProjectMediaAvgAggregateOutputType | null
    _sum: ProjectMediaSumAggregateOutputType | null
    _min: ProjectMediaMinAggregateOutputType | null
    _max: ProjectMediaMaxAggregateOutputType | null
  }

  type GetProjectMediaGroupByPayload<T extends ProjectMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectMediaGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectMediaGroupByOutputType[P]>
        }
      >
    >


  export type ProjectMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    type?: boolean
    url?: boolean
    thumbnail?: boolean
    caption?: boolean
    displayOrder?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMedia"]>

  export type ProjectMediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    type?: boolean
    url?: boolean
    thumbnail?: boolean
    caption?: boolean
    displayOrder?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMedia"]>

  export type ProjectMediaSelectScalar = {
    id?: boolean
    projectId?: boolean
    type?: boolean
    url?: boolean
    thumbnail?: boolean
    caption?: boolean
    displayOrder?: boolean
  }

  export type ProjectMediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectMediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectMedia"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      type: $Enums.MediaType
      url: string
      thumbnail: string | null
      caption: string | null
      displayOrder: number
    }, ExtArgs["result"]["projectMedia"]>
    composites: {}
  }

  type ProjectMediaGetPayload<S extends boolean | null | undefined | ProjectMediaDefaultArgs> = $Result.GetResult<Prisma.$ProjectMediaPayload, S>

  type ProjectMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectMediaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectMediaCountAggregateInputType | true
    }

  export interface ProjectMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectMedia'], meta: { name: 'ProjectMedia' } }
    /**
     * Find zero or one ProjectMedia that matches the filter.
     * @param {ProjectMediaFindUniqueArgs} args - Arguments to find a ProjectMedia
     * @example
     * // Get one ProjectMedia
     * const projectMedia = await prisma.projectMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectMediaFindUniqueArgs>(args: SelectSubset<T, ProjectMediaFindUniqueArgs<ExtArgs>>): Prisma__ProjectMediaClient<$Result.GetResult<Prisma.$ProjectMediaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectMedia that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectMediaFindUniqueOrThrowArgs} args - Arguments to find a ProjectMedia
     * @example
     * // Get one ProjectMedia
     * const projectMedia = await prisma.projectMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectMediaFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectMediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectMediaClient<$Result.GetResult<Prisma.$ProjectMediaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMediaFindFirstArgs} args - Arguments to find a ProjectMedia
     * @example
     * // Get one ProjectMedia
     * const projectMedia = await prisma.projectMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectMediaFindFirstArgs>(args?: SelectSubset<T, ProjectMediaFindFirstArgs<ExtArgs>>): Prisma__ProjectMediaClient<$Result.GetResult<Prisma.$ProjectMediaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMediaFindFirstOrThrowArgs} args - Arguments to find a ProjectMedia
     * @example
     * // Get one ProjectMedia
     * const projectMedia = await prisma.projectMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectMediaFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectMediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectMediaClient<$Result.GetResult<Prisma.$ProjectMediaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectMedias
     * const projectMedias = await prisma.projectMedia.findMany()
     * 
     * // Get first 10 ProjectMedias
     * const projectMedias = await prisma.projectMedia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectMediaWithIdOnly = await prisma.projectMedia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectMediaFindManyArgs>(args?: SelectSubset<T, ProjectMediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMediaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectMedia.
     * @param {ProjectMediaCreateArgs} args - Arguments to create a ProjectMedia.
     * @example
     * // Create one ProjectMedia
     * const ProjectMedia = await prisma.projectMedia.create({
     *   data: {
     *     // ... data to create a ProjectMedia
     *   }
     * })
     * 
     */
    create<T extends ProjectMediaCreateArgs>(args: SelectSubset<T, ProjectMediaCreateArgs<ExtArgs>>): Prisma__ProjectMediaClient<$Result.GetResult<Prisma.$ProjectMediaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectMedias.
     * @param {ProjectMediaCreateManyArgs} args - Arguments to create many ProjectMedias.
     * @example
     * // Create many ProjectMedias
     * const projectMedia = await prisma.projectMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectMediaCreateManyArgs>(args?: SelectSubset<T, ProjectMediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectMedias and returns the data saved in the database.
     * @param {ProjectMediaCreateManyAndReturnArgs} args - Arguments to create many ProjectMedias.
     * @example
     * // Create many ProjectMedias
     * const projectMedia = await prisma.projectMedia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectMedias and only return the `id`
     * const projectMediaWithIdOnly = await prisma.projectMedia.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectMediaCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectMediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMediaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectMedia.
     * @param {ProjectMediaDeleteArgs} args - Arguments to delete one ProjectMedia.
     * @example
     * // Delete one ProjectMedia
     * const ProjectMedia = await prisma.projectMedia.delete({
     *   where: {
     *     // ... filter to delete one ProjectMedia
     *   }
     * })
     * 
     */
    delete<T extends ProjectMediaDeleteArgs>(args: SelectSubset<T, ProjectMediaDeleteArgs<ExtArgs>>): Prisma__ProjectMediaClient<$Result.GetResult<Prisma.$ProjectMediaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectMedia.
     * @param {ProjectMediaUpdateArgs} args - Arguments to update one ProjectMedia.
     * @example
     * // Update one ProjectMedia
     * const projectMedia = await prisma.projectMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectMediaUpdateArgs>(args: SelectSubset<T, ProjectMediaUpdateArgs<ExtArgs>>): Prisma__ProjectMediaClient<$Result.GetResult<Prisma.$ProjectMediaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectMedias.
     * @param {ProjectMediaDeleteManyArgs} args - Arguments to filter ProjectMedias to delete.
     * @example
     * // Delete a few ProjectMedias
     * const { count } = await prisma.projectMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectMediaDeleteManyArgs>(args?: SelectSubset<T, ProjectMediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectMedias
     * const projectMedia = await prisma.projectMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectMediaUpdateManyArgs>(args: SelectSubset<T, ProjectMediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectMedia.
     * @param {ProjectMediaUpsertArgs} args - Arguments to update or create a ProjectMedia.
     * @example
     * // Update or create a ProjectMedia
     * const projectMedia = await prisma.projectMedia.upsert({
     *   create: {
     *     // ... data to create a ProjectMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectMedia we want to update
     *   }
     * })
     */
    upsert<T extends ProjectMediaUpsertArgs>(args: SelectSubset<T, ProjectMediaUpsertArgs<ExtArgs>>): Prisma__ProjectMediaClient<$Result.GetResult<Prisma.$ProjectMediaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMediaCountArgs} args - Arguments to filter ProjectMedias to count.
     * @example
     * // Count the number of ProjectMedias
     * const count = await prisma.projectMedia.count({
     *   where: {
     *     // ... the filter for the ProjectMedias we want to count
     *   }
     * })
    **/
    count<T extends ProjectMediaCountArgs>(
      args?: Subset<T, ProjectMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectMediaAggregateArgs>(args: Subset<T, ProjectMediaAggregateArgs>): Prisma.PrismaPromise<GetProjectMediaAggregateType<T>>

    /**
     * Group by ProjectMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectMediaGroupByArgs['orderBy'] }
        : { orderBy?: ProjectMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectMedia model
   */
  readonly fields: ProjectMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectMedia model
   */ 
  interface ProjectMediaFieldRefs {
    readonly id: FieldRef<"ProjectMedia", 'String'>
    readonly projectId: FieldRef<"ProjectMedia", 'String'>
    readonly type: FieldRef<"ProjectMedia", 'MediaType'>
    readonly url: FieldRef<"ProjectMedia", 'String'>
    readonly thumbnail: FieldRef<"ProjectMedia", 'String'>
    readonly caption: FieldRef<"ProjectMedia", 'String'>
    readonly displayOrder: FieldRef<"ProjectMedia", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProjectMedia findUnique
   */
  export type ProjectMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMedia
     */
    select?: ProjectMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMediaInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMedia to fetch.
     */
    where: ProjectMediaWhereUniqueInput
  }

  /**
   * ProjectMedia findUniqueOrThrow
   */
  export type ProjectMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMedia
     */
    select?: ProjectMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMediaInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMedia to fetch.
     */
    where: ProjectMediaWhereUniqueInput
  }

  /**
   * ProjectMedia findFirst
   */
  export type ProjectMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMedia
     */
    select?: ProjectMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMediaInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMedia to fetch.
     */
    where?: ProjectMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMedias to fetch.
     */
    orderBy?: ProjectMediaOrderByWithRelationInput | ProjectMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMedias.
     */
    cursor?: ProjectMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMedias.
     */
    distinct?: ProjectMediaScalarFieldEnum | ProjectMediaScalarFieldEnum[]
  }

  /**
   * ProjectMedia findFirstOrThrow
   */
  export type ProjectMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMedia
     */
    select?: ProjectMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMediaInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMedia to fetch.
     */
    where?: ProjectMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMedias to fetch.
     */
    orderBy?: ProjectMediaOrderByWithRelationInput | ProjectMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMedias.
     */
    cursor?: ProjectMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMedias.
     */
    distinct?: ProjectMediaScalarFieldEnum | ProjectMediaScalarFieldEnum[]
  }

  /**
   * ProjectMedia findMany
   */
  export type ProjectMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMedia
     */
    select?: ProjectMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMediaInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMedias to fetch.
     */
    where?: ProjectMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMedias to fetch.
     */
    orderBy?: ProjectMediaOrderByWithRelationInput | ProjectMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectMedias.
     */
    cursor?: ProjectMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMedias.
     */
    skip?: number
    distinct?: ProjectMediaScalarFieldEnum | ProjectMediaScalarFieldEnum[]
  }

  /**
   * ProjectMedia create
   */
  export type ProjectMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMedia
     */
    select?: ProjectMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMediaInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectMedia.
     */
    data: XOR<ProjectMediaCreateInput, ProjectMediaUncheckedCreateInput>
  }

  /**
   * ProjectMedia createMany
   */
  export type ProjectMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectMedias.
     */
    data: ProjectMediaCreateManyInput | ProjectMediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectMedia createManyAndReturn
   */
  export type ProjectMediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMedia
     */
    select?: ProjectMediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectMedias.
     */
    data: ProjectMediaCreateManyInput | ProjectMediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMedia update
   */
  export type ProjectMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMedia
     */
    select?: ProjectMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMediaInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectMedia.
     */
    data: XOR<ProjectMediaUpdateInput, ProjectMediaUncheckedUpdateInput>
    /**
     * Choose, which ProjectMedia to update.
     */
    where: ProjectMediaWhereUniqueInput
  }

  /**
   * ProjectMedia updateMany
   */
  export type ProjectMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectMedias.
     */
    data: XOR<ProjectMediaUpdateManyMutationInput, ProjectMediaUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMedias to update
     */
    where?: ProjectMediaWhereInput
  }

  /**
   * ProjectMedia upsert
   */
  export type ProjectMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMedia
     */
    select?: ProjectMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMediaInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectMedia to update in case it exists.
     */
    where: ProjectMediaWhereUniqueInput
    /**
     * In case the ProjectMedia found by the `where` argument doesn't exist, create a new ProjectMedia with this data.
     */
    create: XOR<ProjectMediaCreateInput, ProjectMediaUncheckedCreateInput>
    /**
     * In case the ProjectMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectMediaUpdateInput, ProjectMediaUncheckedUpdateInput>
  }

  /**
   * ProjectMedia delete
   */
  export type ProjectMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMedia
     */
    select?: ProjectMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMediaInclude<ExtArgs> | null
    /**
     * Filter which ProjectMedia to delete.
     */
    where: ProjectMediaWhereUniqueInput
  }

  /**
   * ProjectMedia deleteMany
   */
  export type ProjectMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMedias to delete
     */
    where?: ProjectMediaWhereInput
  }

  /**
   * ProjectMedia without action
   */
  export type ProjectMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMedia
     */
    select?: ProjectMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMediaInclude<ExtArgs> | null
  }


  /**
   * Model ProjectSkill
   */

  export type AggregateProjectSkill = {
    _count: ProjectSkillCountAggregateOutputType | null
    _min: ProjectSkillMinAggregateOutputType | null
    _max: ProjectSkillMaxAggregateOutputType | null
  }

  export type ProjectSkillMinAggregateOutputType = {
    projectId: string | null
    skillId: string | null
  }

  export type ProjectSkillMaxAggregateOutputType = {
    projectId: string | null
    skillId: string | null
  }

  export type ProjectSkillCountAggregateOutputType = {
    projectId: number
    skillId: number
    _all: number
  }


  export type ProjectSkillMinAggregateInputType = {
    projectId?: true
    skillId?: true
  }

  export type ProjectSkillMaxAggregateInputType = {
    projectId?: true
    skillId?: true
  }

  export type ProjectSkillCountAggregateInputType = {
    projectId?: true
    skillId?: true
    _all?: true
  }

  export type ProjectSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectSkill to aggregate.
     */
    where?: ProjectSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSkills to fetch.
     */
    orderBy?: ProjectSkillOrderByWithRelationInput | ProjectSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectSkills
    **/
    _count?: true | ProjectSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectSkillMaxAggregateInputType
  }

  export type GetProjectSkillAggregateType<T extends ProjectSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectSkill[P]>
      : GetScalarType<T[P], AggregateProjectSkill[P]>
  }




  export type ProjectSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectSkillWhereInput
    orderBy?: ProjectSkillOrderByWithAggregationInput | ProjectSkillOrderByWithAggregationInput[]
    by: ProjectSkillScalarFieldEnum[] | ProjectSkillScalarFieldEnum
    having?: ProjectSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectSkillCountAggregateInputType | true
    _min?: ProjectSkillMinAggregateInputType
    _max?: ProjectSkillMaxAggregateInputType
  }

  export type ProjectSkillGroupByOutputType = {
    projectId: string
    skillId: string
    _count: ProjectSkillCountAggregateOutputType | null
    _min: ProjectSkillMinAggregateOutputType | null
    _max: ProjectSkillMaxAggregateOutputType | null
  }

  type GetProjectSkillGroupByPayload<T extends ProjectSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectSkillGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectSkillGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectId?: boolean
    skillId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectSkill"]>

  export type ProjectSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectId?: boolean
    skillId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectSkill"]>

  export type ProjectSkillSelectScalar = {
    projectId?: boolean
    skillId?: boolean
  }

  export type ProjectSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type ProjectSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }

  export type $ProjectSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectSkill"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      projectId: string
      skillId: string
    }, ExtArgs["result"]["projectSkill"]>
    composites: {}
  }

  type ProjectSkillGetPayload<S extends boolean | null | undefined | ProjectSkillDefaultArgs> = $Result.GetResult<Prisma.$ProjectSkillPayload, S>

  type ProjectSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectSkillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectSkillCountAggregateInputType | true
    }

  export interface ProjectSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectSkill'], meta: { name: 'ProjectSkill' } }
    /**
     * Find zero or one ProjectSkill that matches the filter.
     * @param {ProjectSkillFindUniqueArgs} args - Arguments to find a ProjectSkill
     * @example
     * // Get one ProjectSkill
     * const projectSkill = await prisma.projectSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectSkillFindUniqueArgs>(args: SelectSubset<T, ProjectSkillFindUniqueArgs<ExtArgs>>): Prisma__ProjectSkillClient<$Result.GetResult<Prisma.$ProjectSkillPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectSkill that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectSkillFindUniqueOrThrowArgs} args - Arguments to find a ProjectSkill
     * @example
     * // Get one ProjectSkill
     * const projectSkill = await prisma.projectSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectSkillClient<$Result.GetResult<Prisma.$ProjectSkillPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSkillFindFirstArgs} args - Arguments to find a ProjectSkill
     * @example
     * // Get one ProjectSkill
     * const projectSkill = await prisma.projectSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectSkillFindFirstArgs>(args?: SelectSubset<T, ProjectSkillFindFirstArgs<ExtArgs>>): Prisma__ProjectSkillClient<$Result.GetResult<Prisma.$ProjectSkillPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSkillFindFirstOrThrowArgs} args - Arguments to find a ProjectSkill
     * @example
     * // Get one ProjectSkill
     * const projectSkill = await prisma.projectSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectSkillClient<$Result.GetResult<Prisma.$ProjectSkillPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectSkills
     * const projectSkills = await prisma.projectSkill.findMany()
     * 
     * // Get first 10 ProjectSkills
     * const projectSkills = await prisma.projectSkill.findMany({ take: 10 })
     * 
     * // Only select the `projectId`
     * const projectSkillWithProjectIdOnly = await prisma.projectSkill.findMany({ select: { projectId: true } })
     * 
     */
    findMany<T extends ProjectSkillFindManyArgs>(args?: SelectSubset<T, ProjectSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSkillPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectSkill.
     * @param {ProjectSkillCreateArgs} args - Arguments to create a ProjectSkill.
     * @example
     * // Create one ProjectSkill
     * const ProjectSkill = await prisma.projectSkill.create({
     *   data: {
     *     // ... data to create a ProjectSkill
     *   }
     * })
     * 
     */
    create<T extends ProjectSkillCreateArgs>(args: SelectSubset<T, ProjectSkillCreateArgs<ExtArgs>>): Prisma__ProjectSkillClient<$Result.GetResult<Prisma.$ProjectSkillPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectSkills.
     * @param {ProjectSkillCreateManyArgs} args - Arguments to create many ProjectSkills.
     * @example
     * // Create many ProjectSkills
     * const projectSkill = await prisma.projectSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectSkillCreateManyArgs>(args?: SelectSubset<T, ProjectSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectSkills and returns the data saved in the database.
     * @param {ProjectSkillCreateManyAndReturnArgs} args - Arguments to create many ProjectSkills.
     * @example
     * // Create many ProjectSkills
     * const projectSkill = await prisma.projectSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectSkills and only return the `projectId`
     * const projectSkillWithProjectIdOnly = await prisma.projectSkill.createManyAndReturn({ 
     *   select: { projectId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSkillPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectSkill.
     * @param {ProjectSkillDeleteArgs} args - Arguments to delete one ProjectSkill.
     * @example
     * // Delete one ProjectSkill
     * const ProjectSkill = await prisma.projectSkill.delete({
     *   where: {
     *     // ... filter to delete one ProjectSkill
     *   }
     * })
     * 
     */
    delete<T extends ProjectSkillDeleteArgs>(args: SelectSubset<T, ProjectSkillDeleteArgs<ExtArgs>>): Prisma__ProjectSkillClient<$Result.GetResult<Prisma.$ProjectSkillPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectSkill.
     * @param {ProjectSkillUpdateArgs} args - Arguments to update one ProjectSkill.
     * @example
     * // Update one ProjectSkill
     * const projectSkill = await prisma.projectSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectSkillUpdateArgs>(args: SelectSubset<T, ProjectSkillUpdateArgs<ExtArgs>>): Prisma__ProjectSkillClient<$Result.GetResult<Prisma.$ProjectSkillPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectSkills.
     * @param {ProjectSkillDeleteManyArgs} args - Arguments to filter ProjectSkills to delete.
     * @example
     * // Delete a few ProjectSkills
     * const { count } = await prisma.projectSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectSkillDeleteManyArgs>(args?: SelectSubset<T, ProjectSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectSkills
     * const projectSkill = await prisma.projectSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectSkillUpdateManyArgs>(args: SelectSubset<T, ProjectSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectSkill.
     * @param {ProjectSkillUpsertArgs} args - Arguments to update or create a ProjectSkill.
     * @example
     * // Update or create a ProjectSkill
     * const projectSkill = await prisma.projectSkill.upsert({
     *   create: {
     *     // ... data to create a ProjectSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectSkill we want to update
     *   }
     * })
     */
    upsert<T extends ProjectSkillUpsertArgs>(args: SelectSubset<T, ProjectSkillUpsertArgs<ExtArgs>>): Prisma__ProjectSkillClient<$Result.GetResult<Prisma.$ProjectSkillPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSkillCountArgs} args - Arguments to filter ProjectSkills to count.
     * @example
     * // Count the number of ProjectSkills
     * const count = await prisma.projectSkill.count({
     *   where: {
     *     // ... the filter for the ProjectSkills we want to count
     *   }
     * })
    **/
    count<T extends ProjectSkillCountArgs>(
      args?: Subset<T, ProjectSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectSkillAggregateArgs>(args: Subset<T, ProjectSkillAggregateArgs>): Prisma.PrismaPromise<GetProjectSkillAggregateType<T>>

    /**
     * Group by ProjectSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectSkillGroupByArgs['orderBy'] }
        : { orderBy?: ProjectSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectSkill model
   */
  readonly fields: ProjectSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectSkill model
   */ 
  interface ProjectSkillFieldRefs {
    readonly projectId: FieldRef<"ProjectSkill", 'String'>
    readonly skillId: FieldRef<"ProjectSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProjectSkill findUnique
   */
  export type ProjectSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSkill to fetch.
     */
    where: ProjectSkillWhereUniqueInput
  }

  /**
   * ProjectSkill findUniqueOrThrow
   */
  export type ProjectSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSkill to fetch.
     */
    where: ProjectSkillWhereUniqueInput
  }

  /**
   * ProjectSkill findFirst
   */
  export type ProjectSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSkill to fetch.
     */
    where?: ProjectSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSkills to fetch.
     */
    orderBy?: ProjectSkillOrderByWithRelationInput | ProjectSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectSkills.
     */
    cursor?: ProjectSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectSkills.
     */
    distinct?: ProjectSkillScalarFieldEnum | ProjectSkillScalarFieldEnum[]
  }

  /**
   * ProjectSkill findFirstOrThrow
   */
  export type ProjectSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSkill to fetch.
     */
    where?: ProjectSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSkills to fetch.
     */
    orderBy?: ProjectSkillOrderByWithRelationInput | ProjectSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectSkills.
     */
    cursor?: ProjectSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectSkills.
     */
    distinct?: ProjectSkillScalarFieldEnum | ProjectSkillScalarFieldEnum[]
  }

  /**
   * ProjectSkill findMany
   */
  export type ProjectSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSkills to fetch.
     */
    where?: ProjectSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSkills to fetch.
     */
    orderBy?: ProjectSkillOrderByWithRelationInput | ProjectSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectSkills.
     */
    cursor?: ProjectSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSkills.
     */
    skip?: number
    distinct?: ProjectSkillScalarFieldEnum | ProjectSkillScalarFieldEnum[]
  }

  /**
   * ProjectSkill create
   */
  export type ProjectSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectSkill.
     */
    data: XOR<ProjectSkillCreateInput, ProjectSkillUncheckedCreateInput>
  }

  /**
   * ProjectSkill createMany
   */
  export type ProjectSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectSkills.
     */
    data: ProjectSkillCreateManyInput | ProjectSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectSkill createManyAndReturn
   */
  export type ProjectSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectSkills.
     */
    data: ProjectSkillCreateManyInput | ProjectSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectSkill update
   */
  export type ProjectSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectSkill.
     */
    data: XOR<ProjectSkillUpdateInput, ProjectSkillUncheckedUpdateInput>
    /**
     * Choose, which ProjectSkill to update.
     */
    where: ProjectSkillWhereUniqueInput
  }

  /**
   * ProjectSkill updateMany
   */
  export type ProjectSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectSkills.
     */
    data: XOR<ProjectSkillUpdateManyMutationInput, ProjectSkillUncheckedUpdateManyInput>
    /**
     * Filter which ProjectSkills to update
     */
    where?: ProjectSkillWhereInput
  }

  /**
   * ProjectSkill upsert
   */
  export type ProjectSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectSkill to update in case it exists.
     */
    where: ProjectSkillWhereUniqueInput
    /**
     * In case the ProjectSkill found by the `where` argument doesn't exist, create a new ProjectSkill with this data.
     */
    create: XOR<ProjectSkillCreateInput, ProjectSkillUncheckedCreateInput>
    /**
     * In case the ProjectSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectSkillUpdateInput, ProjectSkillUncheckedUpdateInput>
  }

  /**
   * ProjectSkill delete
   */
  export type ProjectSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillInclude<ExtArgs> | null
    /**
     * Filter which ProjectSkill to delete.
     */
    where: ProjectSkillWhereUniqueInput
  }

  /**
   * ProjectSkill deleteMany
   */
  export type ProjectSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectSkills to delete
     */
    where?: ProjectSkillWhereInput
  }

  /**
   * ProjectSkill without action
   */
  export type ProjectSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillInclude<ExtArgs> | null
  }


  /**
   * Model ProjectCollaborator
   */

  export type AggregateProjectCollaborator = {
    _count: ProjectCollaboratorCountAggregateOutputType | null
    _min: ProjectCollaboratorMinAggregateOutputType | null
    _max: ProjectCollaboratorMaxAggregateOutputType | null
  }

  export type ProjectCollaboratorMinAggregateOutputType = {
    projectId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
  }

  export type ProjectCollaboratorMaxAggregateOutputType = {
    projectId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
  }

  export type ProjectCollaboratorCountAggregateOutputType = {
    projectId: number
    userId: number
    role: number
    joinedAt: number
    _all: number
  }


  export type ProjectCollaboratorMinAggregateInputType = {
    projectId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type ProjectCollaboratorMaxAggregateInputType = {
    projectId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type ProjectCollaboratorCountAggregateInputType = {
    projectId?: true
    userId?: true
    role?: true
    joinedAt?: true
    _all?: true
  }

  export type ProjectCollaboratorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectCollaborator to aggregate.
     */
    where?: ProjectCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectCollaborators to fetch.
     */
    orderBy?: ProjectCollaboratorOrderByWithRelationInput | ProjectCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectCollaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectCollaborators
    **/
    _count?: true | ProjectCollaboratorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectCollaboratorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectCollaboratorMaxAggregateInputType
  }

  export type GetProjectCollaboratorAggregateType<T extends ProjectCollaboratorAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectCollaborator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectCollaborator[P]>
      : GetScalarType<T[P], AggregateProjectCollaborator[P]>
  }




  export type ProjectCollaboratorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectCollaboratorWhereInput
    orderBy?: ProjectCollaboratorOrderByWithAggregationInput | ProjectCollaboratorOrderByWithAggregationInput[]
    by: ProjectCollaboratorScalarFieldEnum[] | ProjectCollaboratorScalarFieldEnum
    having?: ProjectCollaboratorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCollaboratorCountAggregateInputType | true
    _min?: ProjectCollaboratorMinAggregateInputType
    _max?: ProjectCollaboratorMaxAggregateInputType
  }

  export type ProjectCollaboratorGroupByOutputType = {
    projectId: string
    userId: string
    role: string | null
    joinedAt: Date
    _count: ProjectCollaboratorCountAggregateOutputType | null
    _min: ProjectCollaboratorMinAggregateOutputType | null
    _max: ProjectCollaboratorMaxAggregateOutputType | null
  }

  type GetProjectCollaboratorGroupByPayload<T extends ProjectCollaboratorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectCollaboratorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectCollaboratorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectCollaboratorGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectCollaboratorGroupByOutputType[P]>
        }
      >
    >


  export type ProjectCollaboratorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectCollaborator"]>

  export type ProjectCollaboratorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectCollaborator"]>

  export type ProjectCollaboratorSelectScalar = {
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
  }

  export type ProjectCollaboratorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectCollaboratorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectCollaboratorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectCollaborator"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      projectId: string
      userId: string
      role: string | null
      joinedAt: Date
    }, ExtArgs["result"]["projectCollaborator"]>
    composites: {}
  }

  type ProjectCollaboratorGetPayload<S extends boolean | null | undefined | ProjectCollaboratorDefaultArgs> = $Result.GetResult<Prisma.$ProjectCollaboratorPayload, S>

  type ProjectCollaboratorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectCollaboratorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCollaboratorCountAggregateInputType | true
    }

  export interface ProjectCollaboratorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectCollaborator'], meta: { name: 'ProjectCollaborator' } }
    /**
     * Find zero or one ProjectCollaborator that matches the filter.
     * @param {ProjectCollaboratorFindUniqueArgs} args - Arguments to find a ProjectCollaborator
     * @example
     * // Get one ProjectCollaborator
     * const projectCollaborator = await prisma.projectCollaborator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectCollaboratorFindUniqueArgs>(args: SelectSubset<T, ProjectCollaboratorFindUniqueArgs<ExtArgs>>): Prisma__ProjectCollaboratorClient<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectCollaborator that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectCollaboratorFindUniqueOrThrowArgs} args - Arguments to find a ProjectCollaborator
     * @example
     * // Get one ProjectCollaborator
     * const projectCollaborator = await prisma.projectCollaborator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectCollaboratorFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectCollaboratorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectCollaboratorClient<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectCollaborator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCollaboratorFindFirstArgs} args - Arguments to find a ProjectCollaborator
     * @example
     * // Get one ProjectCollaborator
     * const projectCollaborator = await prisma.projectCollaborator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectCollaboratorFindFirstArgs>(args?: SelectSubset<T, ProjectCollaboratorFindFirstArgs<ExtArgs>>): Prisma__ProjectCollaboratorClient<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectCollaborator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCollaboratorFindFirstOrThrowArgs} args - Arguments to find a ProjectCollaborator
     * @example
     * // Get one ProjectCollaborator
     * const projectCollaborator = await prisma.projectCollaborator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectCollaboratorFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectCollaboratorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectCollaboratorClient<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectCollaborators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCollaboratorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectCollaborators
     * const projectCollaborators = await prisma.projectCollaborator.findMany()
     * 
     * // Get first 10 ProjectCollaborators
     * const projectCollaborators = await prisma.projectCollaborator.findMany({ take: 10 })
     * 
     * // Only select the `projectId`
     * const projectCollaboratorWithProjectIdOnly = await prisma.projectCollaborator.findMany({ select: { projectId: true } })
     * 
     */
    findMany<T extends ProjectCollaboratorFindManyArgs>(args?: SelectSubset<T, ProjectCollaboratorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectCollaborator.
     * @param {ProjectCollaboratorCreateArgs} args - Arguments to create a ProjectCollaborator.
     * @example
     * // Create one ProjectCollaborator
     * const ProjectCollaborator = await prisma.projectCollaborator.create({
     *   data: {
     *     // ... data to create a ProjectCollaborator
     *   }
     * })
     * 
     */
    create<T extends ProjectCollaboratorCreateArgs>(args: SelectSubset<T, ProjectCollaboratorCreateArgs<ExtArgs>>): Prisma__ProjectCollaboratorClient<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectCollaborators.
     * @param {ProjectCollaboratorCreateManyArgs} args - Arguments to create many ProjectCollaborators.
     * @example
     * // Create many ProjectCollaborators
     * const projectCollaborator = await prisma.projectCollaborator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCollaboratorCreateManyArgs>(args?: SelectSubset<T, ProjectCollaboratorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectCollaborators and returns the data saved in the database.
     * @param {ProjectCollaboratorCreateManyAndReturnArgs} args - Arguments to create many ProjectCollaborators.
     * @example
     * // Create many ProjectCollaborators
     * const projectCollaborator = await prisma.projectCollaborator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectCollaborators and only return the `projectId`
     * const projectCollaboratorWithProjectIdOnly = await prisma.projectCollaborator.createManyAndReturn({ 
     *   select: { projectId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCollaboratorCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCollaboratorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectCollaborator.
     * @param {ProjectCollaboratorDeleteArgs} args - Arguments to delete one ProjectCollaborator.
     * @example
     * // Delete one ProjectCollaborator
     * const ProjectCollaborator = await prisma.projectCollaborator.delete({
     *   where: {
     *     // ... filter to delete one ProjectCollaborator
     *   }
     * })
     * 
     */
    delete<T extends ProjectCollaboratorDeleteArgs>(args: SelectSubset<T, ProjectCollaboratorDeleteArgs<ExtArgs>>): Prisma__ProjectCollaboratorClient<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectCollaborator.
     * @param {ProjectCollaboratorUpdateArgs} args - Arguments to update one ProjectCollaborator.
     * @example
     * // Update one ProjectCollaborator
     * const projectCollaborator = await prisma.projectCollaborator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectCollaboratorUpdateArgs>(args: SelectSubset<T, ProjectCollaboratorUpdateArgs<ExtArgs>>): Prisma__ProjectCollaboratorClient<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectCollaborators.
     * @param {ProjectCollaboratorDeleteManyArgs} args - Arguments to filter ProjectCollaborators to delete.
     * @example
     * // Delete a few ProjectCollaborators
     * const { count } = await prisma.projectCollaborator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectCollaboratorDeleteManyArgs>(args?: SelectSubset<T, ProjectCollaboratorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectCollaborators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCollaboratorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectCollaborators
     * const projectCollaborator = await prisma.projectCollaborator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectCollaboratorUpdateManyArgs>(args: SelectSubset<T, ProjectCollaboratorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectCollaborator.
     * @param {ProjectCollaboratorUpsertArgs} args - Arguments to update or create a ProjectCollaborator.
     * @example
     * // Update or create a ProjectCollaborator
     * const projectCollaborator = await prisma.projectCollaborator.upsert({
     *   create: {
     *     // ... data to create a ProjectCollaborator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectCollaborator we want to update
     *   }
     * })
     */
    upsert<T extends ProjectCollaboratorUpsertArgs>(args: SelectSubset<T, ProjectCollaboratorUpsertArgs<ExtArgs>>): Prisma__ProjectCollaboratorClient<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectCollaborators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCollaboratorCountArgs} args - Arguments to filter ProjectCollaborators to count.
     * @example
     * // Count the number of ProjectCollaborators
     * const count = await prisma.projectCollaborator.count({
     *   where: {
     *     // ... the filter for the ProjectCollaborators we want to count
     *   }
     * })
    **/
    count<T extends ProjectCollaboratorCountArgs>(
      args?: Subset<T, ProjectCollaboratorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCollaboratorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectCollaborator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCollaboratorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectCollaboratorAggregateArgs>(args: Subset<T, ProjectCollaboratorAggregateArgs>): Prisma.PrismaPromise<GetProjectCollaboratorAggregateType<T>>

    /**
     * Group by ProjectCollaborator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCollaboratorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectCollaboratorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectCollaboratorGroupByArgs['orderBy'] }
        : { orderBy?: ProjectCollaboratorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectCollaboratorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectCollaboratorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectCollaborator model
   */
  readonly fields: ProjectCollaboratorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectCollaborator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectCollaboratorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectCollaborator model
   */ 
  interface ProjectCollaboratorFieldRefs {
    readonly projectId: FieldRef<"ProjectCollaborator", 'String'>
    readonly userId: FieldRef<"ProjectCollaborator", 'String'>
    readonly role: FieldRef<"ProjectCollaborator", 'String'>
    readonly joinedAt: FieldRef<"ProjectCollaborator", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectCollaborator findUnique
   */
  export type ProjectCollaboratorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ProjectCollaborator to fetch.
     */
    where: ProjectCollaboratorWhereUniqueInput
  }

  /**
   * ProjectCollaborator findUniqueOrThrow
   */
  export type ProjectCollaboratorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ProjectCollaborator to fetch.
     */
    where: ProjectCollaboratorWhereUniqueInput
  }

  /**
   * ProjectCollaborator findFirst
   */
  export type ProjectCollaboratorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ProjectCollaborator to fetch.
     */
    where?: ProjectCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectCollaborators to fetch.
     */
    orderBy?: ProjectCollaboratorOrderByWithRelationInput | ProjectCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectCollaborators.
     */
    cursor?: ProjectCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectCollaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectCollaborators.
     */
    distinct?: ProjectCollaboratorScalarFieldEnum | ProjectCollaboratorScalarFieldEnum[]
  }

  /**
   * ProjectCollaborator findFirstOrThrow
   */
  export type ProjectCollaboratorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ProjectCollaborator to fetch.
     */
    where?: ProjectCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectCollaborators to fetch.
     */
    orderBy?: ProjectCollaboratorOrderByWithRelationInput | ProjectCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectCollaborators.
     */
    cursor?: ProjectCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectCollaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectCollaborators.
     */
    distinct?: ProjectCollaboratorScalarFieldEnum | ProjectCollaboratorScalarFieldEnum[]
  }

  /**
   * ProjectCollaborator findMany
   */
  export type ProjectCollaboratorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ProjectCollaborators to fetch.
     */
    where?: ProjectCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectCollaborators to fetch.
     */
    orderBy?: ProjectCollaboratorOrderByWithRelationInput | ProjectCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectCollaborators.
     */
    cursor?: ProjectCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectCollaborators.
     */
    skip?: number
    distinct?: ProjectCollaboratorScalarFieldEnum | ProjectCollaboratorScalarFieldEnum[]
  }

  /**
   * ProjectCollaborator create
   */
  export type ProjectCollaboratorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectCollaborator.
     */
    data: XOR<ProjectCollaboratorCreateInput, ProjectCollaboratorUncheckedCreateInput>
  }

  /**
   * ProjectCollaborator createMany
   */
  export type ProjectCollaboratorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectCollaborators.
     */
    data: ProjectCollaboratorCreateManyInput | ProjectCollaboratorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectCollaborator createManyAndReturn
   */
  export type ProjectCollaboratorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectCollaborators.
     */
    data: ProjectCollaboratorCreateManyInput | ProjectCollaboratorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectCollaborator update
   */
  export type ProjectCollaboratorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectCollaborator.
     */
    data: XOR<ProjectCollaboratorUpdateInput, ProjectCollaboratorUncheckedUpdateInput>
    /**
     * Choose, which ProjectCollaborator to update.
     */
    where: ProjectCollaboratorWhereUniqueInput
  }

  /**
   * ProjectCollaborator updateMany
   */
  export type ProjectCollaboratorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectCollaborators.
     */
    data: XOR<ProjectCollaboratorUpdateManyMutationInput, ProjectCollaboratorUncheckedUpdateManyInput>
    /**
     * Filter which ProjectCollaborators to update
     */
    where?: ProjectCollaboratorWhereInput
  }

  /**
   * ProjectCollaborator upsert
   */
  export type ProjectCollaboratorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectCollaborator to update in case it exists.
     */
    where: ProjectCollaboratorWhereUniqueInput
    /**
     * In case the ProjectCollaborator found by the `where` argument doesn't exist, create a new ProjectCollaborator with this data.
     */
    create: XOR<ProjectCollaboratorCreateInput, ProjectCollaboratorUncheckedCreateInput>
    /**
     * In case the ProjectCollaborator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectCollaboratorUpdateInput, ProjectCollaboratorUncheckedUpdateInput>
  }

  /**
   * ProjectCollaborator delete
   */
  export type ProjectCollaboratorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * Filter which ProjectCollaborator to delete.
     */
    where: ProjectCollaboratorWhereUniqueInput
  }

  /**
   * ProjectCollaborator deleteMany
   */
  export type ProjectCollaboratorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectCollaborators to delete
     */
    where?: ProjectCollaboratorWhereInput
  }

  /**
   * ProjectCollaborator without action
   */
  export type ProjectCollaboratorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
  }


  /**
   * Model Endorsement
   */

  export type AggregateEndorsement = {
    _count: EndorsementCountAggregateOutputType | null
    _min: EndorsementMinAggregateOutputType | null
    _max: EndorsementMaxAggregateOutputType | null
  }

  export type EndorsementMinAggregateOutputType = {
    id: string | null
    endorserId: string | null
    comment: string | null
    createdAt: Date | null
    projectId: string | null
  }

  export type EndorsementMaxAggregateOutputType = {
    id: string | null
    endorserId: string | null
    comment: string | null
    createdAt: Date | null
    projectId: string | null
  }

  export type EndorsementCountAggregateOutputType = {
    id: number
    endorserId: number
    comment: number
    createdAt: number
    projectId: number
    _all: number
  }


  export type EndorsementMinAggregateInputType = {
    id?: true
    endorserId?: true
    comment?: true
    createdAt?: true
    projectId?: true
  }

  export type EndorsementMaxAggregateInputType = {
    id?: true
    endorserId?: true
    comment?: true
    createdAt?: true
    projectId?: true
  }

  export type EndorsementCountAggregateInputType = {
    id?: true
    endorserId?: true
    comment?: true
    createdAt?: true
    projectId?: true
    _all?: true
  }

  export type EndorsementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Endorsement to aggregate.
     */
    where?: EndorsementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Endorsements to fetch.
     */
    orderBy?: EndorsementOrderByWithRelationInput | EndorsementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EndorsementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Endorsements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Endorsements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Endorsements
    **/
    _count?: true | EndorsementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EndorsementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EndorsementMaxAggregateInputType
  }

  export type GetEndorsementAggregateType<T extends EndorsementAggregateArgs> = {
        [P in keyof T & keyof AggregateEndorsement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEndorsement[P]>
      : GetScalarType<T[P], AggregateEndorsement[P]>
  }




  export type EndorsementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EndorsementWhereInput
    orderBy?: EndorsementOrderByWithAggregationInput | EndorsementOrderByWithAggregationInput[]
    by: EndorsementScalarFieldEnum[] | EndorsementScalarFieldEnum
    having?: EndorsementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EndorsementCountAggregateInputType | true
    _min?: EndorsementMinAggregateInputType
    _max?: EndorsementMaxAggregateInputType
  }

  export type EndorsementGroupByOutputType = {
    id: string
    endorserId: string
    comment: string | null
    createdAt: Date
    projectId: string | null
    _count: EndorsementCountAggregateOutputType | null
    _min: EndorsementMinAggregateOutputType | null
    _max: EndorsementMaxAggregateOutputType | null
  }

  type GetEndorsementGroupByPayload<T extends EndorsementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EndorsementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EndorsementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EndorsementGroupByOutputType[P]>
            : GetScalarType<T[P], EndorsementGroupByOutputType[P]>
        }
      >
    >


  export type EndorsementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    endorserId?: boolean
    comment?: boolean
    createdAt?: boolean
    projectId?: boolean
    endorser?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Endorsement$projectArgs<ExtArgs>
  }, ExtArgs["result"]["endorsement"]>

  export type EndorsementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    endorserId?: boolean
    comment?: boolean
    createdAt?: boolean
    projectId?: boolean
    endorser?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Endorsement$projectArgs<ExtArgs>
  }, ExtArgs["result"]["endorsement"]>

  export type EndorsementSelectScalar = {
    id?: boolean
    endorserId?: boolean
    comment?: boolean
    createdAt?: boolean
    projectId?: boolean
  }

  export type EndorsementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endorser?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Endorsement$projectArgs<ExtArgs>
  }
  export type EndorsementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endorser?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Endorsement$projectArgs<ExtArgs>
  }

  export type $EndorsementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Endorsement"
    objects: {
      endorser: Prisma.$UserPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      endorserId: string
      comment: string | null
      createdAt: Date
      projectId: string | null
    }, ExtArgs["result"]["endorsement"]>
    composites: {}
  }

  type EndorsementGetPayload<S extends boolean | null | undefined | EndorsementDefaultArgs> = $Result.GetResult<Prisma.$EndorsementPayload, S>

  type EndorsementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EndorsementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EndorsementCountAggregateInputType | true
    }

  export interface EndorsementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Endorsement'], meta: { name: 'Endorsement' } }
    /**
     * Find zero or one Endorsement that matches the filter.
     * @param {EndorsementFindUniqueArgs} args - Arguments to find a Endorsement
     * @example
     * // Get one Endorsement
     * const endorsement = await prisma.endorsement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EndorsementFindUniqueArgs>(args: SelectSubset<T, EndorsementFindUniqueArgs<ExtArgs>>): Prisma__EndorsementClient<$Result.GetResult<Prisma.$EndorsementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Endorsement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EndorsementFindUniqueOrThrowArgs} args - Arguments to find a Endorsement
     * @example
     * // Get one Endorsement
     * const endorsement = await prisma.endorsement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EndorsementFindUniqueOrThrowArgs>(args: SelectSubset<T, EndorsementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EndorsementClient<$Result.GetResult<Prisma.$EndorsementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Endorsement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndorsementFindFirstArgs} args - Arguments to find a Endorsement
     * @example
     * // Get one Endorsement
     * const endorsement = await prisma.endorsement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EndorsementFindFirstArgs>(args?: SelectSubset<T, EndorsementFindFirstArgs<ExtArgs>>): Prisma__EndorsementClient<$Result.GetResult<Prisma.$EndorsementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Endorsement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndorsementFindFirstOrThrowArgs} args - Arguments to find a Endorsement
     * @example
     * // Get one Endorsement
     * const endorsement = await prisma.endorsement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EndorsementFindFirstOrThrowArgs>(args?: SelectSubset<T, EndorsementFindFirstOrThrowArgs<ExtArgs>>): Prisma__EndorsementClient<$Result.GetResult<Prisma.$EndorsementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Endorsements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndorsementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Endorsements
     * const endorsements = await prisma.endorsement.findMany()
     * 
     * // Get first 10 Endorsements
     * const endorsements = await prisma.endorsement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const endorsementWithIdOnly = await prisma.endorsement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EndorsementFindManyArgs>(args?: SelectSubset<T, EndorsementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EndorsementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Endorsement.
     * @param {EndorsementCreateArgs} args - Arguments to create a Endorsement.
     * @example
     * // Create one Endorsement
     * const Endorsement = await prisma.endorsement.create({
     *   data: {
     *     // ... data to create a Endorsement
     *   }
     * })
     * 
     */
    create<T extends EndorsementCreateArgs>(args: SelectSubset<T, EndorsementCreateArgs<ExtArgs>>): Prisma__EndorsementClient<$Result.GetResult<Prisma.$EndorsementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Endorsements.
     * @param {EndorsementCreateManyArgs} args - Arguments to create many Endorsements.
     * @example
     * // Create many Endorsements
     * const endorsement = await prisma.endorsement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EndorsementCreateManyArgs>(args?: SelectSubset<T, EndorsementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Endorsements and returns the data saved in the database.
     * @param {EndorsementCreateManyAndReturnArgs} args - Arguments to create many Endorsements.
     * @example
     * // Create many Endorsements
     * const endorsement = await prisma.endorsement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Endorsements and only return the `id`
     * const endorsementWithIdOnly = await prisma.endorsement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EndorsementCreateManyAndReturnArgs>(args?: SelectSubset<T, EndorsementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EndorsementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Endorsement.
     * @param {EndorsementDeleteArgs} args - Arguments to delete one Endorsement.
     * @example
     * // Delete one Endorsement
     * const Endorsement = await prisma.endorsement.delete({
     *   where: {
     *     // ... filter to delete one Endorsement
     *   }
     * })
     * 
     */
    delete<T extends EndorsementDeleteArgs>(args: SelectSubset<T, EndorsementDeleteArgs<ExtArgs>>): Prisma__EndorsementClient<$Result.GetResult<Prisma.$EndorsementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Endorsement.
     * @param {EndorsementUpdateArgs} args - Arguments to update one Endorsement.
     * @example
     * // Update one Endorsement
     * const endorsement = await prisma.endorsement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EndorsementUpdateArgs>(args: SelectSubset<T, EndorsementUpdateArgs<ExtArgs>>): Prisma__EndorsementClient<$Result.GetResult<Prisma.$EndorsementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Endorsements.
     * @param {EndorsementDeleteManyArgs} args - Arguments to filter Endorsements to delete.
     * @example
     * // Delete a few Endorsements
     * const { count } = await prisma.endorsement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EndorsementDeleteManyArgs>(args?: SelectSubset<T, EndorsementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Endorsements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndorsementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Endorsements
     * const endorsement = await prisma.endorsement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EndorsementUpdateManyArgs>(args: SelectSubset<T, EndorsementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Endorsement.
     * @param {EndorsementUpsertArgs} args - Arguments to update or create a Endorsement.
     * @example
     * // Update or create a Endorsement
     * const endorsement = await prisma.endorsement.upsert({
     *   create: {
     *     // ... data to create a Endorsement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Endorsement we want to update
     *   }
     * })
     */
    upsert<T extends EndorsementUpsertArgs>(args: SelectSubset<T, EndorsementUpsertArgs<ExtArgs>>): Prisma__EndorsementClient<$Result.GetResult<Prisma.$EndorsementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Endorsements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndorsementCountArgs} args - Arguments to filter Endorsements to count.
     * @example
     * // Count the number of Endorsements
     * const count = await prisma.endorsement.count({
     *   where: {
     *     // ... the filter for the Endorsements we want to count
     *   }
     * })
    **/
    count<T extends EndorsementCountArgs>(
      args?: Subset<T, EndorsementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EndorsementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Endorsement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndorsementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EndorsementAggregateArgs>(args: Subset<T, EndorsementAggregateArgs>): Prisma.PrismaPromise<GetEndorsementAggregateType<T>>

    /**
     * Group by Endorsement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndorsementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EndorsementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EndorsementGroupByArgs['orderBy'] }
        : { orderBy?: EndorsementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EndorsementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEndorsementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Endorsement model
   */
  readonly fields: EndorsementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Endorsement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EndorsementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    endorser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends Endorsement$projectArgs<ExtArgs> = {}>(args?: Subset<T, Endorsement$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Endorsement model
   */ 
  interface EndorsementFieldRefs {
    readonly id: FieldRef<"Endorsement", 'String'>
    readonly endorserId: FieldRef<"Endorsement", 'String'>
    readonly comment: FieldRef<"Endorsement", 'String'>
    readonly createdAt: FieldRef<"Endorsement", 'DateTime'>
    readonly projectId: FieldRef<"Endorsement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Endorsement findUnique
   */
  export type EndorsementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endorsement
     */
    select?: EndorsementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndorsementInclude<ExtArgs> | null
    /**
     * Filter, which Endorsement to fetch.
     */
    where: EndorsementWhereUniqueInput
  }

  /**
   * Endorsement findUniqueOrThrow
   */
  export type EndorsementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endorsement
     */
    select?: EndorsementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndorsementInclude<ExtArgs> | null
    /**
     * Filter, which Endorsement to fetch.
     */
    where: EndorsementWhereUniqueInput
  }

  /**
   * Endorsement findFirst
   */
  export type EndorsementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endorsement
     */
    select?: EndorsementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndorsementInclude<ExtArgs> | null
    /**
     * Filter, which Endorsement to fetch.
     */
    where?: EndorsementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Endorsements to fetch.
     */
    orderBy?: EndorsementOrderByWithRelationInput | EndorsementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Endorsements.
     */
    cursor?: EndorsementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Endorsements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Endorsements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Endorsements.
     */
    distinct?: EndorsementScalarFieldEnum | EndorsementScalarFieldEnum[]
  }

  /**
   * Endorsement findFirstOrThrow
   */
  export type EndorsementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endorsement
     */
    select?: EndorsementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndorsementInclude<ExtArgs> | null
    /**
     * Filter, which Endorsement to fetch.
     */
    where?: EndorsementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Endorsements to fetch.
     */
    orderBy?: EndorsementOrderByWithRelationInput | EndorsementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Endorsements.
     */
    cursor?: EndorsementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Endorsements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Endorsements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Endorsements.
     */
    distinct?: EndorsementScalarFieldEnum | EndorsementScalarFieldEnum[]
  }

  /**
   * Endorsement findMany
   */
  export type EndorsementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endorsement
     */
    select?: EndorsementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndorsementInclude<ExtArgs> | null
    /**
     * Filter, which Endorsements to fetch.
     */
    where?: EndorsementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Endorsements to fetch.
     */
    orderBy?: EndorsementOrderByWithRelationInput | EndorsementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Endorsements.
     */
    cursor?: EndorsementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Endorsements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Endorsements.
     */
    skip?: number
    distinct?: EndorsementScalarFieldEnum | EndorsementScalarFieldEnum[]
  }

  /**
   * Endorsement create
   */
  export type EndorsementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endorsement
     */
    select?: EndorsementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndorsementInclude<ExtArgs> | null
    /**
     * The data needed to create a Endorsement.
     */
    data: XOR<EndorsementCreateInput, EndorsementUncheckedCreateInput>
  }

  /**
   * Endorsement createMany
   */
  export type EndorsementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Endorsements.
     */
    data: EndorsementCreateManyInput | EndorsementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Endorsement createManyAndReturn
   */
  export type EndorsementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endorsement
     */
    select?: EndorsementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Endorsements.
     */
    data: EndorsementCreateManyInput | EndorsementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndorsementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Endorsement update
   */
  export type EndorsementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endorsement
     */
    select?: EndorsementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndorsementInclude<ExtArgs> | null
    /**
     * The data needed to update a Endorsement.
     */
    data: XOR<EndorsementUpdateInput, EndorsementUncheckedUpdateInput>
    /**
     * Choose, which Endorsement to update.
     */
    where: EndorsementWhereUniqueInput
  }

  /**
   * Endorsement updateMany
   */
  export type EndorsementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Endorsements.
     */
    data: XOR<EndorsementUpdateManyMutationInput, EndorsementUncheckedUpdateManyInput>
    /**
     * Filter which Endorsements to update
     */
    where?: EndorsementWhereInput
  }

  /**
   * Endorsement upsert
   */
  export type EndorsementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endorsement
     */
    select?: EndorsementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndorsementInclude<ExtArgs> | null
    /**
     * The filter to search for the Endorsement to update in case it exists.
     */
    where: EndorsementWhereUniqueInput
    /**
     * In case the Endorsement found by the `where` argument doesn't exist, create a new Endorsement with this data.
     */
    create: XOR<EndorsementCreateInput, EndorsementUncheckedCreateInput>
    /**
     * In case the Endorsement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EndorsementUpdateInput, EndorsementUncheckedUpdateInput>
  }

  /**
   * Endorsement delete
   */
  export type EndorsementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endorsement
     */
    select?: EndorsementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndorsementInclude<ExtArgs> | null
    /**
     * Filter which Endorsement to delete.
     */
    where: EndorsementWhereUniqueInput
  }

  /**
   * Endorsement deleteMany
   */
  export type EndorsementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Endorsements to delete
     */
    where?: EndorsementWhereInput
  }

  /**
   * Endorsement.project
   */
  export type Endorsement$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Endorsement without action
   */
  export type EndorsementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endorsement
     */
    select?: EndorsementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndorsementInclude<ExtArgs> | null
  }


  /**
   * Model Opportunity
   */

  export type AggregateOpportunity = {
    _count: OpportunityCountAggregateOutputType | null
    _avg: OpportunityAvgAggregateOutputType | null
    _sum: OpportunitySumAggregateOutputType | null
    _min: OpportunityMinAggregateOutputType | null
    _max: OpportunityMaxAggregateOutputType | null
  }

  export type OpportunityAvgAggregateOutputType = {
    salaryMin: number | null
    salaryMax: number | null
  }

  export type OpportunitySumAggregateOutputType = {
    salaryMin: bigint | null
    salaryMax: bigint | null
  }

  export type OpportunityMinAggregateOutputType = {
    id: string | null
    title: string | null
    company: string | null
    companyLogo: string | null
    type: $Enums.OpportunityType | null
    location: string | null
    remote: boolean | null
    description: string | null
    salaryMin: bigint | null
    salaryMax: bigint | null
    postedDate: Date | null
    deadline: Date | null
    applicationUrl: string | null
    createdAt: Date | null
  }

  export type OpportunityMaxAggregateOutputType = {
    id: string | null
    title: string | null
    company: string | null
    companyLogo: string | null
    type: $Enums.OpportunityType | null
    location: string | null
    remote: boolean | null
    description: string | null
    salaryMin: bigint | null
    salaryMax: bigint | null
    postedDate: Date | null
    deadline: Date | null
    applicationUrl: string | null
    createdAt: Date | null
  }

  export type OpportunityCountAggregateOutputType = {
    id: number
    title: number
    company: number
    companyLogo: number
    type: number
    location: number
    remote: number
    description: number
    salaryMin: number
    salaryMax: number
    postedDate: number
    deadline: number
    applicationUrl: number
    createdAt: number
    _all: number
  }


  export type OpportunityAvgAggregateInputType = {
    salaryMin?: true
    salaryMax?: true
  }

  export type OpportunitySumAggregateInputType = {
    salaryMin?: true
    salaryMax?: true
  }

  export type OpportunityMinAggregateInputType = {
    id?: true
    title?: true
    company?: true
    companyLogo?: true
    type?: true
    location?: true
    remote?: true
    description?: true
    salaryMin?: true
    salaryMax?: true
    postedDate?: true
    deadline?: true
    applicationUrl?: true
    createdAt?: true
  }

  export type OpportunityMaxAggregateInputType = {
    id?: true
    title?: true
    company?: true
    companyLogo?: true
    type?: true
    location?: true
    remote?: true
    description?: true
    salaryMin?: true
    salaryMax?: true
    postedDate?: true
    deadline?: true
    applicationUrl?: true
    createdAt?: true
  }

  export type OpportunityCountAggregateInputType = {
    id?: true
    title?: true
    company?: true
    companyLogo?: true
    type?: true
    location?: true
    remote?: true
    description?: true
    salaryMin?: true
    salaryMax?: true
    postedDate?: true
    deadline?: true
    applicationUrl?: true
    createdAt?: true
    _all?: true
  }

  export type OpportunityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Opportunity to aggregate.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Opportunities
    **/
    _count?: true | OpportunityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OpportunityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OpportunitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpportunityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpportunityMaxAggregateInputType
  }

  export type GetOpportunityAggregateType<T extends OpportunityAggregateArgs> = {
        [P in keyof T & keyof AggregateOpportunity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpportunity[P]>
      : GetScalarType<T[P], AggregateOpportunity[P]>
  }




  export type OpportunityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityWhereInput
    orderBy?: OpportunityOrderByWithAggregationInput | OpportunityOrderByWithAggregationInput[]
    by: OpportunityScalarFieldEnum[] | OpportunityScalarFieldEnum
    having?: OpportunityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpportunityCountAggregateInputType | true
    _avg?: OpportunityAvgAggregateInputType
    _sum?: OpportunitySumAggregateInputType
    _min?: OpportunityMinAggregateInputType
    _max?: OpportunityMaxAggregateInputType
  }

  export type OpportunityGroupByOutputType = {
    id: string
    title: string
    company: string
    companyLogo: string | null
    type: $Enums.OpportunityType
    location: string
    remote: boolean
    description: string
    salaryMin: bigint | null
    salaryMax: bigint | null
    postedDate: Date
    deadline: Date | null
    applicationUrl: string | null
    createdAt: Date
    _count: OpportunityCountAggregateOutputType | null
    _avg: OpportunityAvgAggregateOutputType | null
    _sum: OpportunitySumAggregateOutputType | null
    _min: OpportunityMinAggregateOutputType | null
    _max: OpportunityMaxAggregateOutputType | null
  }

  type GetOpportunityGroupByPayload<T extends OpportunityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpportunityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpportunityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpportunityGroupByOutputType[P]>
            : GetScalarType<T[P], OpportunityGroupByOutputType[P]>
        }
      >
    >


  export type OpportunitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    company?: boolean
    companyLogo?: boolean
    type?: boolean
    location?: boolean
    remote?: boolean
    description?: boolean
    salaryMin?: boolean
    salaryMax?: boolean
    postedDate?: boolean
    deadline?: boolean
    applicationUrl?: boolean
    createdAt?: boolean
    requirements?: boolean | Opportunity$requirementsArgs<ExtArgs>
    skills?: boolean | Opportunity$skillsArgs<ExtArgs>
    applications?: boolean | Opportunity$applicationsArgs<ExtArgs>
    _count?: boolean | OpportunityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunity"]>

  export type OpportunitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    company?: boolean
    companyLogo?: boolean
    type?: boolean
    location?: boolean
    remote?: boolean
    description?: boolean
    salaryMin?: boolean
    salaryMax?: boolean
    postedDate?: boolean
    deadline?: boolean
    applicationUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["opportunity"]>

  export type OpportunitySelectScalar = {
    id?: boolean
    title?: boolean
    company?: boolean
    companyLogo?: boolean
    type?: boolean
    location?: boolean
    remote?: boolean
    description?: boolean
    salaryMin?: boolean
    salaryMax?: boolean
    postedDate?: boolean
    deadline?: boolean
    applicationUrl?: boolean
    createdAt?: boolean
  }

  export type OpportunityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirements?: boolean | Opportunity$requirementsArgs<ExtArgs>
    skills?: boolean | Opportunity$skillsArgs<ExtArgs>
    applications?: boolean | Opportunity$applicationsArgs<ExtArgs>
    _count?: boolean | OpportunityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OpportunityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OpportunityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Opportunity"
    objects: {
      requirements: Prisma.$OpportunityRequirementPayload<ExtArgs>[]
      skills: Prisma.$OpportunitySkillPayload<ExtArgs>[]
      applications: Prisma.$ApplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      company: string
      companyLogo: string | null
      type: $Enums.OpportunityType
      location: string
      remote: boolean
      description: string
      salaryMin: bigint | null
      salaryMax: bigint | null
      postedDate: Date
      deadline: Date | null
      applicationUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["opportunity"]>
    composites: {}
  }

  type OpportunityGetPayload<S extends boolean | null | undefined | OpportunityDefaultArgs> = $Result.GetResult<Prisma.$OpportunityPayload, S>

  type OpportunityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OpportunityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OpportunityCountAggregateInputType | true
    }

  export interface OpportunityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Opportunity'], meta: { name: 'Opportunity' } }
    /**
     * Find zero or one Opportunity that matches the filter.
     * @param {OpportunityFindUniqueArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpportunityFindUniqueArgs>(args: SelectSubset<T, OpportunityFindUniqueArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Opportunity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OpportunityFindUniqueOrThrowArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpportunityFindUniqueOrThrowArgs>(args: SelectSubset<T, OpportunityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Opportunity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityFindFirstArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpportunityFindFirstArgs>(args?: SelectSubset<T, OpportunityFindFirstArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Opportunity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityFindFirstOrThrowArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpportunityFindFirstOrThrowArgs>(args?: SelectSubset<T, OpportunityFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Opportunities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Opportunities
     * const opportunities = await prisma.opportunity.findMany()
     * 
     * // Get first 10 Opportunities
     * const opportunities = await prisma.opportunity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const opportunityWithIdOnly = await prisma.opportunity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OpportunityFindManyArgs>(args?: SelectSubset<T, OpportunityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Opportunity.
     * @param {OpportunityCreateArgs} args - Arguments to create a Opportunity.
     * @example
     * // Create one Opportunity
     * const Opportunity = await prisma.opportunity.create({
     *   data: {
     *     // ... data to create a Opportunity
     *   }
     * })
     * 
     */
    create<T extends OpportunityCreateArgs>(args: SelectSubset<T, OpportunityCreateArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Opportunities.
     * @param {OpportunityCreateManyArgs} args - Arguments to create many Opportunities.
     * @example
     * // Create many Opportunities
     * const opportunity = await prisma.opportunity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpportunityCreateManyArgs>(args?: SelectSubset<T, OpportunityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Opportunities and returns the data saved in the database.
     * @param {OpportunityCreateManyAndReturnArgs} args - Arguments to create many Opportunities.
     * @example
     * // Create many Opportunities
     * const opportunity = await prisma.opportunity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Opportunities and only return the `id`
     * const opportunityWithIdOnly = await prisma.opportunity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OpportunityCreateManyAndReturnArgs>(args?: SelectSubset<T, OpportunityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Opportunity.
     * @param {OpportunityDeleteArgs} args - Arguments to delete one Opportunity.
     * @example
     * // Delete one Opportunity
     * const Opportunity = await prisma.opportunity.delete({
     *   where: {
     *     // ... filter to delete one Opportunity
     *   }
     * })
     * 
     */
    delete<T extends OpportunityDeleteArgs>(args: SelectSubset<T, OpportunityDeleteArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Opportunity.
     * @param {OpportunityUpdateArgs} args - Arguments to update one Opportunity.
     * @example
     * // Update one Opportunity
     * const opportunity = await prisma.opportunity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpportunityUpdateArgs>(args: SelectSubset<T, OpportunityUpdateArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Opportunities.
     * @param {OpportunityDeleteManyArgs} args - Arguments to filter Opportunities to delete.
     * @example
     * // Delete a few Opportunities
     * const { count } = await prisma.opportunity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpportunityDeleteManyArgs>(args?: SelectSubset<T, OpportunityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Opportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Opportunities
     * const opportunity = await prisma.opportunity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpportunityUpdateManyArgs>(args: SelectSubset<T, OpportunityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Opportunity.
     * @param {OpportunityUpsertArgs} args - Arguments to update or create a Opportunity.
     * @example
     * // Update or create a Opportunity
     * const opportunity = await prisma.opportunity.upsert({
     *   create: {
     *     // ... data to create a Opportunity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Opportunity we want to update
     *   }
     * })
     */
    upsert<T extends OpportunityUpsertArgs>(args: SelectSubset<T, OpportunityUpsertArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Opportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityCountArgs} args - Arguments to filter Opportunities to count.
     * @example
     * // Count the number of Opportunities
     * const count = await prisma.opportunity.count({
     *   where: {
     *     // ... the filter for the Opportunities we want to count
     *   }
     * })
    **/
    count<T extends OpportunityCountArgs>(
      args?: Subset<T, OpportunityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpportunityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Opportunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpportunityAggregateArgs>(args: Subset<T, OpportunityAggregateArgs>): Prisma.PrismaPromise<GetOpportunityAggregateType<T>>

    /**
     * Group by Opportunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpportunityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpportunityGroupByArgs['orderBy'] }
        : { orderBy?: OpportunityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpportunityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpportunityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Opportunity model
   */
  readonly fields: OpportunityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Opportunity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpportunityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requirements<T extends Opportunity$requirementsArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$requirementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityRequirementPayload<ExtArgs>, T, "findMany"> | Null>
    skills<T extends Opportunity$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunitySkillPayload<ExtArgs>, T, "findMany"> | Null>
    applications<T extends Opportunity$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Opportunity model
   */ 
  interface OpportunityFieldRefs {
    readonly id: FieldRef<"Opportunity", 'String'>
    readonly title: FieldRef<"Opportunity", 'String'>
    readonly company: FieldRef<"Opportunity", 'String'>
    readonly companyLogo: FieldRef<"Opportunity", 'String'>
    readonly type: FieldRef<"Opportunity", 'OpportunityType'>
    readonly location: FieldRef<"Opportunity", 'String'>
    readonly remote: FieldRef<"Opportunity", 'Boolean'>
    readonly description: FieldRef<"Opportunity", 'String'>
    readonly salaryMin: FieldRef<"Opportunity", 'BigInt'>
    readonly salaryMax: FieldRef<"Opportunity", 'BigInt'>
    readonly postedDate: FieldRef<"Opportunity", 'DateTime'>
    readonly deadline: FieldRef<"Opportunity", 'DateTime'>
    readonly applicationUrl: FieldRef<"Opportunity", 'String'>
    readonly createdAt: FieldRef<"Opportunity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Opportunity findUnique
   */
  export type OpportunityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where: OpportunityWhereUniqueInput
  }

  /**
   * Opportunity findUniqueOrThrow
   */
  export type OpportunityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where: OpportunityWhereUniqueInput
  }

  /**
   * Opportunity findFirst
   */
  export type OpportunityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Opportunities.
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Opportunities.
     */
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Opportunity findFirstOrThrow
   */
  export type OpportunityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Opportunities.
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Opportunities.
     */
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Opportunity findMany
   */
  export type OpportunityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunities to fetch.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Opportunities.
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Opportunity create
   */
  export type OpportunityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * The data needed to create a Opportunity.
     */
    data: XOR<OpportunityCreateInput, OpportunityUncheckedCreateInput>
  }

  /**
   * Opportunity createMany
   */
  export type OpportunityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Opportunities.
     */
    data: OpportunityCreateManyInput | OpportunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Opportunity createManyAndReturn
   */
  export type OpportunityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Opportunities.
     */
    data: OpportunityCreateManyInput | OpportunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Opportunity update
   */
  export type OpportunityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * The data needed to update a Opportunity.
     */
    data: XOR<OpportunityUpdateInput, OpportunityUncheckedUpdateInput>
    /**
     * Choose, which Opportunity to update.
     */
    where: OpportunityWhereUniqueInput
  }

  /**
   * Opportunity updateMany
   */
  export type OpportunityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Opportunities.
     */
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyInput>
    /**
     * Filter which Opportunities to update
     */
    where?: OpportunityWhereInput
  }

  /**
   * Opportunity upsert
   */
  export type OpportunityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * The filter to search for the Opportunity to update in case it exists.
     */
    where: OpportunityWhereUniqueInput
    /**
     * In case the Opportunity found by the `where` argument doesn't exist, create a new Opportunity with this data.
     */
    create: XOR<OpportunityCreateInput, OpportunityUncheckedCreateInput>
    /**
     * In case the Opportunity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpportunityUpdateInput, OpportunityUncheckedUpdateInput>
  }

  /**
   * Opportunity delete
   */
  export type OpportunityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter which Opportunity to delete.
     */
    where: OpportunityWhereUniqueInput
  }

  /**
   * Opportunity deleteMany
   */
  export type OpportunityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Opportunities to delete
     */
    where?: OpportunityWhereInput
  }

  /**
   * Opportunity.requirements
   */
  export type Opportunity$requirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityRequirement
     */
    select?: OpportunityRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityRequirementInclude<ExtArgs> | null
    where?: OpportunityRequirementWhereInput
    orderBy?: OpportunityRequirementOrderByWithRelationInput | OpportunityRequirementOrderByWithRelationInput[]
    cursor?: OpportunityRequirementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpportunityRequirementScalarFieldEnum | OpportunityRequirementScalarFieldEnum[]
  }

  /**
   * Opportunity.skills
   */
  export type Opportunity$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunitySkill
     */
    select?: OpportunitySkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunitySkillInclude<ExtArgs> | null
    where?: OpportunitySkillWhereInput
    orderBy?: OpportunitySkillOrderByWithRelationInput | OpportunitySkillOrderByWithRelationInput[]
    cursor?: OpportunitySkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpportunitySkillScalarFieldEnum | OpportunitySkillScalarFieldEnum[]
  }

  /**
   * Opportunity.applications
   */
  export type Opportunity$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    cursor?: ApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Opportunity without action
   */
  export type OpportunityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
  }


  /**
   * Model OpportunityRequirement
   */

  export type AggregateOpportunityRequirement = {
    _count: OpportunityRequirementCountAggregateOutputType | null
    _avg: OpportunityRequirementAvgAggregateOutputType | null
    _sum: OpportunityRequirementSumAggregateOutputType | null
    _min: OpportunityRequirementMinAggregateOutputType | null
    _max: OpportunityRequirementMaxAggregateOutputType | null
  }

  export type OpportunityRequirementAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type OpportunityRequirementSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type OpportunityRequirementMinAggregateOutputType = {
    id: string | null
    opportunityId: string | null
    requirement: string | null
    displayOrder: number | null
  }

  export type OpportunityRequirementMaxAggregateOutputType = {
    id: string | null
    opportunityId: string | null
    requirement: string | null
    displayOrder: number | null
  }

  export type OpportunityRequirementCountAggregateOutputType = {
    id: number
    opportunityId: number
    requirement: number
    displayOrder: number
    _all: number
  }


  export type OpportunityRequirementAvgAggregateInputType = {
    displayOrder?: true
  }

  export type OpportunityRequirementSumAggregateInputType = {
    displayOrder?: true
  }

  export type OpportunityRequirementMinAggregateInputType = {
    id?: true
    opportunityId?: true
    requirement?: true
    displayOrder?: true
  }

  export type OpportunityRequirementMaxAggregateInputType = {
    id?: true
    opportunityId?: true
    requirement?: true
    displayOrder?: true
  }

  export type OpportunityRequirementCountAggregateInputType = {
    id?: true
    opportunityId?: true
    requirement?: true
    displayOrder?: true
    _all?: true
  }

  export type OpportunityRequirementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpportunityRequirement to aggregate.
     */
    where?: OpportunityRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpportunityRequirements to fetch.
     */
    orderBy?: OpportunityRequirementOrderByWithRelationInput | OpportunityRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpportunityRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpportunityRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpportunityRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OpportunityRequirements
    **/
    _count?: true | OpportunityRequirementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OpportunityRequirementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OpportunityRequirementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpportunityRequirementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpportunityRequirementMaxAggregateInputType
  }

  export type GetOpportunityRequirementAggregateType<T extends OpportunityRequirementAggregateArgs> = {
        [P in keyof T & keyof AggregateOpportunityRequirement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpportunityRequirement[P]>
      : GetScalarType<T[P], AggregateOpportunityRequirement[P]>
  }




  export type OpportunityRequirementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityRequirementWhereInput
    orderBy?: OpportunityRequirementOrderByWithAggregationInput | OpportunityRequirementOrderByWithAggregationInput[]
    by: OpportunityRequirementScalarFieldEnum[] | OpportunityRequirementScalarFieldEnum
    having?: OpportunityRequirementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpportunityRequirementCountAggregateInputType | true
    _avg?: OpportunityRequirementAvgAggregateInputType
    _sum?: OpportunityRequirementSumAggregateInputType
    _min?: OpportunityRequirementMinAggregateInputType
    _max?: OpportunityRequirementMaxAggregateInputType
  }

  export type OpportunityRequirementGroupByOutputType = {
    id: string
    opportunityId: string
    requirement: string
    displayOrder: number
    _count: OpportunityRequirementCountAggregateOutputType | null
    _avg: OpportunityRequirementAvgAggregateOutputType | null
    _sum: OpportunityRequirementSumAggregateOutputType | null
    _min: OpportunityRequirementMinAggregateOutputType | null
    _max: OpportunityRequirementMaxAggregateOutputType | null
  }

  type GetOpportunityRequirementGroupByPayload<T extends OpportunityRequirementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpportunityRequirementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpportunityRequirementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpportunityRequirementGroupByOutputType[P]>
            : GetScalarType<T[P], OpportunityRequirementGroupByOutputType[P]>
        }
      >
    >


  export type OpportunityRequirementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    opportunityId?: boolean
    requirement?: boolean
    displayOrder?: boolean
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunityRequirement"]>

  export type OpportunityRequirementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    opportunityId?: boolean
    requirement?: boolean
    displayOrder?: boolean
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunityRequirement"]>

  export type OpportunityRequirementSelectScalar = {
    id?: boolean
    opportunityId?: boolean
    requirement?: boolean
    displayOrder?: boolean
  }

  export type OpportunityRequirementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }
  export type OpportunityRequirementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }

  export type $OpportunityRequirementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OpportunityRequirement"
    objects: {
      opportunity: Prisma.$OpportunityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      opportunityId: string
      requirement: string
      displayOrder: number
    }, ExtArgs["result"]["opportunityRequirement"]>
    composites: {}
  }

  type OpportunityRequirementGetPayload<S extends boolean | null | undefined | OpportunityRequirementDefaultArgs> = $Result.GetResult<Prisma.$OpportunityRequirementPayload, S>

  type OpportunityRequirementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OpportunityRequirementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OpportunityRequirementCountAggregateInputType | true
    }

  export interface OpportunityRequirementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OpportunityRequirement'], meta: { name: 'OpportunityRequirement' } }
    /**
     * Find zero or one OpportunityRequirement that matches the filter.
     * @param {OpportunityRequirementFindUniqueArgs} args - Arguments to find a OpportunityRequirement
     * @example
     * // Get one OpportunityRequirement
     * const opportunityRequirement = await prisma.opportunityRequirement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpportunityRequirementFindUniqueArgs>(args: SelectSubset<T, OpportunityRequirementFindUniqueArgs<ExtArgs>>): Prisma__OpportunityRequirementClient<$Result.GetResult<Prisma.$OpportunityRequirementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OpportunityRequirement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OpportunityRequirementFindUniqueOrThrowArgs} args - Arguments to find a OpportunityRequirement
     * @example
     * // Get one OpportunityRequirement
     * const opportunityRequirement = await prisma.opportunityRequirement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpportunityRequirementFindUniqueOrThrowArgs>(args: SelectSubset<T, OpportunityRequirementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpportunityRequirementClient<$Result.GetResult<Prisma.$OpportunityRequirementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OpportunityRequirement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityRequirementFindFirstArgs} args - Arguments to find a OpportunityRequirement
     * @example
     * // Get one OpportunityRequirement
     * const opportunityRequirement = await prisma.opportunityRequirement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpportunityRequirementFindFirstArgs>(args?: SelectSubset<T, OpportunityRequirementFindFirstArgs<ExtArgs>>): Prisma__OpportunityRequirementClient<$Result.GetResult<Prisma.$OpportunityRequirementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OpportunityRequirement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityRequirementFindFirstOrThrowArgs} args - Arguments to find a OpportunityRequirement
     * @example
     * // Get one OpportunityRequirement
     * const opportunityRequirement = await prisma.opportunityRequirement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpportunityRequirementFindFirstOrThrowArgs>(args?: SelectSubset<T, OpportunityRequirementFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpportunityRequirementClient<$Result.GetResult<Prisma.$OpportunityRequirementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OpportunityRequirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityRequirementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OpportunityRequirements
     * const opportunityRequirements = await prisma.opportunityRequirement.findMany()
     * 
     * // Get first 10 OpportunityRequirements
     * const opportunityRequirements = await prisma.opportunityRequirement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const opportunityRequirementWithIdOnly = await prisma.opportunityRequirement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OpportunityRequirementFindManyArgs>(args?: SelectSubset<T, OpportunityRequirementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityRequirementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OpportunityRequirement.
     * @param {OpportunityRequirementCreateArgs} args - Arguments to create a OpportunityRequirement.
     * @example
     * // Create one OpportunityRequirement
     * const OpportunityRequirement = await prisma.opportunityRequirement.create({
     *   data: {
     *     // ... data to create a OpportunityRequirement
     *   }
     * })
     * 
     */
    create<T extends OpportunityRequirementCreateArgs>(args: SelectSubset<T, OpportunityRequirementCreateArgs<ExtArgs>>): Prisma__OpportunityRequirementClient<$Result.GetResult<Prisma.$OpportunityRequirementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OpportunityRequirements.
     * @param {OpportunityRequirementCreateManyArgs} args - Arguments to create many OpportunityRequirements.
     * @example
     * // Create many OpportunityRequirements
     * const opportunityRequirement = await prisma.opportunityRequirement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpportunityRequirementCreateManyArgs>(args?: SelectSubset<T, OpportunityRequirementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OpportunityRequirements and returns the data saved in the database.
     * @param {OpportunityRequirementCreateManyAndReturnArgs} args - Arguments to create many OpportunityRequirements.
     * @example
     * // Create many OpportunityRequirements
     * const opportunityRequirement = await prisma.opportunityRequirement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OpportunityRequirements and only return the `id`
     * const opportunityRequirementWithIdOnly = await prisma.opportunityRequirement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OpportunityRequirementCreateManyAndReturnArgs>(args?: SelectSubset<T, OpportunityRequirementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityRequirementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OpportunityRequirement.
     * @param {OpportunityRequirementDeleteArgs} args - Arguments to delete one OpportunityRequirement.
     * @example
     * // Delete one OpportunityRequirement
     * const OpportunityRequirement = await prisma.opportunityRequirement.delete({
     *   where: {
     *     // ... filter to delete one OpportunityRequirement
     *   }
     * })
     * 
     */
    delete<T extends OpportunityRequirementDeleteArgs>(args: SelectSubset<T, OpportunityRequirementDeleteArgs<ExtArgs>>): Prisma__OpportunityRequirementClient<$Result.GetResult<Prisma.$OpportunityRequirementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OpportunityRequirement.
     * @param {OpportunityRequirementUpdateArgs} args - Arguments to update one OpportunityRequirement.
     * @example
     * // Update one OpportunityRequirement
     * const opportunityRequirement = await prisma.opportunityRequirement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpportunityRequirementUpdateArgs>(args: SelectSubset<T, OpportunityRequirementUpdateArgs<ExtArgs>>): Prisma__OpportunityRequirementClient<$Result.GetResult<Prisma.$OpportunityRequirementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OpportunityRequirements.
     * @param {OpportunityRequirementDeleteManyArgs} args - Arguments to filter OpportunityRequirements to delete.
     * @example
     * // Delete a few OpportunityRequirements
     * const { count } = await prisma.opportunityRequirement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpportunityRequirementDeleteManyArgs>(args?: SelectSubset<T, OpportunityRequirementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OpportunityRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityRequirementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OpportunityRequirements
     * const opportunityRequirement = await prisma.opportunityRequirement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpportunityRequirementUpdateManyArgs>(args: SelectSubset<T, OpportunityRequirementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OpportunityRequirement.
     * @param {OpportunityRequirementUpsertArgs} args - Arguments to update or create a OpportunityRequirement.
     * @example
     * // Update or create a OpportunityRequirement
     * const opportunityRequirement = await prisma.opportunityRequirement.upsert({
     *   create: {
     *     // ... data to create a OpportunityRequirement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OpportunityRequirement we want to update
     *   }
     * })
     */
    upsert<T extends OpportunityRequirementUpsertArgs>(args: SelectSubset<T, OpportunityRequirementUpsertArgs<ExtArgs>>): Prisma__OpportunityRequirementClient<$Result.GetResult<Prisma.$OpportunityRequirementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OpportunityRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityRequirementCountArgs} args - Arguments to filter OpportunityRequirements to count.
     * @example
     * // Count the number of OpportunityRequirements
     * const count = await prisma.opportunityRequirement.count({
     *   where: {
     *     // ... the filter for the OpportunityRequirements we want to count
     *   }
     * })
    **/
    count<T extends OpportunityRequirementCountArgs>(
      args?: Subset<T, OpportunityRequirementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpportunityRequirementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OpportunityRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityRequirementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpportunityRequirementAggregateArgs>(args: Subset<T, OpportunityRequirementAggregateArgs>): Prisma.PrismaPromise<GetOpportunityRequirementAggregateType<T>>

    /**
     * Group by OpportunityRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityRequirementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpportunityRequirementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpportunityRequirementGroupByArgs['orderBy'] }
        : { orderBy?: OpportunityRequirementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpportunityRequirementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpportunityRequirementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OpportunityRequirement model
   */
  readonly fields: OpportunityRequirementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OpportunityRequirement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpportunityRequirementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    opportunity<T extends OpportunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OpportunityDefaultArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OpportunityRequirement model
   */ 
  interface OpportunityRequirementFieldRefs {
    readonly id: FieldRef<"OpportunityRequirement", 'String'>
    readonly opportunityId: FieldRef<"OpportunityRequirement", 'String'>
    readonly requirement: FieldRef<"OpportunityRequirement", 'String'>
    readonly displayOrder: FieldRef<"OpportunityRequirement", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OpportunityRequirement findUnique
   */
  export type OpportunityRequirementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityRequirement
     */
    select?: OpportunityRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityRequirementInclude<ExtArgs> | null
    /**
     * Filter, which OpportunityRequirement to fetch.
     */
    where: OpportunityRequirementWhereUniqueInput
  }

  /**
   * OpportunityRequirement findUniqueOrThrow
   */
  export type OpportunityRequirementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityRequirement
     */
    select?: OpportunityRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityRequirementInclude<ExtArgs> | null
    /**
     * Filter, which OpportunityRequirement to fetch.
     */
    where: OpportunityRequirementWhereUniqueInput
  }

  /**
   * OpportunityRequirement findFirst
   */
  export type OpportunityRequirementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityRequirement
     */
    select?: OpportunityRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityRequirementInclude<ExtArgs> | null
    /**
     * Filter, which OpportunityRequirement to fetch.
     */
    where?: OpportunityRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpportunityRequirements to fetch.
     */
    orderBy?: OpportunityRequirementOrderByWithRelationInput | OpportunityRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpportunityRequirements.
     */
    cursor?: OpportunityRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpportunityRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpportunityRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpportunityRequirements.
     */
    distinct?: OpportunityRequirementScalarFieldEnum | OpportunityRequirementScalarFieldEnum[]
  }

  /**
   * OpportunityRequirement findFirstOrThrow
   */
  export type OpportunityRequirementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityRequirement
     */
    select?: OpportunityRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityRequirementInclude<ExtArgs> | null
    /**
     * Filter, which OpportunityRequirement to fetch.
     */
    where?: OpportunityRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpportunityRequirements to fetch.
     */
    orderBy?: OpportunityRequirementOrderByWithRelationInput | OpportunityRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpportunityRequirements.
     */
    cursor?: OpportunityRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpportunityRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpportunityRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpportunityRequirements.
     */
    distinct?: OpportunityRequirementScalarFieldEnum | OpportunityRequirementScalarFieldEnum[]
  }

  /**
   * OpportunityRequirement findMany
   */
  export type OpportunityRequirementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityRequirement
     */
    select?: OpportunityRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityRequirementInclude<ExtArgs> | null
    /**
     * Filter, which OpportunityRequirements to fetch.
     */
    where?: OpportunityRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpportunityRequirements to fetch.
     */
    orderBy?: OpportunityRequirementOrderByWithRelationInput | OpportunityRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OpportunityRequirements.
     */
    cursor?: OpportunityRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpportunityRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpportunityRequirements.
     */
    skip?: number
    distinct?: OpportunityRequirementScalarFieldEnum | OpportunityRequirementScalarFieldEnum[]
  }

  /**
   * OpportunityRequirement create
   */
  export type OpportunityRequirementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityRequirement
     */
    select?: OpportunityRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityRequirementInclude<ExtArgs> | null
    /**
     * The data needed to create a OpportunityRequirement.
     */
    data: XOR<OpportunityRequirementCreateInput, OpportunityRequirementUncheckedCreateInput>
  }

  /**
   * OpportunityRequirement createMany
   */
  export type OpportunityRequirementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OpportunityRequirements.
     */
    data: OpportunityRequirementCreateManyInput | OpportunityRequirementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OpportunityRequirement createManyAndReturn
   */
  export type OpportunityRequirementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityRequirement
     */
    select?: OpportunityRequirementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OpportunityRequirements.
     */
    data: OpportunityRequirementCreateManyInput | OpportunityRequirementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityRequirementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OpportunityRequirement update
   */
  export type OpportunityRequirementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityRequirement
     */
    select?: OpportunityRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityRequirementInclude<ExtArgs> | null
    /**
     * The data needed to update a OpportunityRequirement.
     */
    data: XOR<OpportunityRequirementUpdateInput, OpportunityRequirementUncheckedUpdateInput>
    /**
     * Choose, which OpportunityRequirement to update.
     */
    where: OpportunityRequirementWhereUniqueInput
  }

  /**
   * OpportunityRequirement updateMany
   */
  export type OpportunityRequirementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OpportunityRequirements.
     */
    data: XOR<OpportunityRequirementUpdateManyMutationInput, OpportunityRequirementUncheckedUpdateManyInput>
    /**
     * Filter which OpportunityRequirements to update
     */
    where?: OpportunityRequirementWhereInput
  }

  /**
   * OpportunityRequirement upsert
   */
  export type OpportunityRequirementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityRequirement
     */
    select?: OpportunityRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityRequirementInclude<ExtArgs> | null
    /**
     * The filter to search for the OpportunityRequirement to update in case it exists.
     */
    where: OpportunityRequirementWhereUniqueInput
    /**
     * In case the OpportunityRequirement found by the `where` argument doesn't exist, create a new OpportunityRequirement with this data.
     */
    create: XOR<OpportunityRequirementCreateInput, OpportunityRequirementUncheckedCreateInput>
    /**
     * In case the OpportunityRequirement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpportunityRequirementUpdateInput, OpportunityRequirementUncheckedUpdateInput>
  }

  /**
   * OpportunityRequirement delete
   */
  export type OpportunityRequirementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityRequirement
     */
    select?: OpportunityRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityRequirementInclude<ExtArgs> | null
    /**
     * Filter which OpportunityRequirement to delete.
     */
    where: OpportunityRequirementWhereUniqueInput
  }

  /**
   * OpportunityRequirement deleteMany
   */
  export type OpportunityRequirementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpportunityRequirements to delete
     */
    where?: OpportunityRequirementWhereInput
  }

  /**
   * OpportunityRequirement without action
   */
  export type OpportunityRequirementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityRequirement
     */
    select?: OpportunityRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityRequirementInclude<ExtArgs> | null
  }


  /**
   * Model OpportunitySkill
   */

  export type AggregateOpportunitySkill = {
    _count: OpportunitySkillCountAggregateOutputType | null
    _min: OpportunitySkillMinAggregateOutputType | null
    _max: OpportunitySkillMaxAggregateOutputType | null
  }

  export type OpportunitySkillMinAggregateOutputType = {
    opportunityId: string | null
    skillId: string | null
  }

  export type OpportunitySkillMaxAggregateOutputType = {
    opportunityId: string | null
    skillId: string | null
  }

  export type OpportunitySkillCountAggregateOutputType = {
    opportunityId: number
    skillId: number
    _all: number
  }


  export type OpportunitySkillMinAggregateInputType = {
    opportunityId?: true
    skillId?: true
  }

  export type OpportunitySkillMaxAggregateInputType = {
    opportunityId?: true
    skillId?: true
  }

  export type OpportunitySkillCountAggregateInputType = {
    opportunityId?: true
    skillId?: true
    _all?: true
  }

  export type OpportunitySkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpportunitySkill to aggregate.
     */
    where?: OpportunitySkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpportunitySkills to fetch.
     */
    orderBy?: OpportunitySkillOrderByWithRelationInput | OpportunitySkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpportunitySkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpportunitySkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpportunitySkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OpportunitySkills
    **/
    _count?: true | OpportunitySkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpportunitySkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpportunitySkillMaxAggregateInputType
  }

  export type GetOpportunitySkillAggregateType<T extends OpportunitySkillAggregateArgs> = {
        [P in keyof T & keyof AggregateOpportunitySkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpportunitySkill[P]>
      : GetScalarType<T[P], AggregateOpportunitySkill[P]>
  }




  export type OpportunitySkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunitySkillWhereInput
    orderBy?: OpportunitySkillOrderByWithAggregationInput | OpportunitySkillOrderByWithAggregationInput[]
    by: OpportunitySkillScalarFieldEnum[] | OpportunitySkillScalarFieldEnum
    having?: OpportunitySkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpportunitySkillCountAggregateInputType | true
    _min?: OpportunitySkillMinAggregateInputType
    _max?: OpportunitySkillMaxAggregateInputType
  }

  export type OpportunitySkillGroupByOutputType = {
    opportunityId: string
    skillId: string
    _count: OpportunitySkillCountAggregateOutputType | null
    _min: OpportunitySkillMinAggregateOutputType | null
    _max: OpportunitySkillMaxAggregateOutputType | null
  }

  type GetOpportunitySkillGroupByPayload<T extends OpportunitySkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpportunitySkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpportunitySkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpportunitySkillGroupByOutputType[P]>
            : GetScalarType<T[P], OpportunitySkillGroupByOutputType[P]>
        }
      >
    >


  export type OpportunitySkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    opportunityId?: boolean
    skillId?: boolean
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunitySkill"]>

  export type OpportunitySkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    opportunityId?: boolean
    skillId?: boolean
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunitySkill"]>

  export type OpportunitySkillSelectScalar = {
    opportunityId?: boolean
    skillId?: boolean
  }

  export type OpportunitySkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type OpportunitySkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }

  export type $OpportunitySkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OpportunitySkill"
    objects: {
      opportunity: Prisma.$OpportunityPayload<ExtArgs>
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      opportunityId: string
      skillId: string
    }, ExtArgs["result"]["opportunitySkill"]>
    composites: {}
  }

  type OpportunitySkillGetPayload<S extends boolean | null | undefined | OpportunitySkillDefaultArgs> = $Result.GetResult<Prisma.$OpportunitySkillPayload, S>

  type OpportunitySkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OpportunitySkillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OpportunitySkillCountAggregateInputType | true
    }

  export interface OpportunitySkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OpportunitySkill'], meta: { name: 'OpportunitySkill' } }
    /**
     * Find zero or one OpportunitySkill that matches the filter.
     * @param {OpportunitySkillFindUniqueArgs} args - Arguments to find a OpportunitySkill
     * @example
     * // Get one OpportunitySkill
     * const opportunitySkill = await prisma.opportunitySkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpportunitySkillFindUniqueArgs>(args: SelectSubset<T, OpportunitySkillFindUniqueArgs<ExtArgs>>): Prisma__OpportunitySkillClient<$Result.GetResult<Prisma.$OpportunitySkillPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OpportunitySkill that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OpportunitySkillFindUniqueOrThrowArgs} args - Arguments to find a OpportunitySkill
     * @example
     * // Get one OpportunitySkill
     * const opportunitySkill = await prisma.opportunitySkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpportunitySkillFindUniqueOrThrowArgs>(args: SelectSubset<T, OpportunitySkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpportunitySkillClient<$Result.GetResult<Prisma.$OpportunitySkillPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OpportunitySkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunitySkillFindFirstArgs} args - Arguments to find a OpportunitySkill
     * @example
     * // Get one OpportunitySkill
     * const opportunitySkill = await prisma.opportunitySkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpportunitySkillFindFirstArgs>(args?: SelectSubset<T, OpportunitySkillFindFirstArgs<ExtArgs>>): Prisma__OpportunitySkillClient<$Result.GetResult<Prisma.$OpportunitySkillPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OpportunitySkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunitySkillFindFirstOrThrowArgs} args - Arguments to find a OpportunitySkill
     * @example
     * // Get one OpportunitySkill
     * const opportunitySkill = await prisma.opportunitySkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpportunitySkillFindFirstOrThrowArgs>(args?: SelectSubset<T, OpportunitySkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpportunitySkillClient<$Result.GetResult<Prisma.$OpportunitySkillPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OpportunitySkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunitySkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OpportunitySkills
     * const opportunitySkills = await prisma.opportunitySkill.findMany()
     * 
     * // Get first 10 OpportunitySkills
     * const opportunitySkills = await prisma.opportunitySkill.findMany({ take: 10 })
     * 
     * // Only select the `opportunityId`
     * const opportunitySkillWithOpportunityIdOnly = await prisma.opportunitySkill.findMany({ select: { opportunityId: true } })
     * 
     */
    findMany<T extends OpportunitySkillFindManyArgs>(args?: SelectSubset<T, OpportunitySkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunitySkillPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OpportunitySkill.
     * @param {OpportunitySkillCreateArgs} args - Arguments to create a OpportunitySkill.
     * @example
     * // Create one OpportunitySkill
     * const OpportunitySkill = await prisma.opportunitySkill.create({
     *   data: {
     *     // ... data to create a OpportunitySkill
     *   }
     * })
     * 
     */
    create<T extends OpportunitySkillCreateArgs>(args: SelectSubset<T, OpportunitySkillCreateArgs<ExtArgs>>): Prisma__OpportunitySkillClient<$Result.GetResult<Prisma.$OpportunitySkillPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OpportunitySkills.
     * @param {OpportunitySkillCreateManyArgs} args - Arguments to create many OpportunitySkills.
     * @example
     * // Create many OpportunitySkills
     * const opportunitySkill = await prisma.opportunitySkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpportunitySkillCreateManyArgs>(args?: SelectSubset<T, OpportunitySkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OpportunitySkills and returns the data saved in the database.
     * @param {OpportunitySkillCreateManyAndReturnArgs} args - Arguments to create many OpportunitySkills.
     * @example
     * // Create many OpportunitySkills
     * const opportunitySkill = await prisma.opportunitySkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OpportunitySkills and only return the `opportunityId`
     * const opportunitySkillWithOpportunityIdOnly = await prisma.opportunitySkill.createManyAndReturn({ 
     *   select: { opportunityId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OpportunitySkillCreateManyAndReturnArgs>(args?: SelectSubset<T, OpportunitySkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunitySkillPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OpportunitySkill.
     * @param {OpportunitySkillDeleteArgs} args - Arguments to delete one OpportunitySkill.
     * @example
     * // Delete one OpportunitySkill
     * const OpportunitySkill = await prisma.opportunitySkill.delete({
     *   where: {
     *     // ... filter to delete one OpportunitySkill
     *   }
     * })
     * 
     */
    delete<T extends OpportunitySkillDeleteArgs>(args: SelectSubset<T, OpportunitySkillDeleteArgs<ExtArgs>>): Prisma__OpportunitySkillClient<$Result.GetResult<Prisma.$OpportunitySkillPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OpportunitySkill.
     * @param {OpportunitySkillUpdateArgs} args - Arguments to update one OpportunitySkill.
     * @example
     * // Update one OpportunitySkill
     * const opportunitySkill = await prisma.opportunitySkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpportunitySkillUpdateArgs>(args: SelectSubset<T, OpportunitySkillUpdateArgs<ExtArgs>>): Prisma__OpportunitySkillClient<$Result.GetResult<Prisma.$OpportunitySkillPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OpportunitySkills.
     * @param {OpportunitySkillDeleteManyArgs} args - Arguments to filter OpportunitySkills to delete.
     * @example
     * // Delete a few OpportunitySkills
     * const { count } = await prisma.opportunitySkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpportunitySkillDeleteManyArgs>(args?: SelectSubset<T, OpportunitySkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OpportunitySkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunitySkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OpportunitySkills
     * const opportunitySkill = await prisma.opportunitySkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpportunitySkillUpdateManyArgs>(args: SelectSubset<T, OpportunitySkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OpportunitySkill.
     * @param {OpportunitySkillUpsertArgs} args - Arguments to update or create a OpportunitySkill.
     * @example
     * // Update or create a OpportunitySkill
     * const opportunitySkill = await prisma.opportunitySkill.upsert({
     *   create: {
     *     // ... data to create a OpportunitySkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OpportunitySkill we want to update
     *   }
     * })
     */
    upsert<T extends OpportunitySkillUpsertArgs>(args: SelectSubset<T, OpportunitySkillUpsertArgs<ExtArgs>>): Prisma__OpportunitySkillClient<$Result.GetResult<Prisma.$OpportunitySkillPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OpportunitySkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunitySkillCountArgs} args - Arguments to filter OpportunitySkills to count.
     * @example
     * // Count the number of OpportunitySkills
     * const count = await prisma.opportunitySkill.count({
     *   where: {
     *     // ... the filter for the OpportunitySkills we want to count
     *   }
     * })
    **/
    count<T extends OpportunitySkillCountArgs>(
      args?: Subset<T, OpportunitySkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpportunitySkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OpportunitySkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunitySkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpportunitySkillAggregateArgs>(args: Subset<T, OpportunitySkillAggregateArgs>): Prisma.PrismaPromise<GetOpportunitySkillAggregateType<T>>

    /**
     * Group by OpportunitySkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunitySkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpportunitySkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpportunitySkillGroupByArgs['orderBy'] }
        : { orderBy?: OpportunitySkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpportunitySkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpportunitySkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OpportunitySkill model
   */
  readonly fields: OpportunitySkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OpportunitySkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpportunitySkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    opportunity<T extends OpportunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OpportunityDefaultArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OpportunitySkill model
   */ 
  interface OpportunitySkillFieldRefs {
    readonly opportunityId: FieldRef<"OpportunitySkill", 'String'>
    readonly skillId: FieldRef<"OpportunitySkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OpportunitySkill findUnique
   */
  export type OpportunitySkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunitySkill
     */
    select?: OpportunitySkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunitySkillInclude<ExtArgs> | null
    /**
     * Filter, which OpportunitySkill to fetch.
     */
    where: OpportunitySkillWhereUniqueInput
  }

  /**
   * OpportunitySkill findUniqueOrThrow
   */
  export type OpportunitySkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunitySkill
     */
    select?: OpportunitySkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunitySkillInclude<ExtArgs> | null
    /**
     * Filter, which OpportunitySkill to fetch.
     */
    where: OpportunitySkillWhereUniqueInput
  }

  /**
   * OpportunitySkill findFirst
   */
  export type OpportunitySkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunitySkill
     */
    select?: OpportunitySkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunitySkillInclude<ExtArgs> | null
    /**
     * Filter, which OpportunitySkill to fetch.
     */
    where?: OpportunitySkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpportunitySkills to fetch.
     */
    orderBy?: OpportunitySkillOrderByWithRelationInput | OpportunitySkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpportunitySkills.
     */
    cursor?: OpportunitySkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpportunitySkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpportunitySkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpportunitySkills.
     */
    distinct?: OpportunitySkillScalarFieldEnum | OpportunitySkillScalarFieldEnum[]
  }

  /**
   * OpportunitySkill findFirstOrThrow
   */
  export type OpportunitySkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunitySkill
     */
    select?: OpportunitySkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunitySkillInclude<ExtArgs> | null
    /**
     * Filter, which OpportunitySkill to fetch.
     */
    where?: OpportunitySkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpportunitySkills to fetch.
     */
    orderBy?: OpportunitySkillOrderByWithRelationInput | OpportunitySkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpportunitySkills.
     */
    cursor?: OpportunitySkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpportunitySkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpportunitySkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpportunitySkills.
     */
    distinct?: OpportunitySkillScalarFieldEnum | OpportunitySkillScalarFieldEnum[]
  }

  /**
   * OpportunitySkill findMany
   */
  export type OpportunitySkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunitySkill
     */
    select?: OpportunitySkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunitySkillInclude<ExtArgs> | null
    /**
     * Filter, which OpportunitySkills to fetch.
     */
    where?: OpportunitySkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpportunitySkills to fetch.
     */
    orderBy?: OpportunitySkillOrderByWithRelationInput | OpportunitySkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OpportunitySkills.
     */
    cursor?: OpportunitySkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpportunitySkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpportunitySkills.
     */
    skip?: number
    distinct?: OpportunitySkillScalarFieldEnum | OpportunitySkillScalarFieldEnum[]
  }

  /**
   * OpportunitySkill create
   */
  export type OpportunitySkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunitySkill
     */
    select?: OpportunitySkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunitySkillInclude<ExtArgs> | null
    /**
     * The data needed to create a OpportunitySkill.
     */
    data: XOR<OpportunitySkillCreateInput, OpportunitySkillUncheckedCreateInput>
  }

  /**
   * OpportunitySkill createMany
   */
  export type OpportunitySkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OpportunitySkills.
     */
    data: OpportunitySkillCreateManyInput | OpportunitySkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OpportunitySkill createManyAndReturn
   */
  export type OpportunitySkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunitySkill
     */
    select?: OpportunitySkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OpportunitySkills.
     */
    data: OpportunitySkillCreateManyInput | OpportunitySkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunitySkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OpportunitySkill update
   */
  export type OpportunitySkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunitySkill
     */
    select?: OpportunitySkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunitySkillInclude<ExtArgs> | null
    /**
     * The data needed to update a OpportunitySkill.
     */
    data: XOR<OpportunitySkillUpdateInput, OpportunitySkillUncheckedUpdateInput>
    /**
     * Choose, which OpportunitySkill to update.
     */
    where: OpportunitySkillWhereUniqueInput
  }

  /**
   * OpportunitySkill updateMany
   */
  export type OpportunitySkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OpportunitySkills.
     */
    data: XOR<OpportunitySkillUpdateManyMutationInput, OpportunitySkillUncheckedUpdateManyInput>
    /**
     * Filter which OpportunitySkills to update
     */
    where?: OpportunitySkillWhereInput
  }

  /**
   * OpportunitySkill upsert
   */
  export type OpportunitySkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunitySkill
     */
    select?: OpportunitySkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunitySkillInclude<ExtArgs> | null
    /**
     * The filter to search for the OpportunitySkill to update in case it exists.
     */
    where: OpportunitySkillWhereUniqueInput
    /**
     * In case the OpportunitySkill found by the `where` argument doesn't exist, create a new OpportunitySkill with this data.
     */
    create: XOR<OpportunitySkillCreateInput, OpportunitySkillUncheckedCreateInput>
    /**
     * In case the OpportunitySkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpportunitySkillUpdateInput, OpportunitySkillUncheckedUpdateInput>
  }

  /**
   * OpportunitySkill delete
   */
  export type OpportunitySkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunitySkill
     */
    select?: OpportunitySkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunitySkillInclude<ExtArgs> | null
    /**
     * Filter which OpportunitySkill to delete.
     */
    where: OpportunitySkillWhereUniqueInput
  }

  /**
   * OpportunitySkill deleteMany
   */
  export type OpportunitySkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpportunitySkills to delete
     */
    where?: OpportunitySkillWhereInput
  }

  /**
   * OpportunitySkill without action
   */
  export type OpportunitySkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunitySkill
     */
    select?: OpportunitySkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunitySkillInclude<ExtArgs> | null
  }


  /**
   * Model Application
   */

  export type AggregateApplication = {
    _count: ApplicationCountAggregateOutputType | null
    _min: ApplicationMinAggregateOutputType | null
    _max: ApplicationMaxAggregateOutputType | null
  }

  export type ApplicationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    opportunityId: string | null
    status: $Enums.ApplicationStatus | null
    coverLetter: string | null
    resumeUrl: string | null
    appliedAt: Date | null
    updatedAt: Date | null
  }

  export type ApplicationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    opportunityId: string | null
    status: $Enums.ApplicationStatus | null
    coverLetter: string | null
    resumeUrl: string | null
    appliedAt: Date | null
    updatedAt: Date | null
  }

  export type ApplicationCountAggregateOutputType = {
    id: number
    userId: number
    opportunityId: number
    status: number
    coverLetter: number
    resumeUrl: number
    appliedAt: number
    updatedAt: number
    _all: number
  }


  export type ApplicationMinAggregateInputType = {
    id?: true
    userId?: true
    opportunityId?: true
    status?: true
    coverLetter?: true
    resumeUrl?: true
    appliedAt?: true
    updatedAt?: true
  }

  export type ApplicationMaxAggregateInputType = {
    id?: true
    userId?: true
    opportunityId?: true
    status?: true
    coverLetter?: true
    resumeUrl?: true
    appliedAt?: true
    updatedAt?: true
  }

  export type ApplicationCountAggregateInputType = {
    id?: true
    userId?: true
    opportunityId?: true
    status?: true
    coverLetter?: true
    resumeUrl?: true
    appliedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Application to aggregate.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Applications
    **/
    _count?: true | ApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationMaxAggregateInputType
  }

  export type GetApplicationAggregateType<T extends ApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplication[P]>
      : GetScalarType<T[P], AggregateApplication[P]>
  }




  export type ApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithAggregationInput | ApplicationOrderByWithAggregationInput[]
    by: ApplicationScalarFieldEnum[] | ApplicationScalarFieldEnum
    having?: ApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationCountAggregateInputType | true
    _min?: ApplicationMinAggregateInputType
    _max?: ApplicationMaxAggregateInputType
  }

  export type ApplicationGroupByOutputType = {
    id: string
    userId: string
    opportunityId: string
    status: $Enums.ApplicationStatus
    coverLetter: string | null
    resumeUrl: string | null
    appliedAt: Date
    updatedAt: Date
    _count: ApplicationCountAggregateOutputType | null
    _min: ApplicationMinAggregateOutputType | null
    _max: ApplicationMaxAggregateOutputType | null
  }

  type GetApplicationGroupByPayload<T extends ApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
        }
      >
    >


  export type ApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    opportunityId?: boolean
    status?: boolean
    coverLetter?: boolean
    resumeUrl?: boolean
    appliedAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["application"]>

  export type ApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    opportunityId?: boolean
    status?: boolean
    coverLetter?: boolean
    resumeUrl?: boolean
    appliedAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["application"]>

  export type ApplicationSelectScalar = {
    id?: boolean
    userId?: boolean
    opportunityId?: boolean
    status?: boolean
    coverLetter?: boolean
    resumeUrl?: boolean
    appliedAt?: boolean
    updatedAt?: boolean
  }

  export type ApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }
  export type ApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }

  export type $ApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Application"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      opportunity: Prisma.$OpportunityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      opportunityId: string
      status: $Enums.ApplicationStatus
      coverLetter: string | null
      resumeUrl: string | null
      appliedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["application"]>
    composites: {}
  }

  type ApplicationGetPayload<S extends boolean | null | undefined | ApplicationDefaultArgs> = $Result.GetResult<Prisma.$ApplicationPayload, S>

  type ApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApplicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApplicationCountAggregateInputType | true
    }

  export interface ApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Application'], meta: { name: 'Application' } }
    /**
     * Find zero or one Application that matches the filter.
     * @param {ApplicationFindUniqueArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApplicationFindUniqueArgs>(args: SelectSubset<T, ApplicationFindUniqueArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Application that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApplicationFindUniqueOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, ApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Application that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApplicationFindFirstArgs>(args?: SelectSubset<T, ApplicationFindFirstArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Application that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, ApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applications
     * const applications = await prisma.application.findMany()
     * 
     * // Get first 10 Applications
     * const applications = await prisma.application.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const applicationWithIdOnly = await prisma.application.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApplicationFindManyArgs>(args?: SelectSubset<T, ApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Application.
     * @param {ApplicationCreateArgs} args - Arguments to create a Application.
     * @example
     * // Create one Application
     * const Application = await prisma.application.create({
     *   data: {
     *     // ... data to create a Application
     *   }
     * })
     * 
     */
    create<T extends ApplicationCreateArgs>(args: SelectSubset<T, ApplicationCreateArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Applications.
     * @param {ApplicationCreateManyArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const application = await prisma.application.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApplicationCreateManyArgs>(args?: SelectSubset<T, ApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Applications and returns the data saved in the database.
     * @param {ApplicationCreateManyAndReturnArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const application = await prisma.application.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Applications and only return the `id`
     * const applicationWithIdOnly = await prisma.application.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, ApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Application.
     * @param {ApplicationDeleteArgs} args - Arguments to delete one Application.
     * @example
     * // Delete one Application
     * const Application = await prisma.application.delete({
     *   where: {
     *     // ... filter to delete one Application
     *   }
     * })
     * 
     */
    delete<T extends ApplicationDeleteArgs>(args: SelectSubset<T, ApplicationDeleteArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Application.
     * @param {ApplicationUpdateArgs} args - Arguments to update one Application.
     * @example
     * // Update one Application
     * const application = await prisma.application.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApplicationUpdateArgs>(args: SelectSubset<T, ApplicationUpdateArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Applications.
     * @param {ApplicationDeleteManyArgs} args - Arguments to filter Applications to delete.
     * @example
     * // Delete a few Applications
     * const { count } = await prisma.application.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApplicationDeleteManyArgs>(args?: SelectSubset<T, ApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applications
     * const application = await prisma.application.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApplicationUpdateManyArgs>(args: SelectSubset<T, ApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Application.
     * @param {ApplicationUpsertArgs} args - Arguments to update or create a Application.
     * @example
     * // Update or create a Application
     * const application = await prisma.application.upsert({
     *   create: {
     *     // ... data to create a Application
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Application we want to update
     *   }
     * })
     */
    upsert<T extends ApplicationUpsertArgs>(args: SelectSubset<T, ApplicationUpsertArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationCountArgs} args - Arguments to filter Applications to count.
     * @example
     * // Count the number of Applications
     * const count = await prisma.application.count({
     *   where: {
     *     // ... the filter for the Applications we want to count
     *   }
     * })
    **/
    count<T extends ApplicationCountArgs>(
      args?: Subset<T, ApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationAggregateArgs>(args: Subset<T, ApplicationAggregateArgs>): Prisma.PrismaPromise<GetApplicationAggregateType<T>>

    /**
     * Group by Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApplicationGroupByArgs['orderBy'] }
        : { orderBy?: ApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Application model
   */
  readonly fields: ApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Application.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    opportunity<T extends OpportunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OpportunityDefaultArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Application model
   */ 
  interface ApplicationFieldRefs {
    readonly id: FieldRef<"Application", 'String'>
    readonly userId: FieldRef<"Application", 'String'>
    readonly opportunityId: FieldRef<"Application", 'String'>
    readonly status: FieldRef<"Application", 'ApplicationStatus'>
    readonly coverLetter: FieldRef<"Application", 'String'>
    readonly resumeUrl: FieldRef<"Application", 'String'>
    readonly appliedAt: FieldRef<"Application", 'DateTime'>
    readonly updatedAt: FieldRef<"Application", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Application findUnique
   */
  export type ApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application findUniqueOrThrow
   */
  export type ApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application findFirst
   */
  export type ApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application findFirstOrThrow
   */
  export type ApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application findMany
   */
  export type ApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Applications to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application create
   */
  export type ApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Application.
     */
    data: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>
  }

  /**
   * Application createMany
   */
  export type ApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Applications.
     */
    data: ApplicationCreateManyInput | ApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Application createManyAndReturn
   */
  export type ApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Applications.
     */
    data: ApplicationCreateManyInput | ApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Application update
   */
  export type ApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Application.
     */
    data: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>
    /**
     * Choose, which Application to update.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application updateMany
   */
  export type ApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Applications.
     */
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyInput>
    /**
     * Filter which Applications to update
     */
    where?: ApplicationWhereInput
  }

  /**
   * Application upsert
   */
  export type ApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Application to update in case it exists.
     */
    where: ApplicationWhereUniqueInput
    /**
     * In case the Application found by the `where` argument doesn't exist, create a new Application with this data.
     */
    create: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>
    /**
     * In case the Application was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>
  }

  /**
   * Application delete
   */
  export type ApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter which Application to delete.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application deleteMany
   */
  export type ApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Applications to delete
     */
    where?: ApplicationWhereInput
  }

  /**
   * Application without action
   */
  export type ApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
  }


  /**
   * Model Connection
   */

  export type AggregateConnection = {
    _count: ConnectionCountAggregateOutputType | null
    _avg: ConnectionAvgAggregateOutputType | null
    _sum: ConnectionSumAggregateOutputType | null
    _min: ConnectionMinAggregateOutputType | null
    _max: ConnectionMaxAggregateOutputType | null
  }

  export type ConnectionAvgAggregateOutputType = {
    mutualConnections: number | null
  }

  export type ConnectionSumAggregateOutputType = {
    mutualConnections: number | null
  }

  export type ConnectionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    connectedUserId: string | null
    type: $Enums.ConnectionType | null
    mutualConnections: number | null
    connectedAt: Date | null
  }

  export type ConnectionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    connectedUserId: string | null
    type: $Enums.ConnectionType | null
    mutualConnections: number | null
    connectedAt: Date | null
  }

  export type ConnectionCountAggregateOutputType = {
    id: number
    userId: number
    connectedUserId: number
    type: number
    mutualConnections: number
    connectedAt: number
    _all: number
  }


  export type ConnectionAvgAggregateInputType = {
    mutualConnections?: true
  }

  export type ConnectionSumAggregateInputType = {
    mutualConnections?: true
  }

  export type ConnectionMinAggregateInputType = {
    id?: true
    userId?: true
    connectedUserId?: true
    type?: true
    mutualConnections?: true
    connectedAt?: true
  }

  export type ConnectionMaxAggregateInputType = {
    id?: true
    userId?: true
    connectedUserId?: true
    type?: true
    mutualConnections?: true
    connectedAt?: true
  }

  export type ConnectionCountAggregateInputType = {
    id?: true
    userId?: true
    connectedUserId?: true
    type?: true
    mutualConnections?: true
    connectedAt?: true
    _all?: true
  }

  export type ConnectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Connection to aggregate.
     */
    where?: ConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Connections
    **/
    _count?: true | ConnectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConnectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConnectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConnectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConnectionMaxAggregateInputType
  }

  export type GetConnectionAggregateType<T extends ConnectionAggregateArgs> = {
        [P in keyof T & keyof AggregateConnection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConnection[P]>
      : GetScalarType<T[P], AggregateConnection[P]>
  }




  export type ConnectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionWhereInput
    orderBy?: ConnectionOrderByWithAggregationInput | ConnectionOrderByWithAggregationInput[]
    by: ConnectionScalarFieldEnum[] | ConnectionScalarFieldEnum
    having?: ConnectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConnectionCountAggregateInputType | true
    _avg?: ConnectionAvgAggregateInputType
    _sum?: ConnectionSumAggregateInputType
    _min?: ConnectionMinAggregateInputType
    _max?: ConnectionMaxAggregateInputType
  }

  export type ConnectionGroupByOutputType = {
    id: string
    userId: string
    connectedUserId: string
    type: $Enums.ConnectionType
    mutualConnections: number
    connectedAt: Date
    _count: ConnectionCountAggregateOutputType | null
    _avg: ConnectionAvgAggregateOutputType | null
    _sum: ConnectionSumAggregateOutputType | null
    _min: ConnectionMinAggregateOutputType | null
    _max: ConnectionMaxAggregateOutputType | null
  }

  type GetConnectionGroupByPayload<T extends ConnectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConnectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConnectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConnectionGroupByOutputType[P]>
            : GetScalarType<T[P], ConnectionGroupByOutputType[P]>
        }
      >
    >


  export type ConnectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    connectedUserId?: boolean
    type?: boolean
    mutualConnections?: boolean
    connectedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    connectedUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["connection"]>

  export type ConnectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    connectedUserId?: boolean
    type?: boolean
    mutualConnections?: boolean
    connectedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    connectedUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["connection"]>

  export type ConnectionSelectScalar = {
    id?: boolean
    userId?: boolean
    connectedUserId?: boolean
    type?: boolean
    mutualConnections?: boolean
    connectedAt?: boolean
  }

  export type ConnectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    connectedUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ConnectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    connectedUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ConnectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Connection"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      connectedUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      connectedUserId: string
      type: $Enums.ConnectionType
      mutualConnections: number
      connectedAt: Date
    }, ExtArgs["result"]["connection"]>
    composites: {}
  }

  type ConnectionGetPayload<S extends boolean | null | undefined | ConnectionDefaultArgs> = $Result.GetResult<Prisma.$ConnectionPayload, S>

  type ConnectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConnectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConnectionCountAggregateInputType | true
    }

  export interface ConnectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Connection'], meta: { name: 'Connection' } }
    /**
     * Find zero or one Connection that matches the filter.
     * @param {ConnectionFindUniqueArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConnectionFindUniqueArgs>(args: SelectSubset<T, ConnectionFindUniqueArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Connection that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConnectionFindUniqueOrThrowArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConnectionFindUniqueOrThrowArgs>(args: SelectSubset<T, ConnectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Connection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionFindFirstArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConnectionFindFirstArgs>(args?: SelectSubset<T, ConnectionFindFirstArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Connection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionFindFirstOrThrowArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConnectionFindFirstOrThrowArgs>(args?: SelectSubset<T, ConnectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Connections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Connections
     * const connections = await prisma.connection.findMany()
     * 
     * // Get first 10 Connections
     * const connections = await prisma.connection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const connectionWithIdOnly = await prisma.connection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConnectionFindManyArgs>(args?: SelectSubset<T, ConnectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Connection.
     * @param {ConnectionCreateArgs} args - Arguments to create a Connection.
     * @example
     * // Create one Connection
     * const Connection = await prisma.connection.create({
     *   data: {
     *     // ... data to create a Connection
     *   }
     * })
     * 
     */
    create<T extends ConnectionCreateArgs>(args: SelectSubset<T, ConnectionCreateArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Connections.
     * @param {ConnectionCreateManyArgs} args - Arguments to create many Connections.
     * @example
     * // Create many Connections
     * const connection = await prisma.connection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConnectionCreateManyArgs>(args?: SelectSubset<T, ConnectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Connections and returns the data saved in the database.
     * @param {ConnectionCreateManyAndReturnArgs} args - Arguments to create many Connections.
     * @example
     * // Create many Connections
     * const connection = await prisma.connection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Connections and only return the `id`
     * const connectionWithIdOnly = await prisma.connection.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConnectionCreateManyAndReturnArgs>(args?: SelectSubset<T, ConnectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Connection.
     * @param {ConnectionDeleteArgs} args - Arguments to delete one Connection.
     * @example
     * // Delete one Connection
     * const Connection = await prisma.connection.delete({
     *   where: {
     *     // ... filter to delete one Connection
     *   }
     * })
     * 
     */
    delete<T extends ConnectionDeleteArgs>(args: SelectSubset<T, ConnectionDeleteArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Connection.
     * @param {ConnectionUpdateArgs} args - Arguments to update one Connection.
     * @example
     * // Update one Connection
     * const connection = await prisma.connection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConnectionUpdateArgs>(args: SelectSubset<T, ConnectionUpdateArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Connections.
     * @param {ConnectionDeleteManyArgs} args - Arguments to filter Connections to delete.
     * @example
     * // Delete a few Connections
     * const { count } = await prisma.connection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConnectionDeleteManyArgs>(args?: SelectSubset<T, ConnectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Connections
     * const connection = await prisma.connection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConnectionUpdateManyArgs>(args: SelectSubset<T, ConnectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Connection.
     * @param {ConnectionUpsertArgs} args - Arguments to update or create a Connection.
     * @example
     * // Update or create a Connection
     * const connection = await prisma.connection.upsert({
     *   create: {
     *     // ... data to create a Connection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Connection we want to update
     *   }
     * })
     */
    upsert<T extends ConnectionUpsertArgs>(args: SelectSubset<T, ConnectionUpsertArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionCountArgs} args - Arguments to filter Connections to count.
     * @example
     * // Count the number of Connections
     * const count = await prisma.connection.count({
     *   where: {
     *     // ... the filter for the Connections we want to count
     *   }
     * })
    **/
    count<T extends ConnectionCountArgs>(
      args?: Subset<T, ConnectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConnectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Connection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConnectionAggregateArgs>(args: Subset<T, ConnectionAggregateArgs>): Prisma.PrismaPromise<GetConnectionAggregateType<T>>

    /**
     * Group by Connection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConnectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConnectionGroupByArgs['orderBy'] }
        : { orderBy?: ConnectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConnectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConnectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Connection model
   */
  readonly fields: ConnectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Connection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConnectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    connectedUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Connection model
   */ 
  interface ConnectionFieldRefs {
    readonly id: FieldRef<"Connection", 'String'>
    readonly userId: FieldRef<"Connection", 'String'>
    readonly connectedUserId: FieldRef<"Connection", 'String'>
    readonly type: FieldRef<"Connection", 'ConnectionType'>
    readonly mutualConnections: FieldRef<"Connection", 'Int'>
    readonly connectedAt: FieldRef<"Connection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Connection findUnique
   */
  export type ConnectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connection to fetch.
     */
    where: ConnectionWhereUniqueInput
  }

  /**
   * Connection findUniqueOrThrow
   */
  export type ConnectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connection to fetch.
     */
    where: ConnectionWhereUniqueInput
  }

  /**
   * Connection findFirst
   */
  export type ConnectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connection to fetch.
     */
    where?: ConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Connections.
     */
    cursor?: ConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Connections.
     */
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * Connection findFirstOrThrow
   */
  export type ConnectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connection to fetch.
     */
    where?: ConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Connections.
     */
    cursor?: ConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Connections.
     */
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * Connection findMany
   */
  export type ConnectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connections to fetch.
     */
    where?: ConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Connections.
     */
    cursor?: ConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Connections.
     */
    skip?: number
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * Connection create
   */
  export type ConnectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Connection.
     */
    data: XOR<ConnectionCreateInput, ConnectionUncheckedCreateInput>
  }

  /**
   * Connection createMany
   */
  export type ConnectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Connections.
     */
    data: ConnectionCreateManyInput | ConnectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Connection createManyAndReturn
   */
  export type ConnectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Connections.
     */
    data: ConnectionCreateManyInput | ConnectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Connection update
   */
  export type ConnectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Connection.
     */
    data: XOR<ConnectionUpdateInput, ConnectionUncheckedUpdateInput>
    /**
     * Choose, which Connection to update.
     */
    where: ConnectionWhereUniqueInput
  }

  /**
   * Connection updateMany
   */
  export type ConnectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Connections.
     */
    data: XOR<ConnectionUpdateManyMutationInput, ConnectionUncheckedUpdateManyInput>
    /**
     * Filter which Connections to update
     */
    where?: ConnectionWhereInput
  }

  /**
   * Connection upsert
   */
  export type ConnectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Connection to update in case it exists.
     */
    where: ConnectionWhereUniqueInput
    /**
     * In case the Connection found by the `where` argument doesn't exist, create a new Connection with this data.
     */
    create: XOR<ConnectionCreateInput, ConnectionUncheckedCreateInput>
    /**
     * In case the Connection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConnectionUpdateInput, ConnectionUncheckedUpdateInput>
  }

  /**
   * Connection delete
   */
  export type ConnectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter which Connection to delete.
     */
    where: ConnectionWhereUniqueInput
  }

  /**
   * Connection deleteMany
   */
  export type ConnectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Connections to delete
     */
    where?: ConnectionWhereInput
  }

  /**
   * Connection without action
   */
  export type ConnectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
  }


  /**
   * Model ConnectionRequest
   */

  export type AggregateConnectionRequest = {
    _count: ConnectionRequestCountAggregateOutputType | null
    _min: ConnectionRequestMinAggregateOutputType | null
    _max: ConnectionRequestMaxAggregateOutputType | null
  }

  export type ConnectionRequestMinAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    message: string | null
    status: $Enums.ConnectionStatus | null
    requestedAt: Date | null
    respondedAt: Date | null
  }

  export type ConnectionRequestMaxAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    message: string | null
    status: $Enums.ConnectionStatus | null
    requestedAt: Date | null
    respondedAt: Date | null
  }

  export type ConnectionRequestCountAggregateOutputType = {
    id: number
    senderId: number
    receiverId: number
    message: number
    status: number
    requestedAt: number
    respondedAt: number
    _all: number
  }


  export type ConnectionRequestMinAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    message?: true
    status?: true
    requestedAt?: true
    respondedAt?: true
  }

  export type ConnectionRequestMaxAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    message?: true
    status?: true
    requestedAt?: true
    respondedAt?: true
  }

  export type ConnectionRequestCountAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    message?: true
    status?: true
    requestedAt?: true
    respondedAt?: true
    _all?: true
  }

  export type ConnectionRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConnectionRequest to aggregate.
     */
    where?: ConnectionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectionRequests to fetch.
     */
    orderBy?: ConnectionRequestOrderByWithRelationInput | ConnectionRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConnectionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectionRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConnectionRequests
    **/
    _count?: true | ConnectionRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConnectionRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConnectionRequestMaxAggregateInputType
  }

  export type GetConnectionRequestAggregateType<T extends ConnectionRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateConnectionRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConnectionRequest[P]>
      : GetScalarType<T[P], AggregateConnectionRequest[P]>
  }




  export type ConnectionRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionRequestWhereInput
    orderBy?: ConnectionRequestOrderByWithAggregationInput | ConnectionRequestOrderByWithAggregationInput[]
    by: ConnectionRequestScalarFieldEnum[] | ConnectionRequestScalarFieldEnum
    having?: ConnectionRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConnectionRequestCountAggregateInputType | true
    _min?: ConnectionRequestMinAggregateInputType
    _max?: ConnectionRequestMaxAggregateInputType
  }

  export type ConnectionRequestGroupByOutputType = {
    id: string
    senderId: string
    receiverId: string
    message: string | null
    status: $Enums.ConnectionStatus
    requestedAt: Date
    respondedAt: Date | null
    _count: ConnectionRequestCountAggregateOutputType | null
    _min: ConnectionRequestMinAggregateOutputType | null
    _max: ConnectionRequestMaxAggregateOutputType | null
  }

  type GetConnectionRequestGroupByPayload<T extends ConnectionRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConnectionRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConnectionRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConnectionRequestGroupByOutputType[P]>
            : GetScalarType<T[P], ConnectionRequestGroupByOutputType[P]>
        }
      >
    >


  export type ConnectionRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    message?: boolean
    status?: boolean
    requestedAt?: boolean
    respondedAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["connectionRequest"]>

  export type ConnectionRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    message?: boolean
    status?: boolean
    requestedAt?: boolean
    respondedAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["connectionRequest"]>

  export type ConnectionRequestSelectScalar = {
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    message?: boolean
    status?: boolean
    requestedAt?: boolean
    respondedAt?: boolean
  }

  export type ConnectionRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ConnectionRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ConnectionRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConnectionRequest"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      receiver: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      senderId: string
      receiverId: string
      message: string | null
      status: $Enums.ConnectionStatus
      requestedAt: Date
      respondedAt: Date | null
    }, ExtArgs["result"]["connectionRequest"]>
    composites: {}
  }

  type ConnectionRequestGetPayload<S extends boolean | null | undefined | ConnectionRequestDefaultArgs> = $Result.GetResult<Prisma.$ConnectionRequestPayload, S>

  type ConnectionRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConnectionRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConnectionRequestCountAggregateInputType | true
    }

  export interface ConnectionRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConnectionRequest'], meta: { name: 'ConnectionRequest' } }
    /**
     * Find zero or one ConnectionRequest that matches the filter.
     * @param {ConnectionRequestFindUniqueArgs} args - Arguments to find a ConnectionRequest
     * @example
     * // Get one ConnectionRequest
     * const connectionRequest = await prisma.connectionRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConnectionRequestFindUniqueArgs>(args: SelectSubset<T, ConnectionRequestFindUniqueArgs<ExtArgs>>): Prisma__ConnectionRequestClient<$Result.GetResult<Prisma.$ConnectionRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConnectionRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConnectionRequestFindUniqueOrThrowArgs} args - Arguments to find a ConnectionRequest
     * @example
     * // Get one ConnectionRequest
     * const connectionRequest = await prisma.connectionRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConnectionRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, ConnectionRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConnectionRequestClient<$Result.GetResult<Prisma.$ConnectionRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConnectionRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionRequestFindFirstArgs} args - Arguments to find a ConnectionRequest
     * @example
     * // Get one ConnectionRequest
     * const connectionRequest = await prisma.connectionRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConnectionRequestFindFirstArgs>(args?: SelectSubset<T, ConnectionRequestFindFirstArgs<ExtArgs>>): Prisma__ConnectionRequestClient<$Result.GetResult<Prisma.$ConnectionRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConnectionRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionRequestFindFirstOrThrowArgs} args - Arguments to find a ConnectionRequest
     * @example
     * // Get one ConnectionRequest
     * const connectionRequest = await prisma.connectionRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConnectionRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, ConnectionRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConnectionRequestClient<$Result.GetResult<Prisma.$ConnectionRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConnectionRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConnectionRequests
     * const connectionRequests = await prisma.connectionRequest.findMany()
     * 
     * // Get first 10 ConnectionRequests
     * const connectionRequests = await prisma.connectionRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const connectionRequestWithIdOnly = await prisma.connectionRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConnectionRequestFindManyArgs>(args?: SelectSubset<T, ConnectionRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConnectionRequest.
     * @param {ConnectionRequestCreateArgs} args - Arguments to create a ConnectionRequest.
     * @example
     * // Create one ConnectionRequest
     * const ConnectionRequest = await prisma.connectionRequest.create({
     *   data: {
     *     // ... data to create a ConnectionRequest
     *   }
     * })
     * 
     */
    create<T extends ConnectionRequestCreateArgs>(args: SelectSubset<T, ConnectionRequestCreateArgs<ExtArgs>>): Prisma__ConnectionRequestClient<$Result.GetResult<Prisma.$ConnectionRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConnectionRequests.
     * @param {ConnectionRequestCreateManyArgs} args - Arguments to create many ConnectionRequests.
     * @example
     * // Create many ConnectionRequests
     * const connectionRequest = await prisma.connectionRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConnectionRequestCreateManyArgs>(args?: SelectSubset<T, ConnectionRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConnectionRequests and returns the data saved in the database.
     * @param {ConnectionRequestCreateManyAndReturnArgs} args - Arguments to create many ConnectionRequests.
     * @example
     * // Create many ConnectionRequests
     * const connectionRequest = await prisma.connectionRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConnectionRequests and only return the `id`
     * const connectionRequestWithIdOnly = await prisma.connectionRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConnectionRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, ConnectionRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConnectionRequest.
     * @param {ConnectionRequestDeleteArgs} args - Arguments to delete one ConnectionRequest.
     * @example
     * // Delete one ConnectionRequest
     * const ConnectionRequest = await prisma.connectionRequest.delete({
     *   where: {
     *     // ... filter to delete one ConnectionRequest
     *   }
     * })
     * 
     */
    delete<T extends ConnectionRequestDeleteArgs>(args: SelectSubset<T, ConnectionRequestDeleteArgs<ExtArgs>>): Prisma__ConnectionRequestClient<$Result.GetResult<Prisma.$ConnectionRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConnectionRequest.
     * @param {ConnectionRequestUpdateArgs} args - Arguments to update one ConnectionRequest.
     * @example
     * // Update one ConnectionRequest
     * const connectionRequest = await prisma.connectionRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConnectionRequestUpdateArgs>(args: SelectSubset<T, ConnectionRequestUpdateArgs<ExtArgs>>): Prisma__ConnectionRequestClient<$Result.GetResult<Prisma.$ConnectionRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConnectionRequests.
     * @param {ConnectionRequestDeleteManyArgs} args - Arguments to filter ConnectionRequests to delete.
     * @example
     * // Delete a few ConnectionRequests
     * const { count } = await prisma.connectionRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConnectionRequestDeleteManyArgs>(args?: SelectSubset<T, ConnectionRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConnectionRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConnectionRequests
     * const connectionRequest = await prisma.connectionRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConnectionRequestUpdateManyArgs>(args: SelectSubset<T, ConnectionRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConnectionRequest.
     * @param {ConnectionRequestUpsertArgs} args - Arguments to update or create a ConnectionRequest.
     * @example
     * // Update or create a ConnectionRequest
     * const connectionRequest = await prisma.connectionRequest.upsert({
     *   create: {
     *     // ... data to create a ConnectionRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConnectionRequest we want to update
     *   }
     * })
     */
    upsert<T extends ConnectionRequestUpsertArgs>(args: SelectSubset<T, ConnectionRequestUpsertArgs<ExtArgs>>): Prisma__ConnectionRequestClient<$Result.GetResult<Prisma.$ConnectionRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConnectionRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionRequestCountArgs} args - Arguments to filter ConnectionRequests to count.
     * @example
     * // Count the number of ConnectionRequests
     * const count = await prisma.connectionRequest.count({
     *   where: {
     *     // ... the filter for the ConnectionRequests we want to count
     *   }
     * })
    **/
    count<T extends ConnectionRequestCountArgs>(
      args?: Subset<T, ConnectionRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConnectionRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConnectionRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConnectionRequestAggregateArgs>(args: Subset<T, ConnectionRequestAggregateArgs>): Prisma.PrismaPromise<GetConnectionRequestAggregateType<T>>

    /**
     * Group by ConnectionRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConnectionRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConnectionRequestGroupByArgs['orderBy'] }
        : { orderBy?: ConnectionRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConnectionRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConnectionRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConnectionRequest model
   */
  readonly fields: ConnectionRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConnectionRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConnectionRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    receiver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConnectionRequest model
   */ 
  interface ConnectionRequestFieldRefs {
    readonly id: FieldRef<"ConnectionRequest", 'String'>
    readonly senderId: FieldRef<"ConnectionRequest", 'String'>
    readonly receiverId: FieldRef<"ConnectionRequest", 'String'>
    readonly message: FieldRef<"ConnectionRequest", 'String'>
    readonly status: FieldRef<"ConnectionRequest", 'ConnectionStatus'>
    readonly requestedAt: FieldRef<"ConnectionRequest", 'DateTime'>
    readonly respondedAt: FieldRef<"ConnectionRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConnectionRequest findUnique
   */
  export type ConnectionRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionRequest
     */
    select?: ConnectionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionRequestInclude<ExtArgs> | null
    /**
     * Filter, which ConnectionRequest to fetch.
     */
    where: ConnectionRequestWhereUniqueInput
  }

  /**
   * ConnectionRequest findUniqueOrThrow
   */
  export type ConnectionRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionRequest
     */
    select?: ConnectionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionRequestInclude<ExtArgs> | null
    /**
     * Filter, which ConnectionRequest to fetch.
     */
    where: ConnectionRequestWhereUniqueInput
  }

  /**
   * ConnectionRequest findFirst
   */
  export type ConnectionRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionRequest
     */
    select?: ConnectionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionRequestInclude<ExtArgs> | null
    /**
     * Filter, which ConnectionRequest to fetch.
     */
    where?: ConnectionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectionRequests to fetch.
     */
    orderBy?: ConnectionRequestOrderByWithRelationInput | ConnectionRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConnectionRequests.
     */
    cursor?: ConnectionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectionRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConnectionRequests.
     */
    distinct?: ConnectionRequestScalarFieldEnum | ConnectionRequestScalarFieldEnum[]
  }

  /**
   * ConnectionRequest findFirstOrThrow
   */
  export type ConnectionRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionRequest
     */
    select?: ConnectionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionRequestInclude<ExtArgs> | null
    /**
     * Filter, which ConnectionRequest to fetch.
     */
    where?: ConnectionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectionRequests to fetch.
     */
    orderBy?: ConnectionRequestOrderByWithRelationInput | ConnectionRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConnectionRequests.
     */
    cursor?: ConnectionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectionRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConnectionRequests.
     */
    distinct?: ConnectionRequestScalarFieldEnum | ConnectionRequestScalarFieldEnum[]
  }

  /**
   * ConnectionRequest findMany
   */
  export type ConnectionRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionRequest
     */
    select?: ConnectionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionRequestInclude<ExtArgs> | null
    /**
     * Filter, which ConnectionRequests to fetch.
     */
    where?: ConnectionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectionRequests to fetch.
     */
    orderBy?: ConnectionRequestOrderByWithRelationInput | ConnectionRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConnectionRequests.
     */
    cursor?: ConnectionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectionRequests.
     */
    skip?: number
    distinct?: ConnectionRequestScalarFieldEnum | ConnectionRequestScalarFieldEnum[]
  }

  /**
   * ConnectionRequest create
   */
  export type ConnectionRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionRequest
     */
    select?: ConnectionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a ConnectionRequest.
     */
    data: XOR<ConnectionRequestCreateInput, ConnectionRequestUncheckedCreateInput>
  }

  /**
   * ConnectionRequest createMany
   */
  export type ConnectionRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConnectionRequests.
     */
    data: ConnectionRequestCreateManyInput | ConnectionRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConnectionRequest createManyAndReturn
   */
  export type ConnectionRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionRequest
     */
    select?: ConnectionRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConnectionRequests.
     */
    data: ConnectionRequestCreateManyInput | ConnectionRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConnectionRequest update
   */
  export type ConnectionRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionRequest
     */
    select?: ConnectionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a ConnectionRequest.
     */
    data: XOR<ConnectionRequestUpdateInput, ConnectionRequestUncheckedUpdateInput>
    /**
     * Choose, which ConnectionRequest to update.
     */
    where: ConnectionRequestWhereUniqueInput
  }

  /**
   * ConnectionRequest updateMany
   */
  export type ConnectionRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConnectionRequests.
     */
    data: XOR<ConnectionRequestUpdateManyMutationInput, ConnectionRequestUncheckedUpdateManyInput>
    /**
     * Filter which ConnectionRequests to update
     */
    where?: ConnectionRequestWhereInput
  }

  /**
   * ConnectionRequest upsert
   */
  export type ConnectionRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionRequest
     */
    select?: ConnectionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the ConnectionRequest to update in case it exists.
     */
    where: ConnectionRequestWhereUniqueInput
    /**
     * In case the ConnectionRequest found by the `where` argument doesn't exist, create a new ConnectionRequest with this data.
     */
    create: XOR<ConnectionRequestCreateInput, ConnectionRequestUncheckedCreateInput>
    /**
     * In case the ConnectionRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConnectionRequestUpdateInput, ConnectionRequestUncheckedUpdateInput>
  }

  /**
   * ConnectionRequest delete
   */
  export type ConnectionRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionRequest
     */
    select?: ConnectionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionRequestInclude<ExtArgs> | null
    /**
     * Filter which ConnectionRequest to delete.
     */
    where: ConnectionRequestWhereUniqueInput
  }

  /**
   * ConnectionRequest deleteMany
   */
  export type ConnectionRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConnectionRequests to delete
     */
    where?: ConnectionRequestWhereInput
  }

  /**
   * ConnectionRequest without action
   */
  export type ConnectionRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionRequest
     */
    select?: ConnectionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionRequestInclude<ExtArgs> | null
  }


  /**
   * Model FeedItem
   */

  export type AggregateFeedItem = {
    _count: FeedItemCountAggregateOutputType | null
    _min: FeedItemMinAggregateOutputType | null
    _max: FeedItemMaxAggregateOutputType | null
  }

  export type FeedItemMinAggregateOutputType = {
    id: string | null
    type: $Enums.FeedItemType | null
    userId: string | null
    priority: $Enums.Priority | null
    title: string | null
    description: string | null
    image: string | null
    timestamp: Date | null
  }

  export type FeedItemMaxAggregateOutputType = {
    id: string | null
    type: $Enums.FeedItemType | null
    userId: string | null
    priority: $Enums.Priority | null
    title: string | null
    description: string | null
    image: string | null
    timestamp: Date | null
  }

  export type FeedItemCountAggregateOutputType = {
    id: number
    type: number
    userId: number
    priority: number
    title: number
    description: number
    image: number
    data: number
    timestamp: number
    _all: number
  }


  export type FeedItemMinAggregateInputType = {
    id?: true
    type?: true
    userId?: true
    priority?: true
    title?: true
    description?: true
    image?: true
    timestamp?: true
  }

  export type FeedItemMaxAggregateInputType = {
    id?: true
    type?: true
    userId?: true
    priority?: true
    title?: true
    description?: true
    image?: true
    timestamp?: true
  }

  export type FeedItemCountAggregateInputType = {
    id?: true
    type?: true
    userId?: true
    priority?: true
    title?: true
    description?: true
    image?: true
    data?: true
    timestamp?: true
    _all?: true
  }

  export type FeedItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedItem to aggregate.
     */
    where?: FeedItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedItems to fetch.
     */
    orderBy?: FeedItemOrderByWithRelationInput | FeedItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeedItems
    **/
    _count?: true | FeedItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedItemMaxAggregateInputType
  }

  export type GetFeedItemAggregateType<T extends FeedItemAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedItem[P]>
      : GetScalarType<T[P], AggregateFeedItem[P]>
  }




  export type FeedItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedItemWhereInput
    orderBy?: FeedItemOrderByWithAggregationInput | FeedItemOrderByWithAggregationInput[]
    by: FeedItemScalarFieldEnum[] | FeedItemScalarFieldEnum
    having?: FeedItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedItemCountAggregateInputType | true
    _min?: FeedItemMinAggregateInputType
    _max?: FeedItemMaxAggregateInputType
  }

  export type FeedItemGroupByOutputType = {
    id: string
    type: $Enums.FeedItemType
    userId: string
    priority: $Enums.Priority
    title: string
    description: string
    image: string | null
    data: JsonValue | null
    timestamp: Date
    _count: FeedItemCountAggregateOutputType | null
    _min: FeedItemMinAggregateOutputType | null
    _max: FeedItemMaxAggregateOutputType | null
  }

  type GetFeedItemGroupByPayload<T extends FeedItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedItemGroupByOutputType[P]>
            : GetScalarType<T[P], FeedItemGroupByOutputType[P]>
        }
      >
    >


  export type FeedItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    userId?: boolean
    priority?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    data?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedItem"]>

  export type FeedItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    userId?: boolean
    priority?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    data?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedItem"]>

  export type FeedItemSelectScalar = {
    id?: boolean
    type?: boolean
    userId?: boolean
    priority?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    data?: boolean
    timestamp?: boolean
  }

  export type FeedItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FeedItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FeedItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeedItem"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.FeedItemType
      userId: string
      priority: $Enums.Priority
      title: string
      description: string
      image: string | null
      data: Prisma.JsonValue | null
      timestamp: Date
    }, ExtArgs["result"]["feedItem"]>
    composites: {}
  }

  type FeedItemGetPayload<S extends boolean | null | undefined | FeedItemDefaultArgs> = $Result.GetResult<Prisma.$FeedItemPayload, S>

  type FeedItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeedItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeedItemCountAggregateInputType | true
    }

  export interface FeedItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeedItem'], meta: { name: 'FeedItem' } }
    /**
     * Find zero or one FeedItem that matches the filter.
     * @param {FeedItemFindUniqueArgs} args - Arguments to find a FeedItem
     * @example
     * // Get one FeedItem
     * const feedItem = await prisma.feedItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedItemFindUniqueArgs>(args: SelectSubset<T, FeedItemFindUniqueArgs<ExtArgs>>): Prisma__FeedItemClient<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FeedItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FeedItemFindUniqueOrThrowArgs} args - Arguments to find a FeedItem
     * @example
     * // Get one FeedItem
     * const feedItem = await prisma.feedItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedItemFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedItemClient<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FeedItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedItemFindFirstArgs} args - Arguments to find a FeedItem
     * @example
     * // Get one FeedItem
     * const feedItem = await prisma.feedItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedItemFindFirstArgs>(args?: SelectSubset<T, FeedItemFindFirstArgs<ExtArgs>>): Prisma__FeedItemClient<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FeedItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedItemFindFirstOrThrowArgs} args - Arguments to find a FeedItem
     * @example
     * // Get one FeedItem
     * const feedItem = await prisma.feedItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedItemFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedItemClient<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FeedItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeedItems
     * const feedItems = await prisma.feedItem.findMany()
     * 
     * // Get first 10 FeedItems
     * const feedItems = await prisma.feedItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedItemWithIdOnly = await prisma.feedItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedItemFindManyArgs>(args?: SelectSubset<T, FeedItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FeedItem.
     * @param {FeedItemCreateArgs} args - Arguments to create a FeedItem.
     * @example
     * // Create one FeedItem
     * const FeedItem = await prisma.feedItem.create({
     *   data: {
     *     // ... data to create a FeedItem
     *   }
     * })
     * 
     */
    create<T extends FeedItemCreateArgs>(args: SelectSubset<T, FeedItemCreateArgs<ExtArgs>>): Prisma__FeedItemClient<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FeedItems.
     * @param {FeedItemCreateManyArgs} args - Arguments to create many FeedItems.
     * @example
     * // Create many FeedItems
     * const feedItem = await prisma.feedItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedItemCreateManyArgs>(args?: SelectSubset<T, FeedItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeedItems and returns the data saved in the database.
     * @param {FeedItemCreateManyAndReturnArgs} args - Arguments to create many FeedItems.
     * @example
     * // Create many FeedItems
     * const feedItem = await prisma.feedItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeedItems and only return the `id`
     * const feedItemWithIdOnly = await prisma.feedItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedItemCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FeedItem.
     * @param {FeedItemDeleteArgs} args - Arguments to delete one FeedItem.
     * @example
     * // Delete one FeedItem
     * const FeedItem = await prisma.feedItem.delete({
     *   where: {
     *     // ... filter to delete one FeedItem
     *   }
     * })
     * 
     */
    delete<T extends FeedItemDeleteArgs>(args: SelectSubset<T, FeedItemDeleteArgs<ExtArgs>>): Prisma__FeedItemClient<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FeedItem.
     * @param {FeedItemUpdateArgs} args - Arguments to update one FeedItem.
     * @example
     * // Update one FeedItem
     * const feedItem = await prisma.feedItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedItemUpdateArgs>(args: SelectSubset<T, FeedItemUpdateArgs<ExtArgs>>): Prisma__FeedItemClient<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FeedItems.
     * @param {FeedItemDeleteManyArgs} args - Arguments to filter FeedItems to delete.
     * @example
     * // Delete a few FeedItems
     * const { count } = await prisma.feedItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedItemDeleteManyArgs>(args?: SelectSubset<T, FeedItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeedItems
     * const feedItem = await prisma.feedItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedItemUpdateManyArgs>(args: SelectSubset<T, FeedItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeedItem.
     * @param {FeedItemUpsertArgs} args - Arguments to update or create a FeedItem.
     * @example
     * // Update or create a FeedItem
     * const feedItem = await prisma.feedItem.upsert({
     *   create: {
     *     // ... data to create a FeedItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeedItem we want to update
     *   }
     * })
     */
    upsert<T extends FeedItemUpsertArgs>(args: SelectSubset<T, FeedItemUpsertArgs<ExtArgs>>): Prisma__FeedItemClient<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FeedItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedItemCountArgs} args - Arguments to filter FeedItems to count.
     * @example
     * // Count the number of FeedItems
     * const count = await prisma.feedItem.count({
     *   where: {
     *     // ... the filter for the FeedItems we want to count
     *   }
     * })
    **/
    count<T extends FeedItemCountArgs>(
      args?: Subset<T, FeedItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeedItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedItemAggregateArgs>(args: Subset<T, FeedItemAggregateArgs>): Prisma.PrismaPromise<GetFeedItemAggregateType<T>>

    /**
     * Group by FeedItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedItemGroupByArgs['orderBy'] }
        : { orderBy?: FeedItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeedItem model
   */
  readonly fields: FeedItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeedItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeedItem model
   */ 
  interface FeedItemFieldRefs {
    readonly id: FieldRef<"FeedItem", 'String'>
    readonly type: FieldRef<"FeedItem", 'FeedItemType'>
    readonly userId: FieldRef<"FeedItem", 'String'>
    readonly priority: FieldRef<"FeedItem", 'Priority'>
    readonly title: FieldRef<"FeedItem", 'String'>
    readonly description: FieldRef<"FeedItem", 'String'>
    readonly image: FieldRef<"FeedItem", 'String'>
    readonly data: FieldRef<"FeedItem", 'Json'>
    readonly timestamp: FieldRef<"FeedItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeedItem findUnique
   */
  export type FeedItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemInclude<ExtArgs> | null
    /**
     * Filter, which FeedItem to fetch.
     */
    where: FeedItemWhereUniqueInput
  }

  /**
   * FeedItem findUniqueOrThrow
   */
  export type FeedItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemInclude<ExtArgs> | null
    /**
     * Filter, which FeedItem to fetch.
     */
    where: FeedItemWhereUniqueInput
  }

  /**
   * FeedItem findFirst
   */
  export type FeedItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemInclude<ExtArgs> | null
    /**
     * Filter, which FeedItem to fetch.
     */
    where?: FeedItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedItems to fetch.
     */
    orderBy?: FeedItemOrderByWithRelationInput | FeedItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedItems.
     */
    cursor?: FeedItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedItems.
     */
    distinct?: FeedItemScalarFieldEnum | FeedItemScalarFieldEnum[]
  }

  /**
   * FeedItem findFirstOrThrow
   */
  export type FeedItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemInclude<ExtArgs> | null
    /**
     * Filter, which FeedItem to fetch.
     */
    where?: FeedItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedItems to fetch.
     */
    orderBy?: FeedItemOrderByWithRelationInput | FeedItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedItems.
     */
    cursor?: FeedItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedItems.
     */
    distinct?: FeedItemScalarFieldEnum | FeedItemScalarFieldEnum[]
  }

  /**
   * FeedItem findMany
   */
  export type FeedItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemInclude<ExtArgs> | null
    /**
     * Filter, which FeedItems to fetch.
     */
    where?: FeedItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedItems to fetch.
     */
    orderBy?: FeedItemOrderByWithRelationInput | FeedItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeedItems.
     */
    cursor?: FeedItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedItems.
     */
    skip?: number
    distinct?: FeedItemScalarFieldEnum | FeedItemScalarFieldEnum[]
  }

  /**
   * FeedItem create
   */
  export type FeedItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemInclude<ExtArgs> | null
    /**
     * The data needed to create a FeedItem.
     */
    data: XOR<FeedItemCreateInput, FeedItemUncheckedCreateInput>
  }

  /**
   * FeedItem createMany
   */
  export type FeedItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeedItems.
     */
    data: FeedItemCreateManyInput | FeedItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeedItem createManyAndReturn
   */
  export type FeedItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FeedItems.
     */
    data: FeedItemCreateManyInput | FeedItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeedItem update
   */
  export type FeedItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemInclude<ExtArgs> | null
    /**
     * The data needed to update a FeedItem.
     */
    data: XOR<FeedItemUpdateInput, FeedItemUncheckedUpdateInput>
    /**
     * Choose, which FeedItem to update.
     */
    where: FeedItemWhereUniqueInput
  }

  /**
   * FeedItem updateMany
   */
  export type FeedItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeedItems.
     */
    data: XOR<FeedItemUpdateManyMutationInput, FeedItemUncheckedUpdateManyInput>
    /**
     * Filter which FeedItems to update
     */
    where?: FeedItemWhereInput
  }

  /**
   * FeedItem upsert
   */
  export type FeedItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemInclude<ExtArgs> | null
    /**
     * The filter to search for the FeedItem to update in case it exists.
     */
    where: FeedItemWhereUniqueInput
    /**
     * In case the FeedItem found by the `where` argument doesn't exist, create a new FeedItem with this data.
     */
    create: XOR<FeedItemCreateInput, FeedItemUncheckedCreateInput>
    /**
     * In case the FeedItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedItemUpdateInput, FeedItemUncheckedUpdateInput>
  }

  /**
   * FeedItem delete
   */
  export type FeedItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemInclude<ExtArgs> | null
    /**
     * Filter which FeedItem to delete.
     */
    where: FeedItemWhereUniqueInput
  }

  /**
   * FeedItem deleteMany
   */
  export type FeedItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedItems to delete
     */
    where?: FeedItemWhereInput
  }

  /**
   * FeedItem without action
   */
  export type FeedItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    read: boolean | null
    actionUrl: string | null
    icon: string | null
    timestamp: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    read: boolean | null
    actionUrl: string | null
    icon: string | null
    timestamp: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    read: number
    actionUrl: number
    icon: number
    timestamp: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    actionUrl?: true
    icon?: true
    timestamp?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    actionUrl?: true
    icon?: true
    timestamp?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    actionUrl?: true
    icon?: true
    timestamp?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    read: boolean
    actionUrl: string | null
    icon: string | null
    timestamp: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    actionUrl?: boolean
    icon?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    actionUrl?: boolean
    icon?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    actionUrl?: boolean
    icon?: boolean
    timestamp?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.NotificationType
      title: string
      message: string
      read: boolean
      actionUrl: string | null
      icon: string | null
      timestamp: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly actionUrl: FieldRef<"Notification", 'String'>
    readonly icon: FieldRef<"Notification", 'String'>
    readonly timestamp: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model CareerPath
   */

  export type AggregateCareerPath = {
    _count: CareerPathCountAggregateOutputType | null
    _avg: CareerPathAvgAggregateOutputType | null
    _sum: CareerPathSumAggregateOutputType | null
    _min: CareerPathMinAggregateOutputType | null
    _max: CareerPathMaxAggregateOutputType | null
  }

  export type CareerPathAvgAggregateOutputType = {
    estimatedDuration: number | null
  }

  export type CareerPathSumAggregateOutputType = {
    estimatedDuration: number | null
  }

  export type CareerPathMinAggregateOutputType = {
    id: string | null
    userId: string | null
    currentRole: string | null
    targetRole: string | null
    estimatedDuration: number | null
    createdAt: Date | null
  }

  export type CareerPathMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    currentRole: string | null
    targetRole: string | null
    estimatedDuration: number | null
    createdAt: Date | null
  }

  export type CareerPathCountAggregateOutputType = {
    id: number
    userId: number
    currentRole: number
    targetRole: number
    estimatedDuration: number
    createdAt: number
    _all: number
  }


  export type CareerPathAvgAggregateInputType = {
    estimatedDuration?: true
  }

  export type CareerPathSumAggregateInputType = {
    estimatedDuration?: true
  }

  export type CareerPathMinAggregateInputType = {
    id?: true
    userId?: true
    currentRole?: true
    targetRole?: true
    estimatedDuration?: true
    createdAt?: true
  }

  export type CareerPathMaxAggregateInputType = {
    id?: true
    userId?: true
    currentRole?: true
    targetRole?: true
    estimatedDuration?: true
    createdAt?: true
  }

  export type CareerPathCountAggregateInputType = {
    id?: true
    userId?: true
    currentRole?: true
    targetRole?: true
    estimatedDuration?: true
    createdAt?: true
    _all?: true
  }

  export type CareerPathAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CareerPath to aggregate.
     */
    where?: CareerPathWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CareerPaths to fetch.
     */
    orderBy?: CareerPathOrderByWithRelationInput | CareerPathOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CareerPathWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CareerPaths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CareerPaths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CareerPaths
    **/
    _count?: true | CareerPathCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CareerPathAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CareerPathSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CareerPathMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CareerPathMaxAggregateInputType
  }

  export type GetCareerPathAggregateType<T extends CareerPathAggregateArgs> = {
        [P in keyof T & keyof AggregateCareerPath]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCareerPath[P]>
      : GetScalarType<T[P], AggregateCareerPath[P]>
  }




  export type CareerPathGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CareerPathWhereInput
    orderBy?: CareerPathOrderByWithAggregationInput | CareerPathOrderByWithAggregationInput[]
    by: CareerPathScalarFieldEnum[] | CareerPathScalarFieldEnum
    having?: CareerPathScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CareerPathCountAggregateInputType | true
    _avg?: CareerPathAvgAggregateInputType
    _sum?: CareerPathSumAggregateInputType
    _min?: CareerPathMinAggregateInputType
    _max?: CareerPathMaxAggregateInputType
  }

  export type CareerPathGroupByOutputType = {
    id: string
    userId: string
    currentRole: string
    targetRole: string
    estimatedDuration: number
    createdAt: Date
    _count: CareerPathCountAggregateOutputType | null
    _avg: CareerPathAvgAggregateOutputType | null
    _sum: CareerPathSumAggregateOutputType | null
    _min: CareerPathMinAggregateOutputType | null
    _max: CareerPathMaxAggregateOutputType | null
  }

  type GetCareerPathGroupByPayload<T extends CareerPathGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CareerPathGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CareerPathGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CareerPathGroupByOutputType[P]>
            : GetScalarType<T[P], CareerPathGroupByOutputType[P]>
        }
      >
    >


  export type CareerPathSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentRole?: boolean
    targetRole?: boolean
    estimatedDuration?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    nodes?: boolean | CareerPath$nodesArgs<ExtArgs>
    skillGaps?: boolean | CareerPath$skillGapsArgs<ExtArgs>
    _count?: boolean | CareerPathCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["careerPath"]>

  export type CareerPathSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentRole?: boolean
    targetRole?: boolean
    estimatedDuration?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["careerPath"]>

  export type CareerPathSelectScalar = {
    id?: boolean
    userId?: boolean
    currentRole?: boolean
    targetRole?: boolean
    estimatedDuration?: boolean
    createdAt?: boolean
  }

  export type CareerPathInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    nodes?: boolean | CareerPath$nodesArgs<ExtArgs>
    skillGaps?: boolean | CareerPath$skillGapsArgs<ExtArgs>
    _count?: boolean | CareerPathCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CareerPathIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CareerPathPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CareerPath"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      nodes: Prisma.$CareerPathNodePayload<ExtArgs>[]
      skillGaps: Prisma.$SkillGapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      currentRole: string
      targetRole: string
      estimatedDuration: number
      createdAt: Date
    }, ExtArgs["result"]["careerPath"]>
    composites: {}
  }

  type CareerPathGetPayload<S extends boolean | null | undefined | CareerPathDefaultArgs> = $Result.GetResult<Prisma.$CareerPathPayload, S>

  type CareerPathCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CareerPathFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CareerPathCountAggregateInputType | true
    }

  export interface CareerPathDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CareerPath'], meta: { name: 'CareerPath' } }
    /**
     * Find zero or one CareerPath that matches the filter.
     * @param {CareerPathFindUniqueArgs} args - Arguments to find a CareerPath
     * @example
     * // Get one CareerPath
     * const careerPath = await prisma.careerPath.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CareerPathFindUniqueArgs>(args: SelectSubset<T, CareerPathFindUniqueArgs<ExtArgs>>): Prisma__CareerPathClient<$Result.GetResult<Prisma.$CareerPathPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CareerPath that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CareerPathFindUniqueOrThrowArgs} args - Arguments to find a CareerPath
     * @example
     * // Get one CareerPath
     * const careerPath = await prisma.careerPath.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CareerPathFindUniqueOrThrowArgs>(args: SelectSubset<T, CareerPathFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CareerPathClient<$Result.GetResult<Prisma.$CareerPathPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CareerPath that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerPathFindFirstArgs} args - Arguments to find a CareerPath
     * @example
     * // Get one CareerPath
     * const careerPath = await prisma.careerPath.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CareerPathFindFirstArgs>(args?: SelectSubset<T, CareerPathFindFirstArgs<ExtArgs>>): Prisma__CareerPathClient<$Result.GetResult<Prisma.$CareerPathPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CareerPath that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerPathFindFirstOrThrowArgs} args - Arguments to find a CareerPath
     * @example
     * // Get one CareerPath
     * const careerPath = await prisma.careerPath.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CareerPathFindFirstOrThrowArgs>(args?: SelectSubset<T, CareerPathFindFirstOrThrowArgs<ExtArgs>>): Prisma__CareerPathClient<$Result.GetResult<Prisma.$CareerPathPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CareerPaths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerPathFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CareerPaths
     * const careerPaths = await prisma.careerPath.findMany()
     * 
     * // Get first 10 CareerPaths
     * const careerPaths = await prisma.careerPath.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const careerPathWithIdOnly = await prisma.careerPath.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CareerPathFindManyArgs>(args?: SelectSubset<T, CareerPathFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareerPathPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CareerPath.
     * @param {CareerPathCreateArgs} args - Arguments to create a CareerPath.
     * @example
     * // Create one CareerPath
     * const CareerPath = await prisma.careerPath.create({
     *   data: {
     *     // ... data to create a CareerPath
     *   }
     * })
     * 
     */
    create<T extends CareerPathCreateArgs>(args: SelectSubset<T, CareerPathCreateArgs<ExtArgs>>): Prisma__CareerPathClient<$Result.GetResult<Prisma.$CareerPathPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CareerPaths.
     * @param {CareerPathCreateManyArgs} args - Arguments to create many CareerPaths.
     * @example
     * // Create many CareerPaths
     * const careerPath = await prisma.careerPath.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CareerPathCreateManyArgs>(args?: SelectSubset<T, CareerPathCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CareerPaths and returns the data saved in the database.
     * @param {CareerPathCreateManyAndReturnArgs} args - Arguments to create many CareerPaths.
     * @example
     * // Create many CareerPaths
     * const careerPath = await prisma.careerPath.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CareerPaths and only return the `id`
     * const careerPathWithIdOnly = await prisma.careerPath.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CareerPathCreateManyAndReturnArgs>(args?: SelectSubset<T, CareerPathCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareerPathPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CareerPath.
     * @param {CareerPathDeleteArgs} args - Arguments to delete one CareerPath.
     * @example
     * // Delete one CareerPath
     * const CareerPath = await prisma.careerPath.delete({
     *   where: {
     *     // ... filter to delete one CareerPath
     *   }
     * })
     * 
     */
    delete<T extends CareerPathDeleteArgs>(args: SelectSubset<T, CareerPathDeleteArgs<ExtArgs>>): Prisma__CareerPathClient<$Result.GetResult<Prisma.$CareerPathPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CareerPath.
     * @param {CareerPathUpdateArgs} args - Arguments to update one CareerPath.
     * @example
     * // Update one CareerPath
     * const careerPath = await prisma.careerPath.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CareerPathUpdateArgs>(args: SelectSubset<T, CareerPathUpdateArgs<ExtArgs>>): Prisma__CareerPathClient<$Result.GetResult<Prisma.$CareerPathPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CareerPaths.
     * @param {CareerPathDeleteManyArgs} args - Arguments to filter CareerPaths to delete.
     * @example
     * // Delete a few CareerPaths
     * const { count } = await prisma.careerPath.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CareerPathDeleteManyArgs>(args?: SelectSubset<T, CareerPathDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CareerPaths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerPathUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CareerPaths
     * const careerPath = await prisma.careerPath.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CareerPathUpdateManyArgs>(args: SelectSubset<T, CareerPathUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CareerPath.
     * @param {CareerPathUpsertArgs} args - Arguments to update or create a CareerPath.
     * @example
     * // Update or create a CareerPath
     * const careerPath = await prisma.careerPath.upsert({
     *   create: {
     *     // ... data to create a CareerPath
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CareerPath we want to update
     *   }
     * })
     */
    upsert<T extends CareerPathUpsertArgs>(args: SelectSubset<T, CareerPathUpsertArgs<ExtArgs>>): Prisma__CareerPathClient<$Result.GetResult<Prisma.$CareerPathPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CareerPaths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerPathCountArgs} args - Arguments to filter CareerPaths to count.
     * @example
     * // Count the number of CareerPaths
     * const count = await prisma.careerPath.count({
     *   where: {
     *     // ... the filter for the CareerPaths we want to count
     *   }
     * })
    **/
    count<T extends CareerPathCountArgs>(
      args?: Subset<T, CareerPathCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CareerPathCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CareerPath.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerPathAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CareerPathAggregateArgs>(args: Subset<T, CareerPathAggregateArgs>): Prisma.PrismaPromise<GetCareerPathAggregateType<T>>

    /**
     * Group by CareerPath.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerPathGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CareerPathGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CareerPathGroupByArgs['orderBy'] }
        : { orderBy?: CareerPathGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CareerPathGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCareerPathGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CareerPath model
   */
  readonly fields: CareerPathFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CareerPath.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CareerPathClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    nodes<T extends CareerPath$nodesArgs<ExtArgs> = {}>(args?: Subset<T, CareerPath$nodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareerPathNodePayload<ExtArgs>, T, "findMany"> | Null>
    skillGaps<T extends CareerPath$skillGapsArgs<ExtArgs> = {}>(args?: Subset<T, CareerPath$skillGapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillGapPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CareerPath model
   */ 
  interface CareerPathFieldRefs {
    readonly id: FieldRef<"CareerPath", 'String'>
    readonly userId: FieldRef<"CareerPath", 'String'>
    readonly currentRole: FieldRef<"CareerPath", 'String'>
    readonly targetRole: FieldRef<"CareerPath", 'String'>
    readonly estimatedDuration: FieldRef<"CareerPath", 'Int'>
    readonly createdAt: FieldRef<"CareerPath", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CareerPath findUnique
   */
  export type CareerPathFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPath
     */
    select?: CareerPathSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerPathInclude<ExtArgs> | null
    /**
     * Filter, which CareerPath to fetch.
     */
    where: CareerPathWhereUniqueInput
  }

  /**
   * CareerPath findUniqueOrThrow
   */
  export type CareerPathFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPath
     */
    select?: CareerPathSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerPathInclude<ExtArgs> | null
    /**
     * Filter, which CareerPath to fetch.
     */
    where: CareerPathWhereUniqueInput
  }

  /**
   * CareerPath findFirst
   */
  export type CareerPathFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPath
     */
    select?: CareerPathSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerPathInclude<ExtArgs> | null
    /**
     * Filter, which CareerPath to fetch.
     */
    where?: CareerPathWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CareerPaths to fetch.
     */
    orderBy?: CareerPathOrderByWithRelationInput | CareerPathOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CareerPaths.
     */
    cursor?: CareerPathWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CareerPaths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CareerPaths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CareerPaths.
     */
    distinct?: CareerPathScalarFieldEnum | CareerPathScalarFieldEnum[]
  }

  /**
   * CareerPath findFirstOrThrow
   */
  export type CareerPathFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPath
     */
    select?: CareerPathSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerPathInclude<ExtArgs> | null
    /**
     * Filter, which CareerPath to fetch.
     */
    where?: CareerPathWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CareerPaths to fetch.
     */
    orderBy?: CareerPathOrderByWithRelationInput | CareerPathOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CareerPaths.
     */
    cursor?: CareerPathWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CareerPaths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CareerPaths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CareerPaths.
     */
    distinct?: CareerPathScalarFieldEnum | CareerPathScalarFieldEnum[]
  }

  /**
   * CareerPath findMany
   */
  export type CareerPathFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPath
     */
    select?: CareerPathSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerPathInclude<ExtArgs> | null
    /**
     * Filter, which CareerPaths to fetch.
     */
    where?: CareerPathWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CareerPaths to fetch.
     */
    orderBy?: CareerPathOrderByWithRelationInput | CareerPathOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CareerPaths.
     */
    cursor?: CareerPathWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CareerPaths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CareerPaths.
     */
    skip?: number
    distinct?: CareerPathScalarFieldEnum | CareerPathScalarFieldEnum[]
  }

  /**
   * CareerPath create
   */
  export type CareerPathCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPath
     */
    select?: CareerPathSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerPathInclude<ExtArgs> | null
    /**
     * The data needed to create a CareerPath.
     */
    data: XOR<CareerPathCreateInput, CareerPathUncheckedCreateInput>
  }

  /**
   * CareerPath createMany
   */
  export type CareerPathCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CareerPaths.
     */
    data: CareerPathCreateManyInput | CareerPathCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CareerPath createManyAndReturn
   */
  export type CareerPathCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPath
     */
    select?: CareerPathSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CareerPaths.
     */
    data: CareerPathCreateManyInput | CareerPathCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerPathIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CareerPath update
   */
  export type CareerPathUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPath
     */
    select?: CareerPathSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerPathInclude<ExtArgs> | null
    /**
     * The data needed to update a CareerPath.
     */
    data: XOR<CareerPathUpdateInput, CareerPathUncheckedUpdateInput>
    /**
     * Choose, which CareerPath to update.
     */
    where: CareerPathWhereUniqueInput
  }

  /**
   * CareerPath updateMany
   */
  export type CareerPathUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CareerPaths.
     */
    data: XOR<CareerPathUpdateManyMutationInput, CareerPathUncheckedUpdateManyInput>
    /**
     * Filter which CareerPaths to update
     */
    where?: CareerPathWhereInput
  }

  /**
   * CareerPath upsert
   */
  export type CareerPathUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPath
     */
    select?: CareerPathSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerPathInclude<ExtArgs> | null
    /**
     * The filter to search for the CareerPath to update in case it exists.
     */
    where: CareerPathWhereUniqueInput
    /**
     * In case the CareerPath found by the `where` argument doesn't exist, create a new CareerPath with this data.
     */
    create: XOR<CareerPathCreateInput, CareerPathUncheckedCreateInput>
    /**
     * In case the CareerPath was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CareerPathUpdateInput, CareerPathUncheckedUpdateInput>
  }

  /**
   * CareerPath delete
   */
  export type CareerPathDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPath
     */
    select?: CareerPathSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerPathInclude<ExtArgs> | null
    /**
     * Filter which CareerPath to delete.
     */
    where: CareerPathWhereUniqueInput
  }

  /**
   * CareerPath deleteMany
   */
  export type CareerPathDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CareerPaths to delete
     */
    where?: CareerPathWhereInput
  }

  /**
   * CareerPath.nodes
   */
  export type CareerPath$nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPathNode
     */
    select?: CareerPathNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerPathNodeInclude<ExtArgs> | null
    where?: CareerPathNodeWhereInput
    orderBy?: CareerPathNodeOrderByWithRelationInput | CareerPathNodeOrderByWithRelationInput[]
    cursor?: CareerPathNodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CareerPathNodeScalarFieldEnum | CareerPathNodeScalarFieldEnum[]
  }

  /**
   * CareerPath.skillGaps
   */
  export type CareerPath$skillGapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillGap
     */
    select?: SkillGapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillGapInclude<ExtArgs> | null
    where?: SkillGapWhereInput
    orderBy?: SkillGapOrderByWithRelationInput | SkillGapOrderByWithRelationInput[]
    cursor?: SkillGapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillGapScalarFieldEnum | SkillGapScalarFieldEnum[]
  }

  /**
   * CareerPath without action
   */
  export type CareerPathDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPath
     */
    select?: CareerPathSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerPathInclude<ExtArgs> | null
  }


  /**
   * Model CareerPathNode
   */

  export type AggregateCareerPathNode = {
    _count: CareerPathNodeCountAggregateOutputType | null
    _avg: CareerPathNodeAvgAggregateOutputType | null
    _sum: CareerPathNodeSumAggregateOutputType | null
    _min: CareerPathNodeMinAggregateOutputType | null
    _max: CareerPathNodeMaxAggregateOutputType | null
  }

  export type CareerPathNodeAvgAggregateOutputType = {
    stageNumber: number | null
    duration: number | null
  }

  export type CareerPathNodeSumAggregateOutputType = {
    stageNumber: number | null
    duration: number | null
  }

  export type CareerPathNodeMinAggregateOutputType = {
    id: string | null
    careerPathId: string | null
    stageNumber: number | null
    title: string | null
    duration: number | null
    completed: boolean | null
  }

  export type CareerPathNodeMaxAggregateOutputType = {
    id: string | null
    careerPathId: string | null
    stageNumber: number | null
    title: string | null
    duration: number | null
    completed: boolean | null
  }

  export type CareerPathNodeCountAggregateOutputType = {
    id: number
    careerPathId: number
    stageNumber: number
    title: number
    duration: number
    completed: number
    _all: number
  }


  export type CareerPathNodeAvgAggregateInputType = {
    stageNumber?: true
    duration?: true
  }

  export type CareerPathNodeSumAggregateInputType = {
    stageNumber?: true
    duration?: true
  }

  export type CareerPathNodeMinAggregateInputType = {
    id?: true
    careerPathId?: true
    stageNumber?: true
    title?: true
    duration?: true
    completed?: true
  }

  export type CareerPathNodeMaxAggregateInputType = {
    id?: true
    careerPathId?: true
    stageNumber?: true
    title?: true
    duration?: true
    completed?: true
  }

  export type CareerPathNodeCountAggregateInputType = {
    id?: true
    careerPathId?: true
    stageNumber?: true
    title?: true
    duration?: true
    completed?: true
    _all?: true
  }

  export type CareerPathNodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CareerPathNode to aggregate.
     */
    where?: CareerPathNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CareerPathNodes to fetch.
     */
    orderBy?: CareerPathNodeOrderByWithRelationInput | CareerPathNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CareerPathNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CareerPathNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CareerPathNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CareerPathNodes
    **/
    _count?: true | CareerPathNodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CareerPathNodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CareerPathNodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CareerPathNodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CareerPathNodeMaxAggregateInputType
  }

  export type GetCareerPathNodeAggregateType<T extends CareerPathNodeAggregateArgs> = {
        [P in keyof T & keyof AggregateCareerPathNode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCareerPathNode[P]>
      : GetScalarType<T[P], AggregateCareerPathNode[P]>
  }




  export type CareerPathNodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CareerPathNodeWhereInput
    orderBy?: CareerPathNodeOrderByWithAggregationInput | CareerPathNodeOrderByWithAggregationInput[]
    by: CareerPathNodeScalarFieldEnum[] | CareerPathNodeScalarFieldEnum
    having?: CareerPathNodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CareerPathNodeCountAggregateInputType | true
    _avg?: CareerPathNodeAvgAggregateInputType
    _sum?: CareerPathNodeSumAggregateInputType
    _min?: CareerPathNodeMinAggregateInputType
    _max?: CareerPathNodeMaxAggregateInputType
  }

  export type CareerPathNodeGroupByOutputType = {
    id: string
    careerPathId: string
    stageNumber: number
    title: string
    duration: number
    completed: boolean
    _count: CareerPathNodeCountAggregateOutputType | null
    _avg: CareerPathNodeAvgAggregateOutputType | null
    _sum: CareerPathNodeSumAggregateOutputType | null
    _min: CareerPathNodeMinAggregateOutputType | null
    _max: CareerPathNodeMaxAggregateOutputType | null
  }

  type GetCareerPathNodeGroupByPayload<T extends CareerPathNodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CareerPathNodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CareerPathNodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CareerPathNodeGroupByOutputType[P]>
            : GetScalarType<T[P], CareerPathNodeGroupByOutputType[P]>
        }
      >
    >


  export type CareerPathNodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    careerPathId?: boolean
    stageNumber?: boolean
    title?: boolean
    duration?: boolean
    completed?: boolean
    careerPath?: boolean | CareerPathDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["careerPathNode"]>

  export type CareerPathNodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    careerPathId?: boolean
    stageNumber?: boolean
    title?: boolean
    duration?: boolean
    completed?: boolean
    careerPath?: boolean | CareerPathDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["careerPathNode"]>

  export type CareerPathNodeSelectScalar = {
    id?: boolean
    careerPathId?: boolean
    stageNumber?: boolean
    title?: boolean
    duration?: boolean
    completed?: boolean
  }

  export type CareerPathNodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    careerPath?: boolean | CareerPathDefaultArgs<ExtArgs>
  }
  export type CareerPathNodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    careerPath?: boolean | CareerPathDefaultArgs<ExtArgs>
  }

  export type $CareerPathNodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CareerPathNode"
    objects: {
      careerPath: Prisma.$CareerPathPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      careerPathId: string
      stageNumber: number
      title: string
      duration: number
      completed: boolean
    }, ExtArgs["result"]["careerPathNode"]>
    composites: {}
  }

  type CareerPathNodeGetPayload<S extends boolean | null | undefined | CareerPathNodeDefaultArgs> = $Result.GetResult<Prisma.$CareerPathNodePayload, S>

  type CareerPathNodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CareerPathNodeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CareerPathNodeCountAggregateInputType | true
    }

  export interface CareerPathNodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CareerPathNode'], meta: { name: 'CareerPathNode' } }
    /**
     * Find zero or one CareerPathNode that matches the filter.
     * @param {CareerPathNodeFindUniqueArgs} args - Arguments to find a CareerPathNode
     * @example
     * // Get one CareerPathNode
     * const careerPathNode = await prisma.careerPathNode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CareerPathNodeFindUniqueArgs>(args: SelectSubset<T, CareerPathNodeFindUniqueArgs<ExtArgs>>): Prisma__CareerPathNodeClient<$Result.GetResult<Prisma.$CareerPathNodePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CareerPathNode that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CareerPathNodeFindUniqueOrThrowArgs} args - Arguments to find a CareerPathNode
     * @example
     * // Get one CareerPathNode
     * const careerPathNode = await prisma.careerPathNode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CareerPathNodeFindUniqueOrThrowArgs>(args: SelectSubset<T, CareerPathNodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CareerPathNodeClient<$Result.GetResult<Prisma.$CareerPathNodePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CareerPathNode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerPathNodeFindFirstArgs} args - Arguments to find a CareerPathNode
     * @example
     * // Get one CareerPathNode
     * const careerPathNode = await prisma.careerPathNode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CareerPathNodeFindFirstArgs>(args?: SelectSubset<T, CareerPathNodeFindFirstArgs<ExtArgs>>): Prisma__CareerPathNodeClient<$Result.GetResult<Prisma.$CareerPathNodePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CareerPathNode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerPathNodeFindFirstOrThrowArgs} args - Arguments to find a CareerPathNode
     * @example
     * // Get one CareerPathNode
     * const careerPathNode = await prisma.careerPathNode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CareerPathNodeFindFirstOrThrowArgs>(args?: SelectSubset<T, CareerPathNodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CareerPathNodeClient<$Result.GetResult<Prisma.$CareerPathNodePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CareerPathNodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerPathNodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CareerPathNodes
     * const careerPathNodes = await prisma.careerPathNode.findMany()
     * 
     * // Get first 10 CareerPathNodes
     * const careerPathNodes = await prisma.careerPathNode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const careerPathNodeWithIdOnly = await prisma.careerPathNode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CareerPathNodeFindManyArgs>(args?: SelectSubset<T, CareerPathNodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareerPathNodePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CareerPathNode.
     * @param {CareerPathNodeCreateArgs} args - Arguments to create a CareerPathNode.
     * @example
     * // Create one CareerPathNode
     * const CareerPathNode = await prisma.careerPathNode.create({
     *   data: {
     *     // ... data to create a CareerPathNode
     *   }
     * })
     * 
     */
    create<T extends CareerPathNodeCreateArgs>(args: SelectSubset<T, CareerPathNodeCreateArgs<ExtArgs>>): Prisma__CareerPathNodeClient<$Result.GetResult<Prisma.$CareerPathNodePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CareerPathNodes.
     * @param {CareerPathNodeCreateManyArgs} args - Arguments to create many CareerPathNodes.
     * @example
     * // Create many CareerPathNodes
     * const careerPathNode = await prisma.careerPathNode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CareerPathNodeCreateManyArgs>(args?: SelectSubset<T, CareerPathNodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CareerPathNodes and returns the data saved in the database.
     * @param {CareerPathNodeCreateManyAndReturnArgs} args - Arguments to create many CareerPathNodes.
     * @example
     * // Create many CareerPathNodes
     * const careerPathNode = await prisma.careerPathNode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CareerPathNodes and only return the `id`
     * const careerPathNodeWithIdOnly = await prisma.careerPathNode.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CareerPathNodeCreateManyAndReturnArgs>(args?: SelectSubset<T, CareerPathNodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareerPathNodePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CareerPathNode.
     * @param {CareerPathNodeDeleteArgs} args - Arguments to delete one CareerPathNode.
     * @example
     * // Delete one CareerPathNode
     * const CareerPathNode = await prisma.careerPathNode.delete({
     *   where: {
     *     // ... filter to delete one CareerPathNode
     *   }
     * })
     * 
     */
    delete<T extends CareerPathNodeDeleteArgs>(args: SelectSubset<T, CareerPathNodeDeleteArgs<ExtArgs>>): Prisma__CareerPathNodeClient<$Result.GetResult<Prisma.$CareerPathNodePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CareerPathNode.
     * @param {CareerPathNodeUpdateArgs} args - Arguments to update one CareerPathNode.
     * @example
     * // Update one CareerPathNode
     * const careerPathNode = await prisma.careerPathNode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CareerPathNodeUpdateArgs>(args: SelectSubset<T, CareerPathNodeUpdateArgs<ExtArgs>>): Prisma__CareerPathNodeClient<$Result.GetResult<Prisma.$CareerPathNodePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CareerPathNodes.
     * @param {CareerPathNodeDeleteManyArgs} args - Arguments to filter CareerPathNodes to delete.
     * @example
     * // Delete a few CareerPathNodes
     * const { count } = await prisma.careerPathNode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CareerPathNodeDeleteManyArgs>(args?: SelectSubset<T, CareerPathNodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CareerPathNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerPathNodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CareerPathNodes
     * const careerPathNode = await prisma.careerPathNode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CareerPathNodeUpdateManyArgs>(args: SelectSubset<T, CareerPathNodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CareerPathNode.
     * @param {CareerPathNodeUpsertArgs} args - Arguments to update or create a CareerPathNode.
     * @example
     * // Update or create a CareerPathNode
     * const careerPathNode = await prisma.careerPathNode.upsert({
     *   create: {
     *     // ... data to create a CareerPathNode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CareerPathNode we want to update
     *   }
     * })
     */
    upsert<T extends CareerPathNodeUpsertArgs>(args: SelectSubset<T, CareerPathNodeUpsertArgs<ExtArgs>>): Prisma__CareerPathNodeClient<$Result.GetResult<Prisma.$CareerPathNodePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CareerPathNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerPathNodeCountArgs} args - Arguments to filter CareerPathNodes to count.
     * @example
     * // Count the number of CareerPathNodes
     * const count = await prisma.careerPathNode.count({
     *   where: {
     *     // ... the filter for the CareerPathNodes we want to count
     *   }
     * })
    **/
    count<T extends CareerPathNodeCountArgs>(
      args?: Subset<T, CareerPathNodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CareerPathNodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CareerPathNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerPathNodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CareerPathNodeAggregateArgs>(args: Subset<T, CareerPathNodeAggregateArgs>): Prisma.PrismaPromise<GetCareerPathNodeAggregateType<T>>

    /**
     * Group by CareerPathNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerPathNodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CareerPathNodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CareerPathNodeGroupByArgs['orderBy'] }
        : { orderBy?: CareerPathNodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CareerPathNodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCareerPathNodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CareerPathNode model
   */
  readonly fields: CareerPathNodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CareerPathNode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CareerPathNodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    careerPath<T extends CareerPathDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CareerPathDefaultArgs<ExtArgs>>): Prisma__CareerPathClient<$Result.GetResult<Prisma.$CareerPathPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CareerPathNode model
   */ 
  interface CareerPathNodeFieldRefs {
    readonly id: FieldRef<"CareerPathNode", 'String'>
    readonly careerPathId: FieldRef<"CareerPathNode", 'String'>
    readonly stageNumber: FieldRef<"CareerPathNode", 'Int'>
    readonly title: FieldRef<"CareerPathNode", 'String'>
    readonly duration: FieldRef<"CareerPathNode", 'Int'>
    readonly completed: FieldRef<"CareerPathNode", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * CareerPathNode findUnique
   */
  export type CareerPathNodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPathNode
     */
    select?: CareerPathNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerPathNodeInclude<ExtArgs> | null
    /**
     * Filter, which CareerPathNode to fetch.
     */
    where: CareerPathNodeWhereUniqueInput
  }

  /**
   * CareerPathNode findUniqueOrThrow
   */
  export type CareerPathNodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPathNode
     */
    select?: CareerPathNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerPathNodeInclude<ExtArgs> | null
    /**
     * Filter, which CareerPathNode to fetch.
     */
    where: CareerPathNodeWhereUniqueInput
  }

  /**
   * CareerPathNode findFirst
   */
  export type CareerPathNodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPathNode
     */
    select?: CareerPathNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerPathNodeInclude<ExtArgs> | null
    /**
     * Filter, which CareerPathNode to fetch.
     */
    where?: CareerPathNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CareerPathNodes to fetch.
     */
    orderBy?: CareerPathNodeOrderByWithRelationInput | CareerPathNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CareerPathNodes.
     */
    cursor?: CareerPathNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CareerPathNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CareerPathNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CareerPathNodes.
     */
    distinct?: CareerPathNodeScalarFieldEnum | CareerPathNodeScalarFieldEnum[]
  }

  /**
   * CareerPathNode findFirstOrThrow
   */
  export type CareerPathNodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPathNode
     */
    select?: CareerPathNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerPathNodeInclude<ExtArgs> | null
    /**
     * Filter, which CareerPathNode to fetch.
     */
    where?: CareerPathNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CareerPathNodes to fetch.
     */
    orderBy?: CareerPathNodeOrderByWithRelationInput | CareerPathNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CareerPathNodes.
     */
    cursor?: CareerPathNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CareerPathNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CareerPathNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CareerPathNodes.
     */
    distinct?: CareerPathNodeScalarFieldEnum | CareerPathNodeScalarFieldEnum[]
  }

  /**
   * CareerPathNode findMany
   */
  export type CareerPathNodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPathNode
     */
    select?: CareerPathNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerPathNodeInclude<ExtArgs> | null
    /**
     * Filter, which CareerPathNodes to fetch.
     */
    where?: CareerPathNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CareerPathNodes to fetch.
     */
    orderBy?: CareerPathNodeOrderByWithRelationInput | CareerPathNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CareerPathNodes.
     */
    cursor?: CareerPathNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CareerPathNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CareerPathNodes.
     */
    skip?: number
    distinct?: CareerPathNodeScalarFieldEnum | CareerPathNodeScalarFieldEnum[]
  }

  /**
   * CareerPathNode create
   */
  export type CareerPathNodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPathNode
     */
    select?: CareerPathNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerPathNodeInclude<ExtArgs> | null
    /**
     * The data needed to create a CareerPathNode.
     */
    data: XOR<CareerPathNodeCreateInput, CareerPathNodeUncheckedCreateInput>
  }

  /**
   * CareerPathNode createMany
   */
  export type CareerPathNodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CareerPathNodes.
     */
    data: CareerPathNodeCreateManyInput | CareerPathNodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CareerPathNode createManyAndReturn
   */
  export type CareerPathNodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPathNode
     */
    select?: CareerPathNodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CareerPathNodes.
     */
    data: CareerPathNodeCreateManyInput | CareerPathNodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerPathNodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CareerPathNode update
   */
  export type CareerPathNodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPathNode
     */
    select?: CareerPathNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerPathNodeInclude<ExtArgs> | null
    /**
     * The data needed to update a CareerPathNode.
     */
    data: XOR<CareerPathNodeUpdateInput, CareerPathNodeUncheckedUpdateInput>
    /**
     * Choose, which CareerPathNode to update.
     */
    where: CareerPathNodeWhereUniqueInput
  }

  /**
   * CareerPathNode updateMany
   */
  export type CareerPathNodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CareerPathNodes.
     */
    data: XOR<CareerPathNodeUpdateManyMutationInput, CareerPathNodeUncheckedUpdateManyInput>
    /**
     * Filter which CareerPathNodes to update
     */
    where?: CareerPathNodeWhereInput
  }

  /**
   * CareerPathNode upsert
   */
  export type CareerPathNodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPathNode
     */
    select?: CareerPathNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerPathNodeInclude<ExtArgs> | null
    /**
     * The filter to search for the CareerPathNode to update in case it exists.
     */
    where: CareerPathNodeWhereUniqueInput
    /**
     * In case the CareerPathNode found by the `where` argument doesn't exist, create a new CareerPathNode with this data.
     */
    create: XOR<CareerPathNodeCreateInput, CareerPathNodeUncheckedCreateInput>
    /**
     * In case the CareerPathNode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CareerPathNodeUpdateInput, CareerPathNodeUncheckedUpdateInput>
  }

  /**
   * CareerPathNode delete
   */
  export type CareerPathNodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPathNode
     */
    select?: CareerPathNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerPathNodeInclude<ExtArgs> | null
    /**
     * Filter which CareerPathNode to delete.
     */
    where: CareerPathNodeWhereUniqueInput
  }

  /**
   * CareerPathNode deleteMany
   */
  export type CareerPathNodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CareerPathNodes to delete
     */
    where?: CareerPathNodeWhereInput
  }

  /**
   * CareerPathNode without action
   */
  export type CareerPathNodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPathNode
     */
    select?: CareerPathNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerPathNodeInclude<ExtArgs> | null
  }


  /**
   * Model SkillGap
   */

  export type AggregateSkillGap = {
    _count: SkillGapCountAggregateOutputType | null
    _min: SkillGapMinAggregateOutputType | null
    _max: SkillGapMaxAggregateOutputType | null
  }

  export type SkillGapMinAggregateOutputType = {
    id: string | null
    careerPathId: string | null
    skillId: string | null
    currentLevel: $Enums.SkillLevel | null
    targetLevel: $Enums.SkillLevel | null
    priority: $Enums.Priority | null
  }

  export type SkillGapMaxAggregateOutputType = {
    id: string | null
    careerPathId: string | null
    skillId: string | null
    currentLevel: $Enums.SkillLevel | null
    targetLevel: $Enums.SkillLevel | null
    priority: $Enums.Priority | null
  }

  export type SkillGapCountAggregateOutputType = {
    id: number
    careerPathId: number
    skillId: number
    currentLevel: number
    targetLevel: number
    priority: number
    _all: number
  }


  export type SkillGapMinAggregateInputType = {
    id?: true
    careerPathId?: true
    skillId?: true
    currentLevel?: true
    targetLevel?: true
    priority?: true
  }

  export type SkillGapMaxAggregateInputType = {
    id?: true
    careerPathId?: true
    skillId?: true
    currentLevel?: true
    targetLevel?: true
    priority?: true
  }

  export type SkillGapCountAggregateInputType = {
    id?: true
    careerPathId?: true
    skillId?: true
    currentLevel?: true
    targetLevel?: true
    priority?: true
    _all?: true
  }

  export type SkillGapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkillGap to aggregate.
     */
    where?: SkillGapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillGaps to fetch.
     */
    orderBy?: SkillGapOrderByWithRelationInput | SkillGapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillGapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillGaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillGaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SkillGaps
    **/
    _count?: true | SkillGapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillGapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillGapMaxAggregateInputType
  }

  export type GetSkillGapAggregateType<T extends SkillGapAggregateArgs> = {
        [P in keyof T & keyof AggregateSkillGap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkillGap[P]>
      : GetScalarType<T[P], AggregateSkillGap[P]>
  }




  export type SkillGapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillGapWhereInput
    orderBy?: SkillGapOrderByWithAggregationInput | SkillGapOrderByWithAggregationInput[]
    by: SkillGapScalarFieldEnum[] | SkillGapScalarFieldEnum
    having?: SkillGapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillGapCountAggregateInputType | true
    _min?: SkillGapMinAggregateInputType
    _max?: SkillGapMaxAggregateInputType
  }

  export type SkillGapGroupByOutputType = {
    id: string
    careerPathId: string
    skillId: string
    currentLevel: $Enums.SkillLevel
    targetLevel: $Enums.SkillLevel
    priority: $Enums.Priority
    _count: SkillGapCountAggregateOutputType | null
    _min: SkillGapMinAggregateOutputType | null
    _max: SkillGapMaxAggregateOutputType | null
  }

  type GetSkillGapGroupByPayload<T extends SkillGapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillGapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillGapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillGapGroupByOutputType[P]>
            : GetScalarType<T[P], SkillGapGroupByOutputType[P]>
        }
      >
    >


  export type SkillGapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    careerPathId?: boolean
    skillId?: boolean
    currentLevel?: boolean
    targetLevel?: boolean
    priority?: boolean
    careerPath?: boolean | CareerPathDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skillGap"]>

  export type SkillGapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    careerPathId?: boolean
    skillId?: boolean
    currentLevel?: boolean
    targetLevel?: boolean
    priority?: boolean
    careerPath?: boolean | CareerPathDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skillGap"]>

  export type SkillGapSelectScalar = {
    id?: boolean
    careerPathId?: boolean
    skillId?: boolean
    currentLevel?: boolean
    targetLevel?: boolean
    priority?: boolean
  }

  export type SkillGapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    careerPath?: boolean | CareerPathDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type SkillGapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    careerPath?: boolean | CareerPathDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }

  export type $SkillGapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SkillGap"
    objects: {
      careerPath: Prisma.$CareerPathPayload<ExtArgs>
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      careerPathId: string
      skillId: string
      currentLevel: $Enums.SkillLevel
      targetLevel: $Enums.SkillLevel
      priority: $Enums.Priority
    }, ExtArgs["result"]["skillGap"]>
    composites: {}
  }

  type SkillGapGetPayload<S extends boolean | null | undefined | SkillGapDefaultArgs> = $Result.GetResult<Prisma.$SkillGapPayload, S>

  type SkillGapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SkillGapFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SkillGapCountAggregateInputType | true
    }

  export interface SkillGapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SkillGap'], meta: { name: 'SkillGap' } }
    /**
     * Find zero or one SkillGap that matches the filter.
     * @param {SkillGapFindUniqueArgs} args - Arguments to find a SkillGap
     * @example
     * // Get one SkillGap
     * const skillGap = await prisma.skillGap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillGapFindUniqueArgs>(args: SelectSubset<T, SkillGapFindUniqueArgs<ExtArgs>>): Prisma__SkillGapClient<$Result.GetResult<Prisma.$SkillGapPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SkillGap that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SkillGapFindUniqueOrThrowArgs} args - Arguments to find a SkillGap
     * @example
     * // Get one SkillGap
     * const skillGap = await prisma.skillGap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillGapFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillGapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillGapClient<$Result.GetResult<Prisma.$SkillGapPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SkillGap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGapFindFirstArgs} args - Arguments to find a SkillGap
     * @example
     * // Get one SkillGap
     * const skillGap = await prisma.skillGap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillGapFindFirstArgs>(args?: SelectSubset<T, SkillGapFindFirstArgs<ExtArgs>>): Prisma__SkillGapClient<$Result.GetResult<Prisma.$SkillGapPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SkillGap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGapFindFirstOrThrowArgs} args - Arguments to find a SkillGap
     * @example
     * // Get one SkillGap
     * const skillGap = await prisma.skillGap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillGapFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillGapFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillGapClient<$Result.GetResult<Prisma.$SkillGapPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SkillGaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkillGaps
     * const skillGaps = await prisma.skillGap.findMany()
     * 
     * // Get first 10 SkillGaps
     * const skillGaps = await prisma.skillGap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillGapWithIdOnly = await prisma.skillGap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillGapFindManyArgs>(args?: SelectSubset<T, SkillGapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillGapPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SkillGap.
     * @param {SkillGapCreateArgs} args - Arguments to create a SkillGap.
     * @example
     * // Create one SkillGap
     * const SkillGap = await prisma.skillGap.create({
     *   data: {
     *     // ... data to create a SkillGap
     *   }
     * })
     * 
     */
    create<T extends SkillGapCreateArgs>(args: SelectSubset<T, SkillGapCreateArgs<ExtArgs>>): Prisma__SkillGapClient<$Result.GetResult<Prisma.$SkillGapPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SkillGaps.
     * @param {SkillGapCreateManyArgs} args - Arguments to create many SkillGaps.
     * @example
     * // Create many SkillGaps
     * const skillGap = await prisma.skillGap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillGapCreateManyArgs>(args?: SelectSubset<T, SkillGapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SkillGaps and returns the data saved in the database.
     * @param {SkillGapCreateManyAndReturnArgs} args - Arguments to create many SkillGaps.
     * @example
     * // Create many SkillGaps
     * const skillGap = await prisma.skillGap.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SkillGaps and only return the `id`
     * const skillGapWithIdOnly = await prisma.skillGap.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkillGapCreateManyAndReturnArgs>(args?: SelectSubset<T, SkillGapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillGapPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SkillGap.
     * @param {SkillGapDeleteArgs} args - Arguments to delete one SkillGap.
     * @example
     * // Delete one SkillGap
     * const SkillGap = await prisma.skillGap.delete({
     *   where: {
     *     // ... filter to delete one SkillGap
     *   }
     * })
     * 
     */
    delete<T extends SkillGapDeleteArgs>(args: SelectSubset<T, SkillGapDeleteArgs<ExtArgs>>): Prisma__SkillGapClient<$Result.GetResult<Prisma.$SkillGapPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SkillGap.
     * @param {SkillGapUpdateArgs} args - Arguments to update one SkillGap.
     * @example
     * // Update one SkillGap
     * const skillGap = await prisma.skillGap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillGapUpdateArgs>(args: SelectSubset<T, SkillGapUpdateArgs<ExtArgs>>): Prisma__SkillGapClient<$Result.GetResult<Prisma.$SkillGapPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SkillGaps.
     * @param {SkillGapDeleteManyArgs} args - Arguments to filter SkillGaps to delete.
     * @example
     * // Delete a few SkillGaps
     * const { count } = await prisma.skillGap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillGapDeleteManyArgs>(args?: SelectSubset<T, SkillGapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkillGaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkillGaps
     * const skillGap = await prisma.skillGap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillGapUpdateManyArgs>(args: SelectSubset<T, SkillGapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SkillGap.
     * @param {SkillGapUpsertArgs} args - Arguments to update or create a SkillGap.
     * @example
     * // Update or create a SkillGap
     * const skillGap = await prisma.skillGap.upsert({
     *   create: {
     *     // ... data to create a SkillGap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkillGap we want to update
     *   }
     * })
     */
    upsert<T extends SkillGapUpsertArgs>(args: SelectSubset<T, SkillGapUpsertArgs<ExtArgs>>): Prisma__SkillGapClient<$Result.GetResult<Prisma.$SkillGapPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SkillGaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGapCountArgs} args - Arguments to filter SkillGaps to count.
     * @example
     * // Count the number of SkillGaps
     * const count = await prisma.skillGap.count({
     *   where: {
     *     // ... the filter for the SkillGaps we want to count
     *   }
     * })
    **/
    count<T extends SkillGapCountArgs>(
      args?: Subset<T, SkillGapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillGapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkillGap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillGapAggregateArgs>(args: Subset<T, SkillGapAggregateArgs>): Prisma.PrismaPromise<GetSkillGapAggregateType<T>>

    /**
     * Group by SkillGap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillGapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillGapGroupByArgs['orderBy'] }
        : { orderBy?: SkillGapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillGapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillGapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SkillGap model
   */
  readonly fields: SkillGapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SkillGap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillGapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    careerPath<T extends CareerPathDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CareerPathDefaultArgs<ExtArgs>>): Prisma__CareerPathClient<$Result.GetResult<Prisma.$CareerPathPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SkillGap model
   */ 
  interface SkillGapFieldRefs {
    readonly id: FieldRef<"SkillGap", 'String'>
    readonly careerPathId: FieldRef<"SkillGap", 'String'>
    readonly skillId: FieldRef<"SkillGap", 'String'>
    readonly currentLevel: FieldRef<"SkillGap", 'SkillLevel'>
    readonly targetLevel: FieldRef<"SkillGap", 'SkillLevel'>
    readonly priority: FieldRef<"SkillGap", 'Priority'>
  }
    

  // Custom InputTypes
  /**
   * SkillGap findUnique
   */
  export type SkillGapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillGap
     */
    select?: SkillGapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillGapInclude<ExtArgs> | null
    /**
     * Filter, which SkillGap to fetch.
     */
    where: SkillGapWhereUniqueInput
  }

  /**
   * SkillGap findUniqueOrThrow
   */
  export type SkillGapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillGap
     */
    select?: SkillGapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillGapInclude<ExtArgs> | null
    /**
     * Filter, which SkillGap to fetch.
     */
    where: SkillGapWhereUniqueInput
  }

  /**
   * SkillGap findFirst
   */
  export type SkillGapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillGap
     */
    select?: SkillGapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillGapInclude<ExtArgs> | null
    /**
     * Filter, which SkillGap to fetch.
     */
    where?: SkillGapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillGaps to fetch.
     */
    orderBy?: SkillGapOrderByWithRelationInput | SkillGapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkillGaps.
     */
    cursor?: SkillGapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillGaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillGaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkillGaps.
     */
    distinct?: SkillGapScalarFieldEnum | SkillGapScalarFieldEnum[]
  }

  /**
   * SkillGap findFirstOrThrow
   */
  export type SkillGapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillGap
     */
    select?: SkillGapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillGapInclude<ExtArgs> | null
    /**
     * Filter, which SkillGap to fetch.
     */
    where?: SkillGapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillGaps to fetch.
     */
    orderBy?: SkillGapOrderByWithRelationInput | SkillGapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkillGaps.
     */
    cursor?: SkillGapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillGaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillGaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkillGaps.
     */
    distinct?: SkillGapScalarFieldEnum | SkillGapScalarFieldEnum[]
  }

  /**
   * SkillGap findMany
   */
  export type SkillGapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillGap
     */
    select?: SkillGapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillGapInclude<ExtArgs> | null
    /**
     * Filter, which SkillGaps to fetch.
     */
    where?: SkillGapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillGaps to fetch.
     */
    orderBy?: SkillGapOrderByWithRelationInput | SkillGapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SkillGaps.
     */
    cursor?: SkillGapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillGaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillGaps.
     */
    skip?: number
    distinct?: SkillGapScalarFieldEnum | SkillGapScalarFieldEnum[]
  }

  /**
   * SkillGap create
   */
  export type SkillGapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillGap
     */
    select?: SkillGapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillGapInclude<ExtArgs> | null
    /**
     * The data needed to create a SkillGap.
     */
    data: XOR<SkillGapCreateInput, SkillGapUncheckedCreateInput>
  }

  /**
   * SkillGap createMany
   */
  export type SkillGapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SkillGaps.
     */
    data: SkillGapCreateManyInput | SkillGapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SkillGap createManyAndReturn
   */
  export type SkillGapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillGap
     */
    select?: SkillGapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SkillGaps.
     */
    data: SkillGapCreateManyInput | SkillGapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillGapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SkillGap update
   */
  export type SkillGapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillGap
     */
    select?: SkillGapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillGapInclude<ExtArgs> | null
    /**
     * The data needed to update a SkillGap.
     */
    data: XOR<SkillGapUpdateInput, SkillGapUncheckedUpdateInput>
    /**
     * Choose, which SkillGap to update.
     */
    where: SkillGapWhereUniqueInput
  }

  /**
   * SkillGap updateMany
   */
  export type SkillGapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SkillGaps.
     */
    data: XOR<SkillGapUpdateManyMutationInput, SkillGapUncheckedUpdateManyInput>
    /**
     * Filter which SkillGaps to update
     */
    where?: SkillGapWhereInput
  }

  /**
   * SkillGap upsert
   */
  export type SkillGapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillGap
     */
    select?: SkillGapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillGapInclude<ExtArgs> | null
    /**
     * The filter to search for the SkillGap to update in case it exists.
     */
    where: SkillGapWhereUniqueInput
    /**
     * In case the SkillGap found by the `where` argument doesn't exist, create a new SkillGap with this data.
     */
    create: XOR<SkillGapCreateInput, SkillGapUncheckedCreateInput>
    /**
     * In case the SkillGap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillGapUpdateInput, SkillGapUncheckedUpdateInput>
  }

  /**
   * SkillGap delete
   */
  export type SkillGapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillGap
     */
    select?: SkillGapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillGapInclude<ExtArgs> | null
    /**
     * Filter which SkillGap to delete.
     */
    where: SkillGapWhereUniqueInput
  }

  /**
   * SkillGap deleteMany
   */
  export type SkillGapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkillGaps to delete
     */
    where?: SkillGapWhereInput
  }

  /**
   * SkillGap without action
   */
  export type SkillGapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillGap
     */
    select?: SkillGapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillGapInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    duration: number | null
    rating: Decimal | null
    reviewCount: number | null
    price: number | null
  }

  export type CourseSumAggregateOutputType = {
    duration: number | null
    rating: Decimal | null
    reviewCount: number | null
    price: bigint | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    title: string | null
    provider: string | null
    description: string | null
    thumbnail: string | null
    duration: number | null
    level: $Enums.SkillLevel | null
    rating: Decimal | null
    reviewCount: number | null
    price: bigint | null
    url: string | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    title: string | null
    provider: string | null
    description: string | null
    thumbnail: string | null
    duration: number | null
    level: $Enums.SkillLevel | null
    rating: Decimal | null
    reviewCount: number | null
    price: bigint | null
    url: string | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    title: number
    provider: number
    description: number
    thumbnail: number
    duration: number
    level: number
    rating: number
    reviewCount: number
    price: number
    url: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    duration?: true
    rating?: true
    reviewCount?: true
    price?: true
  }

  export type CourseSumAggregateInputType = {
    duration?: true
    rating?: true
    reviewCount?: true
    price?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    title?: true
    provider?: true
    description?: true
    thumbnail?: true
    duration?: true
    level?: true
    rating?: true
    reviewCount?: true
    price?: true
    url?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    title?: true
    provider?: true
    description?: true
    thumbnail?: true
    duration?: true
    level?: true
    rating?: true
    reviewCount?: true
    price?: true
    url?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    title?: true
    provider?: true
    description?: true
    thumbnail?: true
    duration?: true
    level?: true
    rating?: true
    reviewCount?: true
    price?: true
    url?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    title: string
    provider: string
    description: string
    thumbnail: string | null
    duration: number
    level: $Enums.SkillLevel
    rating: Decimal
    reviewCount: number
    price: bigint
    url: string
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    provider?: boolean
    description?: boolean
    thumbnail?: boolean
    duration?: boolean
    level?: boolean
    rating?: boolean
    reviewCount?: boolean
    price?: boolean
    url?: boolean
    skills?: boolean | Course$skillsArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    provider?: boolean
    description?: boolean
    thumbnail?: boolean
    duration?: boolean
    level?: boolean
    rating?: boolean
    reviewCount?: boolean
    price?: boolean
    url?: boolean
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    title?: boolean
    provider?: boolean
    description?: boolean
    thumbnail?: boolean
    duration?: boolean
    level?: boolean
    rating?: boolean
    reviewCount?: boolean
    price?: boolean
    url?: boolean
  }

  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills?: boolean | Course$skillsArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      skills: Prisma.$CourseSkillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      provider: string
      description: string
      thumbnail: string | null
      duration: number
      level: $Enums.SkillLevel
      rating: Prisma.Decimal
      reviewCount: number
      price: bigint
      url: string
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skills<T extends Course$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Course$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */ 
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly title: FieldRef<"Course", 'String'>
    readonly provider: FieldRef<"Course", 'String'>
    readonly description: FieldRef<"Course", 'String'>
    readonly thumbnail: FieldRef<"Course", 'String'>
    readonly duration: FieldRef<"Course", 'Int'>
    readonly level: FieldRef<"Course", 'SkillLevel'>
    readonly rating: FieldRef<"Course", 'Decimal'>
    readonly reviewCount: FieldRef<"Course", 'Int'>
    readonly price: FieldRef<"Course", 'BigInt'>
    readonly url: FieldRef<"Course", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
  }

  /**
   * Course.skills
   */
  export type Course$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillInclude<ExtArgs> | null
    where?: CourseSkillWhereInput
    orderBy?: CourseSkillOrderByWithRelationInput | CourseSkillOrderByWithRelationInput[]
    cursor?: CourseSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseSkillScalarFieldEnum | CourseSkillScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model CourseSkill
   */

  export type AggregateCourseSkill = {
    _count: CourseSkillCountAggregateOutputType | null
    _min: CourseSkillMinAggregateOutputType | null
    _max: CourseSkillMaxAggregateOutputType | null
  }

  export type CourseSkillMinAggregateOutputType = {
    courseId: string | null
    skillId: string | null
  }

  export type CourseSkillMaxAggregateOutputType = {
    courseId: string | null
    skillId: string | null
  }

  export type CourseSkillCountAggregateOutputType = {
    courseId: number
    skillId: number
    _all: number
  }


  export type CourseSkillMinAggregateInputType = {
    courseId?: true
    skillId?: true
  }

  export type CourseSkillMaxAggregateInputType = {
    courseId?: true
    skillId?: true
  }

  export type CourseSkillCountAggregateInputType = {
    courseId?: true
    skillId?: true
    _all?: true
  }

  export type CourseSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseSkill to aggregate.
     */
    where?: CourseSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseSkills to fetch.
     */
    orderBy?: CourseSkillOrderByWithRelationInput | CourseSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseSkills
    **/
    _count?: true | CourseSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseSkillMaxAggregateInputType
  }

  export type GetCourseSkillAggregateType<T extends CourseSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseSkill[P]>
      : GetScalarType<T[P], AggregateCourseSkill[P]>
  }




  export type CourseSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseSkillWhereInput
    orderBy?: CourseSkillOrderByWithAggregationInput | CourseSkillOrderByWithAggregationInput[]
    by: CourseSkillScalarFieldEnum[] | CourseSkillScalarFieldEnum
    having?: CourseSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseSkillCountAggregateInputType | true
    _min?: CourseSkillMinAggregateInputType
    _max?: CourseSkillMaxAggregateInputType
  }

  export type CourseSkillGroupByOutputType = {
    courseId: string
    skillId: string
    _count: CourseSkillCountAggregateOutputType | null
    _min: CourseSkillMinAggregateOutputType | null
    _max: CourseSkillMaxAggregateOutputType | null
  }

  type GetCourseSkillGroupByPayload<T extends CourseSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseSkillGroupByOutputType[P]>
            : GetScalarType<T[P], CourseSkillGroupByOutputType[P]>
        }
      >
    >


  export type CourseSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    skillId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseSkill"]>

  export type CourseSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    skillId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseSkill"]>

  export type CourseSkillSelectScalar = {
    courseId?: boolean
    skillId?: boolean
  }

  export type CourseSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type CourseSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }

  export type $CourseSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseSkill"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      courseId: string
      skillId: string
    }, ExtArgs["result"]["courseSkill"]>
    composites: {}
  }

  type CourseSkillGetPayload<S extends boolean | null | undefined | CourseSkillDefaultArgs> = $Result.GetResult<Prisma.$CourseSkillPayload, S>

  type CourseSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseSkillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseSkillCountAggregateInputType | true
    }

  export interface CourseSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseSkill'], meta: { name: 'CourseSkill' } }
    /**
     * Find zero or one CourseSkill that matches the filter.
     * @param {CourseSkillFindUniqueArgs} args - Arguments to find a CourseSkill
     * @example
     * // Get one CourseSkill
     * const courseSkill = await prisma.courseSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseSkillFindUniqueArgs>(args: SelectSubset<T, CourseSkillFindUniqueArgs<ExtArgs>>): Prisma__CourseSkillClient<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CourseSkill that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseSkillFindUniqueOrThrowArgs} args - Arguments to find a CourseSkill
     * @example
     * // Get one CourseSkill
     * const courseSkill = await prisma.courseSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseSkillClient<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CourseSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseSkillFindFirstArgs} args - Arguments to find a CourseSkill
     * @example
     * // Get one CourseSkill
     * const courseSkill = await prisma.courseSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseSkillFindFirstArgs>(args?: SelectSubset<T, CourseSkillFindFirstArgs<ExtArgs>>): Prisma__CourseSkillClient<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CourseSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseSkillFindFirstOrThrowArgs} args - Arguments to find a CourseSkill
     * @example
     * // Get one CourseSkill
     * const courseSkill = await prisma.courseSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseSkillClient<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CourseSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseSkills
     * const courseSkills = await prisma.courseSkill.findMany()
     * 
     * // Get first 10 CourseSkills
     * const courseSkills = await prisma.courseSkill.findMany({ take: 10 })
     * 
     * // Only select the `courseId`
     * const courseSkillWithCourseIdOnly = await prisma.courseSkill.findMany({ select: { courseId: true } })
     * 
     */
    findMany<T extends CourseSkillFindManyArgs>(args?: SelectSubset<T, CourseSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CourseSkill.
     * @param {CourseSkillCreateArgs} args - Arguments to create a CourseSkill.
     * @example
     * // Create one CourseSkill
     * const CourseSkill = await prisma.courseSkill.create({
     *   data: {
     *     // ... data to create a CourseSkill
     *   }
     * })
     * 
     */
    create<T extends CourseSkillCreateArgs>(args: SelectSubset<T, CourseSkillCreateArgs<ExtArgs>>): Prisma__CourseSkillClient<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CourseSkills.
     * @param {CourseSkillCreateManyArgs} args - Arguments to create many CourseSkills.
     * @example
     * // Create many CourseSkills
     * const courseSkill = await prisma.courseSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseSkillCreateManyArgs>(args?: SelectSubset<T, CourseSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseSkills and returns the data saved in the database.
     * @param {CourseSkillCreateManyAndReturnArgs} args - Arguments to create many CourseSkills.
     * @example
     * // Create many CourseSkills
     * const courseSkill = await prisma.courseSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseSkills and only return the `courseId`
     * const courseSkillWithCourseIdOnly = await prisma.courseSkill.createManyAndReturn({ 
     *   select: { courseId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CourseSkill.
     * @param {CourseSkillDeleteArgs} args - Arguments to delete one CourseSkill.
     * @example
     * // Delete one CourseSkill
     * const CourseSkill = await prisma.courseSkill.delete({
     *   where: {
     *     // ... filter to delete one CourseSkill
     *   }
     * })
     * 
     */
    delete<T extends CourseSkillDeleteArgs>(args: SelectSubset<T, CourseSkillDeleteArgs<ExtArgs>>): Prisma__CourseSkillClient<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CourseSkill.
     * @param {CourseSkillUpdateArgs} args - Arguments to update one CourseSkill.
     * @example
     * // Update one CourseSkill
     * const courseSkill = await prisma.courseSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseSkillUpdateArgs>(args: SelectSubset<T, CourseSkillUpdateArgs<ExtArgs>>): Prisma__CourseSkillClient<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CourseSkills.
     * @param {CourseSkillDeleteManyArgs} args - Arguments to filter CourseSkills to delete.
     * @example
     * // Delete a few CourseSkills
     * const { count } = await prisma.courseSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseSkillDeleteManyArgs>(args?: SelectSubset<T, CourseSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseSkills
     * const courseSkill = await prisma.courseSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseSkillUpdateManyArgs>(args: SelectSubset<T, CourseSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseSkill.
     * @param {CourseSkillUpsertArgs} args - Arguments to update or create a CourseSkill.
     * @example
     * // Update or create a CourseSkill
     * const courseSkill = await prisma.courseSkill.upsert({
     *   create: {
     *     // ... data to create a CourseSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseSkill we want to update
     *   }
     * })
     */
    upsert<T extends CourseSkillUpsertArgs>(args: SelectSubset<T, CourseSkillUpsertArgs<ExtArgs>>): Prisma__CourseSkillClient<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CourseSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseSkillCountArgs} args - Arguments to filter CourseSkills to count.
     * @example
     * // Count the number of CourseSkills
     * const count = await prisma.courseSkill.count({
     *   where: {
     *     // ... the filter for the CourseSkills we want to count
     *   }
     * })
    **/
    count<T extends CourseSkillCountArgs>(
      args?: Subset<T, CourseSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseSkillAggregateArgs>(args: Subset<T, CourseSkillAggregateArgs>): Prisma.PrismaPromise<GetCourseSkillAggregateType<T>>

    /**
     * Group by CourseSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseSkillGroupByArgs['orderBy'] }
        : { orderBy?: CourseSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseSkill model
   */
  readonly fields: CourseSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseSkill model
   */ 
  interface CourseSkillFieldRefs {
    readonly courseId: FieldRef<"CourseSkill", 'String'>
    readonly skillId: FieldRef<"CourseSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CourseSkill findUnique
   */
  export type CourseSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillInclude<ExtArgs> | null
    /**
     * Filter, which CourseSkill to fetch.
     */
    where: CourseSkillWhereUniqueInput
  }

  /**
   * CourseSkill findUniqueOrThrow
   */
  export type CourseSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillInclude<ExtArgs> | null
    /**
     * Filter, which CourseSkill to fetch.
     */
    where: CourseSkillWhereUniqueInput
  }

  /**
   * CourseSkill findFirst
   */
  export type CourseSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillInclude<ExtArgs> | null
    /**
     * Filter, which CourseSkill to fetch.
     */
    where?: CourseSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseSkills to fetch.
     */
    orderBy?: CourseSkillOrderByWithRelationInput | CourseSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseSkills.
     */
    cursor?: CourseSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseSkills.
     */
    distinct?: CourseSkillScalarFieldEnum | CourseSkillScalarFieldEnum[]
  }

  /**
   * CourseSkill findFirstOrThrow
   */
  export type CourseSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillInclude<ExtArgs> | null
    /**
     * Filter, which CourseSkill to fetch.
     */
    where?: CourseSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseSkills to fetch.
     */
    orderBy?: CourseSkillOrderByWithRelationInput | CourseSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseSkills.
     */
    cursor?: CourseSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseSkills.
     */
    distinct?: CourseSkillScalarFieldEnum | CourseSkillScalarFieldEnum[]
  }

  /**
   * CourseSkill findMany
   */
  export type CourseSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillInclude<ExtArgs> | null
    /**
     * Filter, which CourseSkills to fetch.
     */
    where?: CourseSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseSkills to fetch.
     */
    orderBy?: CourseSkillOrderByWithRelationInput | CourseSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseSkills.
     */
    cursor?: CourseSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseSkills.
     */
    skip?: number
    distinct?: CourseSkillScalarFieldEnum | CourseSkillScalarFieldEnum[]
  }

  /**
   * CourseSkill create
   */
  export type CourseSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseSkill.
     */
    data: XOR<CourseSkillCreateInput, CourseSkillUncheckedCreateInput>
  }

  /**
   * CourseSkill createMany
   */
  export type CourseSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseSkills.
     */
    data: CourseSkillCreateManyInput | CourseSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseSkill createManyAndReturn
   */
  export type CourseSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CourseSkills.
     */
    data: CourseSkillCreateManyInput | CourseSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseSkill update
   */
  export type CourseSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseSkill.
     */
    data: XOR<CourseSkillUpdateInput, CourseSkillUncheckedUpdateInput>
    /**
     * Choose, which CourseSkill to update.
     */
    where: CourseSkillWhereUniqueInput
  }

  /**
   * CourseSkill updateMany
   */
  export type CourseSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseSkills.
     */
    data: XOR<CourseSkillUpdateManyMutationInput, CourseSkillUncheckedUpdateManyInput>
    /**
     * Filter which CourseSkills to update
     */
    where?: CourseSkillWhereInput
  }

  /**
   * CourseSkill upsert
   */
  export type CourseSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseSkill to update in case it exists.
     */
    where: CourseSkillWhereUniqueInput
    /**
     * In case the CourseSkill found by the `where` argument doesn't exist, create a new CourseSkill with this data.
     */
    create: XOR<CourseSkillCreateInput, CourseSkillUncheckedCreateInput>
    /**
     * In case the CourseSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseSkillUpdateInput, CourseSkillUncheckedUpdateInput>
  }

  /**
   * CourseSkill delete
   */
  export type CourseSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillInclude<ExtArgs> | null
    /**
     * Filter which CourseSkill to delete.
     */
    where: CourseSkillWhereUniqueInput
  }

  /**
   * CourseSkill deleteMany
   */
  export type CourseSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseSkills to delete
     */
    where?: CourseSkillWhereInput
  }

  /**
   * CourseSkill without action
   */
  export type CourseSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillInclude<ExtArgs> | null
  }


  /**
   * Model VerificationRequest
   */

  export type AggregateVerificationRequest = {
    _count: VerificationRequestCountAggregateOutputType | null
    _min: VerificationRequestMinAggregateOutputType | null
    _max: VerificationRequestMaxAggregateOutputType | null
  }

  export type VerificationRequestMinAggregateOutputType = {
    id: string | null
    credentialId: string | null
    requestedBy: string | null
    status: $Enums.VerificationStatus | null
    blockchainHash: string | null
    requestedAt: Date | null
    processedAt: Date | null
  }

  export type VerificationRequestMaxAggregateOutputType = {
    id: string | null
    credentialId: string | null
    requestedBy: string | null
    status: $Enums.VerificationStatus | null
    blockchainHash: string | null
    requestedAt: Date | null
    processedAt: Date | null
  }

  export type VerificationRequestCountAggregateOutputType = {
    id: number
    credentialId: number
    requestedBy: number
    status: number
    blockchainHash: number
    requestedAt: number
    processedAt: number
    _all: number
  }


  export type VerificationRequestMinAggregateInputType = {
    id?: true
    credentialId?: true
    requestedBy?: true
    status?: true
    blockchainHash?: true
    requestedAt?: true
    processedAt?: true
  }

  export type VerificationRequestMaxAggregateInputType = {
    id?: true
    credentialId?: true
    requestedBy?: true
    status?: true
    blockchainHash?: true
    requestedAt?: true
    processedAt?: true
  }

  export type VerificationRequestCountAggregateInputType = {
    id?: true
    credentialId?: true
    requestedBy?: true
    status?: true
    blockchainHash?: true
    requestedAt?: true
    processedAt?: true
    _all?: true
  }

  export type VerificationRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationRequest to aggregate.
     */
    where?: VerificationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationRequests to fetch.
     */
    orderBy?: VerificationRequestOrderByWithRelationInput | VerificationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationRequests
    **/
    _count?: true | VerificationRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationRequestMaxAggregateInputType
  }

  export type GetVerificationRequestAggregateType<T extends VerificationRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationRequest[P]>
      : GetScalarType<T[P], AggregateVerificationRequest[P]>
  }




  export type VerificationRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationRequestWhereInput
    orderBy?: VerificationRequestOrderByWithAggregationInput | VerificationRequestOrderByWithAggregationInput[]
    by: VerificationRequestScalarFieldEnum[] | VerificationRequestScalarFieldEnum
    having?: VerificationRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationRequestCountAggregateInputType | true
    _min?: VerificationRequestMinAggregateInputType
    _max?: VerificationRequestMaxAggregateInputType
  }

  export type VerificationRequestGroupByOutputType = {
    id: string
    credentialId: string
    requestedBy: string
    status: $Enums.VerificationStatus
    blockchainHash: string | null
    requestedAt: Date
    processedAt: Date | null
    _count: VerificationRequestCountAggregateOutputType | null
    _min: VerificationRequestMinAggregateOutputType | null
    _max: VerificationRequestMaxAggregateOutputType | null
  }

  type GetVerificationRequestGroupByPayload<T extends VerificationRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationRequestGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationRequestGroupByOutputType[P]>
        }
      >
    >


  export type VerificationRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    credentialId?: boolean
    requestedBy?: boolean
    status?: boolean
    blockchainHash?: boolean
    requestedAt?: boolean
    processedAt?: boolean
    credential?: boolean | CredentialDefaultArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verificationRequest"]>

  export type VerificationRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    credentialId?: boolean
    requestedBy?: boolean
    status?: boolean
    blockchainHash?: boolean
    requestedAt?: boolean
    processedAt?: boolean
    credential?: boolean | CredentialDefaultArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verificationRequest"]>

  export type VerificationRequestSelectScalar = {
    id?: boolean
    credentialId?: boolean
    requestedBy?: boolean
    status?: boolean
    blockchainHash?: boolean
    requestedAt?: boolean
    processedAt?: boolean
  }

  export type VerificationRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credential?: boolean | CredentialDefaultArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VerificationRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credential?: boolean | CredentialDefaultArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VerificationRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationRequest"
    objects: {
      credential: Prisma.$CredentialPayload<ExtArgs>
      requester: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      credentialId: string
      requestedBy: string
      status: $Enums.VerificationStatus
      blockchainHash: string | null
      requestedAt: Date
      processedAt: Date | null
    }, ExtArgs["result"]["verificationRequest"]>
    composites: {}
  }

  type VerificationRequestGetPayload<S extends boolean | null | undefined | VerificationRequestDefaultArgs> = $Result.GetResult<Prisma.$VerificationRequestPayload, S>

  type VerificationRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VerificationRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VerificationRequestCountAggregateInputType | true
    }

  export interface VerificationRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationRequest'], meta: { name: 'VerificationRequest' } }
    /**
     * Find zero or one VerificationRequest that matches the filter.
     * @param {VerificationRequestFindUniqueArgs} args - Arguments to find a VerificationRequest
     * @example
     * // Get one VerificationRequest
     * const verificationRequest = await prisma.verificationRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationRequestFindUniqueArgs>(args: SelectSubset<T, VerificationRequestFindUniqueArgs<ExtArgs>>): Prisma__VerificationRequestClient<$Result.GetResult<Prisma.$VerificationRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VerificationRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VerificationRequestFindUniqueOrThrowArgs} args - Arguments to find a VerificationRequest
     * @example
     * // Get one VerificationRequest
     * const verificationRequest = await prisma.verificationRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationRequestClient<$Result.GetResult<Prisma.$VerificationRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VerificationRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationRequestFindFirstArgs} args - Arguments to find a VerificationRequest
     * @example
     * // Get one VerificationRequest
     * const verificationRequest = await prisma.verificationRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationRequestFindFirstArgs>(args?: SelectSubset<T, VerificationRequestFindFirstArgs<ExtArgs>>): Prisma__VerificationRequestClient<$Result.GetResult<Prisma.$VerificationRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VerificationRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationRequestFindFirstOrThrowArgs} args - Arguments to find a VerificationRequest
     * @example
     * // Get one VerificationRequest
     * const verificationRequest = await prisma.verificationRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationRequestClient<$Result.GetResult<Prisma.$VerificationRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VerificationRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationRequests
     * const verificationRequests = await prisma.verificationRequest.findMany()
     * 
     * // Get first 10 VerificationRequests
     * const verificationRequests = await prisma.verificationRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationRequestWithIdOnly = await prisma.verificationRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationRequestFindManyArgs>(args?: SelectSubset<T, VerificationRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VerificationRequest.
     * @param {VerificationRequestCreateArgs} args - Arguments to create a VerificationRequest.
     * @example
     * // Create one VerificationRequest
     * const VerificationRequest = await prisma.verificationRequest.create({
     *   data: {
     *     // ... data to create a VerificationRequest
     *   }
     * })
     * 
     */
    create<T extends VerificationRequestCreateArgs>(args: SelectSubset<T, VerificationRequestCreateArgs<ExtArgs>>): Prisma__VerificationRequestClient<$Result.GetResult<Prisma.$VerificationRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VerificationRequests.
     * @param {VerificationRequestCreateManyArgs} args - Arguments to create many VerificationRequests.
     * @example
     * // Create many VerificationRequests
     * const verificationRequest = await prisma.verificationRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationRequestCreateManyArgs>(args?: SelectSubset<T, VerificationRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationRequests and returns the data saved in the database.
     * @param {VerificationRequestCreateManyAndReturnArgs} args - Arguments to create many VerificationRequests.
     * @example
     * // Create many VerificationRequests
     * const verificationRequest = await prisma.verificationRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationRequests and only return the `id`
     * const verificationRequestWithIdOnly = await prisma.verificationRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VerificationRequest.
     * @param {VerificationRequestDeleteArgs} args - Arguments to delete one VerificationRequest.
     * @example
     * // Delete one VerificationRequest
     * const VerificationRequest = await prisma.verificationRequest.delete({
     *   where: {
     *     // ... filter to delete one VerificationRequest
     *   }
     * })
     * 
     */
    delete<T extends VerificationRequestDeleteArgs>(args: SelectSubset<T, VerificationRequestDeleteArgs<ExtArgs>>): Prisma__VerificationRequestClient<$Result.GetResult<Prisma.$VerificationRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VerificationRequest.
     * @param {VerificationRequestUpdateArgs} args - Arguments to update one VerificationRequest.
     * @example
     * // Update one VerificationRequest
     * const verificationRequest = await prisma.verificationRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationRequestUpdateArgs>(args: SelectSubset<T, VerificationRequestUpdateArgs<ExtArgs>>): Prisma__VerificationRequestClient<$Result.GetResult<Prisma.$VerificationRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VerificationRequests.
     * @param {VerificationRequestDeleteManyArgs} args - Arguments to filter VerificationRequests to delete.
     * @example
     * // Delete a few VerificationRequests
     * const { count } = await prisma.verificationRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationRequestDeleteManyArgs>(args?: SelectSubset<T, VerificationRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationRequests
     * const verificationRequest = await prisma.verificationRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationRequestUpdateManyArgs>(args: SelectSubset<T, VerificationRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationRequest.
     * @param {VerificationRequestUpsertArgs} args - Arguments to update or create a VerificationRequest.
     * @example
     * // Update or create a VerificationRequest
     * const verificationRequest = await prisma.verificationRequest.upsert({
     *   create: {
     *     // ... data to create a VerificationRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationRequest we want to update
     *   }
     * })
     */
    upsert<T extends VerificationRequestUpsertArgs>(args: SelectSubset<T, VerificationRequestUpsertArgs<ExtArgs>>): Prisma__VerificationRequestClient<$Result.GetResult<Prisma.$VerificationRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VerificationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationRequestCountArgs} args - Arguments to filter VerificationRequests to count.
     * @example
     * // Count the number of VerificationRequests
     * const count = await prisma.verificationRequest.count({
     *   where: {
     *     // ... the filter for the VerificationRequests we want to count
     *   }
     * })
    **/
    count<T extends VerificationRequestCountArgs>(
      args?: Subset<T, VerificationRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationRequestAggregateArgs>(args: Subset<T, VerificationRequestAggregateArgs>): Prisma.PrismaPromise<GetVerificationRequestAggregateType<T>>

    /**
     * Group by VerificationRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationRequestGroupByArgs['orderBy'] }
        : { orderBy?: VerificationRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationRequest model
   */
  readonly fields: VerificationRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    credential<T extends CredentialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CredentialDefaultArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    requester<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationRequest model
   */ 
  interface VerificationRequestFieldRefs {
    readonly id: FieldRef<"VerificationRequest", 'String'>
    readonly credentialId: FieldRef<"VerificationRequest", 'String'>
    readonly requestedBy: FieldRef<"VerificationRequest", 'String'>
    readonly status: FieldRef<"VerificationRequest", 'VerificationStatus'>
    readonly blockchainHash: FieldRef<"VerificationRequest", 'String'>
    readonly requestedAt: FieldRef<"VerificationRequest", 'DateTime'>
    readonly processedAt: FieldRef<"VerificationRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationRequest findUnique
   */
  export type VerificationRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationRequestInclude<ExtArgs> | null
    /**
     * Filter, which VerificationRequest to fetch.
     */
    where: VerificationRequestWhereUniqueInput
  }

  /**
   * VerificationRequest findUniqueOrThrow
   */
  export type VerificationRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationRequestInclude<ExtArgs> | null
    /**
     * Filter, which VerificationRequest to fetch.
     */
    where: VerificationRequestWhereUniqueInput
  }

  /**
   * VerificationRequest findFirst
   */
  export type VerificationRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationRequestInclude<ExtArgs> | null
    /**
     * Filter, which VerificationRequest to fetch.
     */
    where?: VerificationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationRequests to fetch.
     */
    orderBy?: VerificationRequestOrderByWithRelationInput | VerificationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationRequests.
     */
    cursor?: VerificationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationRequests.
     */
    distinct?: VerificationRequestScalarFieldEnum | VerificationRequestScalarFieldEnum[]
  }

  /**
   * VerificationRequest findFirstOrThrow
   */
  export type VerificationRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationRequestInclude<ExtArgs> | null
    /**
     * Filter, which VerificationRequest to fetch.
     */
    where?: VerificationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationRequests to fetch.
     */
    orderBy?: VerificationRequestOrderByWithRelationInput | VerificationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationRequests.
     */
    cursor?: VerificationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationRequests.
     */
    distinct?: VerificationRequestScalarFieldEnum | VerificationRequestScalarFieldEnum[]
  }

  /**
   * VerificationRequest findMany
   */
  export type VerificationRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationRequestInclude<ExtArgs> | null
    /**
     * Filter, which VerificationRequests to fetch.
     */
    where?: VerificationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationRequests to fetch.
     */
    orderBy?: VerificationRequestOrderByWithRelationInput | VerificationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationRequests.
     */
    cursor?: VerificationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationRequests.
     */
    skip?: number
    distinct?: VerificationRequestScalarFieldEnum | VerificationRequestScalarFieldEnum[]
  }

  /**
   * VerificationRequest create
   */
  export type VerificationRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a VerificationRequest.
     */
    data: XOR<VerificationRequestCreateInput, VerificationRequestUncheckedCreateInput>
  }

  /**
   * VerificationRequest createMany
   */
  export type VerificationRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationRequests.
     */
    data: VerificationRequestCreateManyInput | VerificationRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationRequest createManyAndReturn
   */
  export type VerificationRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VerificationRequests.
     */
    data: VerificationRequestCreateManyInput | VerificationRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerificationRequest update
   */
  export type VerificationRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a VerificationRequest.
     */
    data: XOR<VerificationRequestUpdateInput, VerificationRequestUncheckedUpdateInput>
    /**
     * Choose, which VerificationRequest to update.
     */
    where: VerificationRequestWhereUniqueInput
  }

  /**
   * VerificationRequest updateMany
   */
  export type VerificationRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationRequests.
     */
    data: XOR<VerificationRequestUpdateManyMutationInput, VerificationRequestUncheckedUpdateManyInput>
    /**
     * Filter which VerificationRequests to update
     */
    where?: VerificationRequestWhereInput
  }

  /**
   * VerificationRequest upsert
   */
  export type VerificationRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the VerificationRequest to update in case it exists.
     */
    where: VerificationRequestWhereUniqueInput
    /**
     * In case the VerificationRequest found by the `where` argument doesn't exist, create a new VerificationRequest with this data.
     */
    create: XOR<VerificationRequestCreateInput, VerificationRequestUncheckedCreateInput>
    /**
     * In case the VerificationRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationRequestUpdateInput, VerificationRequestUncheckedUpdateInput>
  }

  /**
   * VerificationRequest delete
   */
  export type VerificationRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationRequestInclude<ExtArgs> | null
    /**
     * Filter which VerificationRequest to delete.
     */
    where: VerificationRequestWhereUniqueInput
  }

  /**
   * VerificationRequest deleteMany
   */
  export type VerificationRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationRequests to delete
     */
    where?: VerificationRequestWhereInput
  }

  /**
   * VerificationRequest without action
   */
  export type VerificationRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     */
    select?: VerificationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationRequestInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    content: string | null
    read: boolean | null
    sentAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    content: string | null
    read: boolean | null
    sentAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    senderId: number
    receiverId: number
    content: number
    read: number
    sentAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    read?: true
    sentAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    read?: true
    sentAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    read?: true
    sentAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    senderId: string
    receiverId: string
    content: string
    read: boolean
    sentAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    read?: boolean
    sentAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    read?: boolean
    sentAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    read?: boolean
    sentAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      receiver: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      senderId: string
      receiverId: string
      content: string
      read: boolean
      sentAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    receiver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly receiverId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly read: FieldRef<"Message", 'Boolean'>
    readonly sentAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    passwordHash: 'passwordHash',
    avatar: 'avatar',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const LearnerProfileScalarFieldEnum: {
    userId: 'userId',
    bio: 'bio',
    location: 'location',
    university: 'university',
    major: 'major',
    graduationYear: 'graduationYear',
    skillsMatchPercentage: 'skillsMatchPercentage',
    verificationStatus: 'verificationStatus'
  };

  export type LearnerProfileScalarFieldEnum = (typeof LearnerProfileScalarFieldEnum)[keyof typeof LearnerProfileScalarFieldEnum]


  export const SkillScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    description: 'description',
    verified: 'verified',
    trending: 'trending'
  };

  export type SkillScalarFieldEnum = (typeof SkillScalarFieldEnum)[keyof typeof SkillScalarFieldEnum]


  export const UserSkillScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    skillId: 'skillId',
    level: 'level',
    endorsements: 'endorsements',
    verified: 'verified',
    addedAt: 'addedAt'
  };

  export type UserSkillScalarFieldEnum = (typeof UserSkillScalarFieldEnum)[keyof typeof UserSkillScalarFieldEnum]


  export const TrendingSkillScalarFieldEnum: {
    skillId: 'skillId',
    demandPercentage: 'demandPercentage',
    growthRate: 'growthRate',
    averageSalary: 'averageSalary',
    openPositions: 'openPositions',
    updatedAt: 'updatedAt'
  };

  export type TrendingSkillScalarFieldEnum = (typeof TrendingSkillScalarFieldEnum)[keyof typeof TrendingSkillScalarFieldEnum]


  export const CredentialScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    issuer: 'issuer',
    type: 'type',
    issueDate: 'issueDate',
    expiryDate: 'expiryDate',
    verified: 'verified',
    blockchainHash: 'blockchainHash',
    qrCode: 'qrCode',
    createdAt: 'createdAt'
  };

  export type CredentialScalarFieldEnum = (typeof CredentialScalarFieldEnum)[keyof typeof CredentialScalarFieldEnum]


  export const CredentialSkillScalarFieldEnum: {
    credentialId: 'credentialId',
    skillId: 'skillId'
  };

  export type CredentialSkillScalarFieldEnum = (typeof CredentialSkillScalarFieldEnum)[keyof typeof CredentialSkillScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    visibility: 'visibility',
    verified: 'verified',
    githubUrl: 'githubUrl',
    liveUrl: 'liveUrl',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectMediaScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    type: 'type',
    url: 'url',
    thumbnail: 'thumbnail',
    caption: 'caption',
    displayOrder: 'displayOrder'
  };

  export type ProjectMediaScalarFieldEnum = (typeof ProjectMediaScalarFieldEnum)[keyof typeof ProjectMediaScalarFieldEnum]


  export const ProjectSkillScalarFieldEnum: {
    projectId: 'projectId',
    skillId: 'skillId'
  };

  export type ProjectSkillScalarFieldEnum = (typeof ProjectSkillScalarFieldEnum)[keyof typeof ProjectSkillScalarFieldEnum]


  export const ProjectCollaboratorScalarFieldEnum: {
    projectId: 'projectId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt'
  };

  export type ProjectCollaboratorScalarFieldEnum = (typeof ProjectCollaboratorScalarFieldEnum)[keyof typeof ProjectCollaboratorScalarFieldEnum]


  export const EndorsementScalarFieldEnum: {
    id: 'id',
    endorserId: 'endorserId',
    comment: 'comment',
    createdAt: 'createdAt',
    projectId: 'projectId'
  };

  export type EndorsementScalarFieldEnum = (typeof EndorsementScalarFieldEnum)[keyof typeof EndorsementScalarFieldEnum]


  export const OpportunityScalarFieldEnum: {
    id: 'id',
    title: 'title',
    company: 'company',
    companyLogo: 'companyLogo',
    type: 'type',
    location: 'location',
    remote: 'remote',
    description: 'description',
    salaryMin: 'salaryMin',
    salaryMax: 'salaryMax',
    postedDate: 'postedDate',
    deadline: 'deadline',
    applicationUrl: 'applicationUrl',
    createdAt: 'createdAt'
  };

  export type OpportunityScalarFieldEnum = (typeof OpportunityScalarFieldEnum)[keyof typeof OpportunityScalarFieldEnum]


  export const OpportunityRequirementScalarFieldEnum: {
    id: 'id',
    opportunityId: 'opportunityId',
    requirement: 'requirement',
    displayOrder: 'displayOrder'
  };

  export type OpportunityRequirementScalarFieldEnum = (typeof OpportunityRequirementScalarFieldEnum)[keyof typeof OpportunityRequirementScalarFieldEnum]


  export const OpportunitySkillScalarFieldEnum: {
    opportunityId: 'opportunityId',
    skillId: 'skillId'
  };

  export type OpportunitySkillScalarFieldEnum = (typeof OpportunitySkillScalarFieldEnum)[keyof typeof OpportunitySkillScalarFieldEnum]


  export const ApplicationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    opportunityId: 'opportunityId',
    status: 'status',
    coverLetter: 'coverLetter',
    resumeUrl: 'resumeUrl',
    appliedAt: 'appliedAt',
    updatedAt: 'updatedAt'
  };

  export type ApplicationScalarFieldEnum = (typeof ApplicationScalarFieldEnum)[keyof typeof ApplicationScalarFieldEnum]


  export const ConnectionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    connectedUserId: 'connectedUserId',
    type: 'type',
    mutualConnections: 'mutualConnections',
    connectedAt: 'connectedAt'
  };

  export type ConnectionScalarFieldEnum = (typeof ConnectionScalarFieldEnum)[keyof typeof ConnectionScalarFieldEnum]


  export const ConnectionRequestScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    receiverId: 'receiverId',
    message: 'message',
    status: 'status',
    requestedAt: 'requestedAt',
    respondedAt: 'respondedAt'
  };

  export type ConnectionRequestScalarFieldEnum = (typeof ConnectionRequestScalarFieldEnum)[keyof typeof ConnectionRequestScalarFieldEnum]


  export const FeedItemScalarFieldEnum: {
    id: 'id',
    type: 'type',
    userId: 'userId',
    priority: 'priority',
    title: 'title',
    description: 'description',
    image: 'image',
    data: 'data',
    timestamp: 'timestamp'
  };

  export type FeedItemScalarFieldEnum = (typeof FeedItemScalarFieldEnum)[keyof typeof FeedItemScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    read: 'read',
    actionUrl: 'actionUrl',
    icon: 'icon',
    timestamp: 'timestamp'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const CareerPathScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    currentRole: 'currentRole',
    targetRole: 'targetRole',
    estimatedDuration: 'estimatedDuration',
    createdAt: 'createdAt'
  };

  export type CareerPathScalarFieldEnum = (typeof CareerPathScalarFieldEnum)[keyof typeof CareerPathScalarFieldEnum]


  export const CareerPathNodeScalarFieldEnum: {
    id: 'id',
    careerPathId: 'careerPathId',
    stageNumber: 'stageNumber',
    title: 'title',
    duration: 'duration',
    completed: 'completed'
  };

  export type CareerPathNodeScalarFieldEnum = (typeof CareerPathNodeScalarFieldEnum)[keyof typeof CareerPathNodeScalarFieldEnum]


  export const SkillGapScalarFieldEnum: {
    id: 'id',
    careerPathId: 'careerPathId',
    skillId: 'skillId',
    currentLevel: 'currentLevel',
    targetLevel: 'targetLevel',
    priority: 'priority'
  };

  export type SkillGapScalarFieldEnum = (typeof SkillGapScalarFieldEnum)[keyof typeof SkillGapScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    provider: 'provider',
    description: 'description',
    thumbnail: 'thumbnail',
    duration: 'duration',
    level: 'level',
    rating: 'rating',
    reviewCount: 'reviewCount',
    price: 'price',
    url: 'url'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const CourseSkillScalarFieldEnum: {
    courseId: 'courseId',
    skillId: 'skillId'
  };

  export type CourseSkillScalarFieldEnum = (typeof CourseSkillScalarFieldEnum)[keyof typeof CourseSkillScalarFieldEnum]


  export const VerificationRequestScalarFieldEnum: {
    id: 'id',
    credentialId: 'credentialId',
    requestedBy: 'requestedBy',
    status: 'status',
    blockchainHash: 'blockchainHash',
    requestedAt: 'requestedAt',
    processedAt: 'processedAt'
  };

  export type VerificationRequestScalarFieldEnum = (typeof VerificationRequestScalarFieldEnum)[keyof typeof VerificationRequestScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    receiverId: 'receiverId',
    content: 'content',
    read: 'read',
    sentAt: 'sentAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'VerificationStatus'
   */
  export type EnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus'>
    


  /**
   * Reference to a field of type 'VerificationStatus[]'
   */
  export type ListEnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus[]'>
    


  /**
   * Reference to a field of type 'SkillCategory'
   */
  export type EnumSkillCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SkillCategory'>
    


  /**
   * Reference to a field of type 'SkillCategory[]'
   */
  export type ListEnumSkillCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SkillCategory[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'SkillLevel'
   */
  export type EnumSkillLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SkillLevel'>
    


  /**
   * Reference to a field of type 'SkillLevel[]'
   */
  export type ListEnumSkillLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SkillLevel[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'CredentialType'
   */
  export type EnumCredentialTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CredentialType'>
    


  /**
   * Reference to a field of type 'CredentialType[]'
   */
  export type ListEnumCredentialTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CredentialType[]'>
    


  /**
   * Reference to a field of type 'ProjectVisibility'
   */
  export type EnumProjectVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectVisibility'>
    


  /**
   * Reference to a field of type 'ProjectVisibility[]'
   */
  export type ListEnumProjectVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectVisibility[]'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


  /**
   * Reference to a field of type 'MediaType[]'
   */
  export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    


  /**
   * Reference to a field of type 'OpportunityType'
   */
  export type EnumOpportunityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OpportunityType'>
    


  /**
   * Reference to a field of type 'OpportunityType[]'
   */
  export type ListEnumOpportunityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OpportunityType[]'>
    


  /**
   * Reference to a field of type 'ApplicationStatus'
   */
  export type EnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus'>
    


  /**
   * Reference to a field of type 'ApplicationStatus[]'
   */
  export type ListEnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus[]'>
    


  /**
   * Reference to a field of type 'ConnectionType'
   */
  export type EnumConnectionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConnectionType'>
    


  /**
   * Reference to a field of type 'ConnectionType[]'
   */
  export type ListEnumConnectionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConnectionType[]'>
    


  /**
   * Reference to a field of type 'ConnectionStatus'
   */
  export type EnumConnectionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConnectionStatus'>
    


  /**
   * Reference to a field of type 'ConnectionStatus[]'
   */
  export type ListEnumConnectionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConnectionStatus[]'>
    


  /**
   * Reference to a field of type 'FeedItemType'
   */
  export type EnumFeedItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedItemType'>
    


  /**
   * Reference to a field of type 'FeedItemType[]'
   */
  export type ListEnumFeedItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedItemType[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    learnerProfile?: XOR<LearnerProfileNullableRelationFilter, LearnerProfileWhereInput> | null
    userSkills?: UserSkillListRelationFilter
    credentials?: CredentialListRelationFilter
    projects?: ProjectListRelationFilter
    applications?: ApplicationListRelationFilter
    connectionsSent?: ConnectionListRelationFilter
    connectionsReceived?: ConnectionListRelationFilter
    connectionRequestsSent?: ConnectionRequestListRelationFilter
    connectionRequestsReceived?: ConnectionRequestListRelationFilter
    feedItems?: FeedItemListRelationFilter
    notifications?: NotificationListRelationFilter
    careerPaths?: CareerPathListRelationFilter
    messagesSent?: MessageListRelationFilter
    messagesReceived?: MessageListRelationFilter
    projectCollaborations?: ProjectCollaboratorListRelationFilter
    endorsements?: EndorsementListRelationFilter
    verificationRequests?: VerificationRequestListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    avatar?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    learnerProfile?: LearnerProfileOrderByWithRelationInput
    userSkills?: UserSkillOrderByRelationAggregateInput
    credentials?: CredentialOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    applications?: ApplicationOrderByRelationAggregateInput
    connectionsSent?: ConnectionOrderByRelationAggregateInput
    connectionsReceived?: ConnectionOrderByRelationAggregateInput
    connectionRequestsSent?: ConnectionRequestOrderByRelationAggregateInput
    connectionRequestsReceived?: ConnectionRequestOrderByRelationAggregateInput
    feedItems?: FeedItemOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    careerPaths?: CareerPathOrderByRelationAggregateInput
    messagesSent?: MessageOrderByRelationAggregateInput
    messagesReceived?: MessageOrderByRelationAggregateInput
    projectCollaborations?: ProjectCollaboratorOrderByRelationAggregateInput
    endorsements?: EndorsementOrderByRelationAggregateInput
    verificationRequests?: VerificationRequestOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    learnerProfile?: XOR<LearnerProfileNullableRelationFilter, LearnerProfileWhereInput> | null
    userSkills?: UserSkillListRelationFilter
    credentials?: CredentialListRelationFilter
    projects?: ProjectListRelationFilter
    applications?: ApplicationListRelationFilter
    connectionsSent?: ConnectionListRelationFilter
    connectionsReceived?: ConnectionListRelationFilter
    connectionRequestsSent?: ConnectionRequestListRelationFilter
    connectionRequestsReceived?: ConnectionRequestListRelationFilter
    feedItems?: FeedItemListRelationFilter
    notifications?: NotificationListRelationFilter
    careerPaths?: CareerPathListRelationFilter
    messagesSent?: MessageListRelationFilter
    messagesReceived?: MessageListRelationFilter
    projectCollaborations?: ProjectCollaboratorListRelationFilter
    endorsements?: EndorsementListRelationFilter
    verificationRequests?: VerificationRequestListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    avatar?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type LearnerProfileWhereInput = {
    AND?: LearnerProfileWhereInput | LearnerProfileWhereInput[]
    OR?: LearnerProfileWhereInput[]
    NOT?: LearnerProfileWhereInput | LearnerProfileWhereInput[]
    userId?: StringFilter<"LearnerProfile"> | string
    bio?: StringNullableFilter<"LearnerProfile"> | string | null
    location?: StringNullableFilter<"LearnerProfile"> | string | null
    university?: StringNullableFilter<"LearnerProfile"> | string | null
    major?: StringNullableFilter<"LearnerProfile"> | string | null
    graduationYear?: IntNullableFilter<"LearnerProfile"> | number | null
    skillsMatchPercentage?: IntFilter<"LearnerProfile"> | number
    verificationStatus?: EnumVerificationStatusFilter<"LearnerProfile"> | $Enums.VerificationStatus
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LearnerProfileOrderByWithRelationInput = {
    userId?: SortOrder
    bio?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    university?: SortOrderInput | SortOrder
    major?: SortOrderInput | SortOrder
    graduationYear?: SortOrderInput | SortOrder
    skillsMatchPercentage?: SortOrder
    verificationStatus?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LearnerProfileWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: LearnerProfileWhereInput | LearnerProfileWhereInput[]
    OR?: LearnerProfileWhereInput[]
    NOT?: LearnerProfileWhereInput | LearnerProfileWhereInput[]
    bio?: StringNullableFilter<"LearnerProfile"> | string | null
    location?: StringNullableFilter<"LearnerProfile"> | string | null
    university?: StringNullableFilter<"LearnerProfile"> | string | null
    major?: StringNullableFilter<"LearnerProfile"> | string | null
    graduationYear?: IntNullableFilter<"LearnerProfile"> | number | null
    skillsMatchPercentage?: IntFilter<"LearnerProfile"> | number
    verificationStatus?: EnumVerificationStatusFilter<"LearnerProfile"> | $Enums.VerificationStatus
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "userId">

  export type LearnerProfileOrderByWithAggregationInput = {
    userId?: SortOrder
    bio?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    university?: SortOrderInput | SortOrder
    major?: SortOrderInput | SortOrder
    graduationYear?: SortOrderInput | SortOrder
    skillsMatchPercentage?: SortOrder
    verificationStatus?: SortOrder
    _count?: LearnerProfileCountOrderByAggregateInput
    _avg?: LearnerProfileAvgOrderByAggregateInput
    _max?: LearnerProfileMaxOrderByAggregateInput
    _min?: LearnerProfileMinOrderByAggregateInput
    _sum?: LearnerProfileSumOrderByAggregateInput
  }

  export type LearnerProfileScalarWhereWithAggregatesInput = {
    AND?: LearnerProfileScalarWhereWithAggregatesInput | LearnerProfileScalarWhereWithAggregatesInput[]
    OR?: LearnerProfileScalarWhereWithAggregatesInput[]
    NOT?: LearnerProfileScalarWhereWithAggregatesInput | LearnerProfileScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"LearnerProfile"> | string
    bio?: StringNullableWithAggregatesFilter<"LearnerProfile"> | string | null
    location?: StringNullableWithAggregatesFilter<"LearnerProfile"> | string | null
    university?: StringNullableWithAggregatesFilter<"LearnerProfile"> | string | null
    major?: StringNullableWithAggregatesFilter<"LearnerProfile"> | string | null
    graduationYear?: IntNullableWithAggregatesFilter<"LearnerProfile"> | number | null
    skillsMatchPercentage?: IntWithAggregatesFilter<"LearnerProfile"> | number
    verificationStatus?: EnumVerificationStatusWithAggregatesFilter<"LearnerProfile"> | $Enums.VerificationStatus
  }

  export type SkillWhereInput = {
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    id?: StringFilter<"Skill"> | string
    name?: StringFilter<"Skill"> | string
    category?: EnumSkillCategoryFilter<"Skill"> | $Enums.SkillCategory
    description?: StringNullableFilter<"Skill"> | string | null
    verified?: BoolFilter<"Skill"> | boolean
    trending?: BoolFilter<"Skill"> | boolean
    userSkills?: UserSkillListRelationFilter
    credentialSkills?: CredentialSkillListRelationFilter
    projectSkills?: ProjectSkillListRelationFilter
    opportunitySkills?: OpportunitySkillListRelationFilter
    courseSkills?: CourseSkillListRelationFilter
    trendingData?: XOR<TrendingSkillNullableRelationFilter, TrendingSkillWhereInput> | null
    skillGaps?: SkillGapListRelationFilter
  }

  export type SkillOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    verified?: SortOrder
    trending?: SortOrder
    userSkills?: UserSkillOrderByRelationAggregateInput
    credentialSkills?: CredentialSkillOrderByRelationAggregateInput
    projectSkills?: ProjectSkillOrderByRelationAggregateInput
    opportunitySkills?: OpportunitySkillOrderByRelationAggregateInput
    courseSkills?: CourseSkillOrderByRelationAggregateInput
    trendingData?: TrendingSkillOrderByWithRelationInput
    skillGaps?: SkillGapOrderByRelationAggregateInput
  }

  export type SkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    category?: EnumSkillCategoryFilter<"Skill"> | $Enums.SkillCategory
    description?: StringNullableFilter<"Skill"> | string | null
    verified?: BoolFilter<"Skill"> | boolean
    trending?: BoolFilter<"Skill"> | boolean
    userSkills?: UserSkillListRelationFilter
    credentialSkills?: CredentialSkillListRelationFilter
    projectSkills?: ProjectSkillListRelationFilter
    opportunitySkills?: OpportunitySkillListRelationFilter
    courseSkills?: CourseSkillListRelationFilter
    trendingData?: XOR<TrendingSkillNullableRelationFilter, TrendingSkillWhereInput> | null
    skillGaps?: SkillGapListRelationFilter
  }, "id" | "name">

  export type SkillOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    verified?: SortOrder
    trending?: SortOrder
    _count?: SkillCountOrderByAggregateInput
    _max?: SkillMaxOrderByAggregateInput
    _min?: SkillMinOrderByAggregateInput
  }

  export type SkillScalarWhereWithAggregatesInput = {
    AND?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    OR?: SkillScalarWhereWithAggregatesInput[]
    NOT?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Skill"> | string
    name?: StringWithAggregatesFilter<"Skill"> | string
    category?: EnumSkillCategoryWithAggregatesFilter<"Skill"> | $Enums.SkillCategory
    description?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    verified?: BoolWithAggregatesFilter<"Skill"> | boolean
    trending?: BoolWithAggregatesFilter<"Skill"> | boolean
  }

  export type UserSkillWhereInput = {
    AND?: UserSkillWhereInput | UserSkillWhereInput[]
    OR?: UserSkillWhereInput[]
    NOT?: UserSkillWhereInput | UserSkillWhereInput[]
    id?: StringFilter<"UserSkill"> | string
    userId?: StringFilter<"UserSkill"> | string
    skillId?: StringFilter<"UserSkill"> | string
    level?: EnumSkillLevelFilter<"UserSkill"> | $Enums.SkillLevel
    endorsements?: IntFilter<"UserSkill"> | number
    verified?: BoolFilter<"UserSkill"> | boolean
    addedAt?: DateTimeFilter<"UserSkill"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }

  export type UserSkillOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    endorsements?: SortOrder
    verified?: SortOrder
    addedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    skill?: SkillOrderByWithRelationInput
  }

  export type UserSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_skillId?: UserSkillUserIdSkillIdCompoundUniqueInput
    AND?: UserSkillWhereInput | UserSkillWhereInput[]
    OR?: UserSkillWhereInput[]
    NOT?: UserSkillWhereInput | UserSkillWhereInput[]
    userId?: StringFilter<"UserSkill"> | string
    skillId?: StringFilter<"UserSkill"> | string
    level?: EnumSkillLevelFilter<"UserSkill"> | $Enums.SkillLevel
    endorsements?: IntFilter<"UserSkill"> | number
    verified?: BoolFilter<"UserSkill"> | boolean
    addedAt?: DateTimeFilter<"UserSkill"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }, "id" | "userId_skillId">

  export type UserSkillOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    endorsements?: SortOrder
    verified?: SortOrder
    addedAt?: SortOrder
    _count?: UserSkillCountOrderByAggregateInput
    _avg?: UserSkillAvgOrderByAggregateInput
    _max?: UserSkillMaxOrderByAggregateInput
    _min?: UserSkillMinOrderByAggregateInput
    _sum?: UserSkillSumOrderByAggregateInput
  }

  export type UserSkillScalarWhereWithAggregatesInput = {
    AND?: UserSkillScalarWhereWithAggregatesInput | UserSkillScalarWhereWithAggregatesInput[]
    OR?: UserSkillScalarWhereWithAggregatesInput[]
    NOT?: UserSkillScalarWhereWithAggregatesInput | UserSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSkill"> | string
    userId?: StringWithAggregatesFilter<"UserSkill"> | string
    skillId?: StringWithAggregatesFilter<"UserSkill"> | string
    level?: EnumSkillLevelWithAggregatesFilter<"UserSkill"> | $Enums.SkillLevel
    endorsements?: IntWithAggregatesFilter<"UserSkill"> | number
    verified?: BoolWithAggregatesFilter<"UserSkill"> | boolean
    addedAt?: DateTimeWithAggregatesFilter<"UserSkill"> | Date | string
  }

  export type TrendingSkillWhereInput = {
    AND?: TrendingSkillWhereInput | TrendingSkillWhereInput[]
    OR?: TrendingSkillWhereInput[]
    NOT?: TrendingSkillWhereInput | TrendingSkillWhereInput[]
    skillId?: StringFilter<"TrendingSkill"> | string
    demandPercentage?: DecimalFilter<"TrendingSkill"> | Decimal | DecimalJsLike | number | string
    growthRate?: DecimalFilter<"TrendingSkill"> | Decimal | DecimalJsLike | number | string
    averageSalary?: BigIntFilter<"TrendingSkill"> | bigint | number
    openPositions?: IntFilter<"TrendingSkill"> | number
    updatedAt?: DateTimeFilter<"TrendingSkill"> | Date | string
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }

  export type TrendingSkillOrderByWithRelationInput = {
    skillId?: SortOrder
    demandPercentage?: SortOrder
    growthRate?: SortOrder
    averageSalary?: SortOrder
    openPositions?: SortOrder
    updatedAt?: SortOrder
    skill?: SkillOrderByWithRelationInput
  }

  export type TrendingSkillWhereUniqueInput = Prisma.AtLeast<{
    skillId?: string
    AND?: TrendingSkillWhereInput | TrendingSkillWhereInput[]
    OR?: TrendingSkillWhereInput[]
    NOT?: TrendingSkillWhereInput | TrendingSkillWhereInput[]
    demandPercentage?: DecimalFilter<"TrendingSkill"> | Decimal | DecimalJsLike | number | string
    growthRate?: DecimalFilter<"TrendingSkill"> | Decimal | DecimalJsLike | number | string
    averageSalary?: BigIntFilter<"TrendingSkill"> | bigint | number
    openPositions?: IntFilter<"TrendingSkill"> | number
    updatedAt?: DateTimeFilter<"TrendingSkill"> | Date | string
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }, "skillId">

  export type TrendingSkillOrderByWithAggregationInput = {
    skillId?: SortOrder
    demandPercentage?: SortOrder
    growthRate?: SortOrder
    averageSalary?: SortOrder
    openPositions?: SortOrder
    updatedAt?: SortOrder
    _count?: TrendingSkillCountOrderByAggregateInput
    _avg?: TrendingSkillAvgOrderByAggregateInput
    _max?: TrendingSkillMaxOrderByAggregateInput
    _min?: TrendingSkillMinOrderByAggregateInput
    _sum?: TrendingSkillSumOrderByAggregateInput
  }

  export type TrendingSkillScalarWhereWithAggregatesInput = {
    AND?: TrendingSkillScalarWhereWithAggregatesInput | TrendingSkillScalarWhereWithAggregatesInput[]
    OR?: TrendingSkillScalarWhereWithAggregatesInput[]
    NOT?: TrendingSkillScalarWhereWithAggregatesInput | TrendingSkillScalarWhereWithAggregatesInput[]
    skillId?: StringWithAggregatesFilter<"TrendingSkill"> | string
    demandPercentage?: DecimalWithAggregatesFilter<"TrendingSkill"> | Decimal | DecimalJsLike | number | string
    growthRate?: DecimalWithAggregatesFilter<"TrendingSkill"> | Decimal | DecimalJsLike | number | string
    averageSalary?: BigIntWithAggregatesFilter<"TrendingSkill"> | bigint | number
    openPositions?: IntWithAggregatesFilter<"TrendingSkill"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"TrendingSkill"> | Date | string
  }

  export type CredentialWhereInput = {
    AND?: CredentialWhereInput | CredentialWhereInput[]
    OR?: CredentialWhereInput[]
    NOT?: CredentialWhereInput | CredentialWhereInput[]
    id?: StringFilter<"Credential"> | string
    userId?: StringFilter<"Credential"> | string
    title?: StringFilter<"Credential"> | string
    issuer?: StringFilter<"Credential"> | string
    type?: EnumCredentialTypeFilter<"Credential"> | $Enums.CredentialType
    issueDate?: DateTimeFilter<"Credential"> | Date | string
    expiryDate?: DateTimeNullableFilter<"Credential"> | Date | string | null
    verified?: BoolFilter<"Credential"> | boolean
    blockchainHash?: StringNullableFilter<"Credential"> | string | null
    qrCode?: StringNullableFilter<"Credential"> | string | null
    createdAt?: DateTimeFilter<"Credential"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    skills?: CredentialSkillListRelationFilter
    verificationRequests?: VerificationRequestListRelationFilter
  }

  export type CredentialOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    issuer?: SortOrder
    type?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    verified?: SortOrder
    blockchainHash?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    skills?: CredentialSkillOrderByRelationAggregateInput
    verificationRequests?: VerificationRequestOrderByRelationAggregateInput
  }

  export type CredentialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CredentialWhereInput | CredentialWhereInput[]
    OR?: CredentialWhereInput[]
    NOT?: CredentialWhereInput | CredentialWhereInput[]
    userId?: StringFilter<"Credential"> | string
    title?: StringFilter<"Credential"> | string
    issuer?: StringFilter<"Credential"> | string
    type?: EnumCredentialTypeFilter<"Credential"> | $Enums.CredentialType
    issueDate?: DateTimeFilter<"Credential"> | Date | string
    expiryDate?: DateTimeNullableFilter<"Credential"> | Date | string | null
    verified?: BoolFilter<"Credential"> | boolean
    blockchainHash?: StringNullableFilter<"Credential"> | string | null
    qrCode?: StringNullableFilter<"Credential"> | string | null
    createdAt?: DateTimeFilter<"Credential"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    skills?: CredentialSkillListRelationFilter
    verificationRequests?: VerificationRequestListRelationFilter
  }, "id">

  export type CredentialOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    issuer?: SortOrder
    type?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    verified?: SortOrder
    blockchainHash?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CredentialCountOrderByAggregateInput
    _max?: CredentialMaxOrderByAggregateInput
    _min?: CredentialMinOrderByAggregateInput
  }

  export type CredentialScalarWhereWithAggregatesInput = {
    AND?: CredentialScalarWhereWithAggregatesInput | CredentialScalarWhereWithAggregatesInput[]
    OR?: CredentialScalarWhereWithAggregatesInput[]
    NOT?: CredentialScalarWhereWithAggregatesInput | CredentialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Credential"> | string
    userId?: StringWithAggregatesFilter<"Credential"> | string
    title?: StringWithAggregatesFilter<"Credential"> | string
    issuer?: StringWithAggregatesFilter<"Credential"> | string
    type?: EnumCredentialTypeWithAggregatesFilter<"Credential"> | $Enums.CredentialType
    issueDate?: DateTimeWithAggregatesFilter<"Credential"> | Date | string
    expiryDate?: DateTimeNullableWithAggregatesFilter<"Credential"> | Date | string | null
    verified?: BoolWithAggregatesFilter<"Credential"> | boolean
    blockchainHash?: StringNullableWithAggregatesFilter<"Credential"> | string | null
    qrCode?: StringNullableWithAggregatesFilter<"Credential"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Credential"> | Date | string
  }

  export type CredentialSkillWhereInput = {
    AND?: CredentialSkillWhereInput | CredentialSkillWhereInput[]
    OR?: CredentialSkillWhereInput[]
    NOT?: CredentialSkillWhereInput | CredentialSkillWhereInput[]
    credentialId?: StringFilter<"CredentialSkill"> | string
    skillId?: StringFilter<"CredentialSkill"> | string
    credential?: XOR<CredentialRelationFilter, CredentialWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }

  export type CredentialSkillOrderByWithRelationInput = {
    credentialId?: SortOrder
    skillId?: SortOrder
    credential?: CredentialOrderByWithRelationInput
    skill?: SkillOrderByWithRelationInput
  }

  export type CredentialSkillWhereUniqueInput = Prisma.AtLeast<{
    credentialId_skillId?: CredentialSkillCredentialIdSkillIdCompoundUniqueInput
    AND?: CredentialSkillWhereInput | CredentialSkillWhereInput[]
    OR?: CredentialSkillWhereInput[]
    NOT?: CredentialSkillWhereInput | CredentialSkillWhereInput[]
    credentialId?: StringFilter<"CredentialSkill"> | string
    skillId?: StringFilter<"CredentialSkill"> | string
    credential?: XOR<CredentialRelationFilter, CredentialWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }, "credentialId_skillId">

  export type CredentialSkillOrderByWithAggregationInput = {
    credentialId?: SortOrder
    skillId?: SortOrder
    _count?: CredentialSkillCountOrderByAggregateInput
    _max?: CredentialSkillMaxOrderByAggregateInput
    _min?: CredentialSkillMinOrderByAggregateInput
  }

  export type CredentialSkillScalarWhereWithAggregatesInput = {
    AND?: CredentialSkillScalarWhereWithAggregatesInput | CredentialSkillScalarWhereWithAggregatesInput[]
    OR?: CredentialSkillScalarWhereWithAggregatesInput[]
    NOT?: CredentialSkillScalarWhereWithAggregatesInput | CredentialSkillScalarWhereWithAggregatesInput[]
    credentialId?: StringWithAggregatesFilter<"CredentialSkill"> | string
    skillId?: StringWithAggregatesFilter<"CredentialSkill"> | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    userId?: StringFilter<"Project"> | string
    title?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    visibility?: EnumProjectVisibilityFilter<"Project"> | $Enums.ProjectVisibility
    verified?: BoolFilter<"Project"> | boolean
    githubUrl?: StringNullableFilter<"Project"> | string | null
    liveUrl?: StringNullableFilter<"Project"> | string | null
    startDate?: DateTimeFilter<"Project"> | Date | string
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    media?: ProjectMediaListRelationFilter
    skills?: ProjectSkillListRelationFilter
    collaborators?: ProjectCollaboratorListRelationFilter
    endorsements?: EndorsementListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    visibility?: SortOrder
    verified?: SortOrder
    githubUrl?: SortOrderInput | SortOrder
    liveUrl?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    media?: ProjectMediaOrderByRelationAggregateInput
    skills?: ProjectSkillOrderByRelationAggregateInput
    collaborators?: ProjectCollaboratorOrderByRelationAggregateInput
    endorsements?: EndorsementOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    userId?: StringFilter<"Project"> | string
    title?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    visibility?: EnumProjectVisibilityFilter<"Project"> | $Enums.ProjectVisibility
    verified?: BoolFilter<"Project"> | boolean
    githubUrl?: StringNullableFilter<"Project"> | string | null
    liveUrl?: StringNullableFilter<"Project"> | string | null
    startDate?: DateTimeFilter<"Project"> | Date | string
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    media?: ProjectMediaListRelationFilter
    skills?: ProjectSkillListRelationFilter
    collaborators?: ProjectCollaboratorListRelationFilter
    endorsements?: EndorsementListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    visibility?: SortOrder
    verified?: SortOrder
    githubUrl?: SortOrderInput | SortOrder
    liveUrl?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    userId?: StringWithAggregatesFilter<"Project"> | string
    title?: StringWithAggregatesFilter<"Project"> | string
    description?: StringWithAggregatesFilter<"Project"> | string
    visibility?: EnumProjectVisibilityWithAggregatesFilter<"Project"> | $Enums.ProjectVisibility
    verified?: BoolWithAggregatesFilter<"Project"> | boolean
    githubUrl?: StringNullableWithAggregatesFilter<"Project"> | string | null
    liveUrl?: StringNullableWithAggregatesFilter<"Project"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type ProjectMediaWhereInput = {
    AND?: ProjectMediaWhereInput | ProjectMediaWhereInput[]
    OR?: ProjectMediaWhereInput[]
    NOT?: ProjectMediaWhereInput | ProjectMediaWhereInput[]
    id?: StringFilter<"ProjectMedia"> | string
    projectId?: StringFilter<"ProjectMedia"> | string
    type?: EnumMediaTypeFilter<"ProjectMedia"> | $Enums.MediaType
    url?: StringFilter<"ProjectMedia"> | string
    thumbnail?: StringNullableFilter<"ProjectMedia"> | string | null
    caption?: StringNullableFilter<"ProjectMedia"> | string | null
    displayOrder?: IntFilter<"ProjectMedia"> | number
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type ProjectMediaOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectMediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectMediaWhereInput | ProjectMediaWhereInput[]
    OR?: ProjectMediaWhereInput[]
    NOT?: ProjectMediaWhereInput | ProjectMediaWhereInput[]
    projectId?: StringFilter<"ProjectMedia"> | string
    type?: EnumMediaTypeFilter<"ProjectMedia"> | $Enums.MediaType
    url?: StringFilter<"ProjectMedia"> | string
    thumbnail?: StringNullableFilter<"ProjectMedia"> | string | null
    caption?: StringNullableFilter<"ProjectMedia"> | string | null
    displayOrder?: IntFilter<"ProjectMedia"> | number
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id">

  export type ProjectMediaOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    _count?: ProjectMediaCountOrderByAggregateInput
    _avg?: ProjectMediaAvgOrderByAggregateInput
    _max?: ProjectMediaMaxOrderByAggregateInput
    _min?: ProjectMediaMinOrderByAggregateInput
    _sum?: ProjectMediaSumOrderByAggregateInput
  }

  export type ProjectMediaScalarWhereWithAggregatesInput = {
    AND?: ProjectMediaScalarWhereWithAggregatesInput | ProjectMediaScalarWhereWithAggregatesInput[]
    OR?: ProjectMediaScalarWhereWithAggregatesInput[]
    NOT?: ProjectMediaScalarWhereWithAggregatesInput | ProjectMediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectMedia"> | string
    projectId?: StringWithAggregatesFilter<"ProjectMedia"> | string
    type?: EnumMediaTypeWithAggregatesFilter<"ProjectMedia"> | $Enums.MediaType
    url?: StringWithAggregatesFilter<"ProjectMedia"> | string
    thumbnail?: StringNullableWithAggregatesFilter<"ProjectMedia"> | string | null
    caption?: StringNullableWithAggregatesFilter<"ProjectMedia"> | string | null
    displayOrder?: IntWithAggregatesFilter<"ProjectMedia"> | number
  }

  export type ProjectSkillWhereInput = {
    AND?: ProjectSkillWhereInput | ProjectSkillWhereInput[]
    OR?: ProjectSkillWhereInput[]
    NOT?: ProjectSkillWhereInput | ProjectSkillWhereInput[]
    projectId?: StringFilter<"ProjectSkill"> | string
    skillId?: StringFilter<"ProjectSkill"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }

  export type ProjectSkillOrderByWithRelationInput = {
    projectId?: SortOrder
    skillId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    skill?: SkillOrderByWithRelationInput
  }

  export type ProjectSkillWhereUniqueInput = Prisma.AtLeast<{
    projectId_skillId?: ProjectSkillProjectIdSkillIdCompoundUniqueInput
    AND?: ProjectSkillWhereInput | ProjectSkillWhereInput[]
    OR?: ProjectSkillWhereInput[]
    NOT?: ProjectSkillWhereInput | ProjectSkillWhereInput[]
    projectId?: StringFilter<"ProjectSkill"> | string
    skillId?: StringFilter<"ProjectSkill"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }, "projectId_skillId">

  export type ProjectSkillOrderByWithAggregationInput = {
    projectId?: SortOrder
    skillId?: SortOrder
    _count?: ProjectSkillCountOrderByAggregateInput
    _max?: ProjectSkillMaxOrderByAggregateInput
    _min?: ProjectSkillMinOrderByAggregateInput
  }

  export type ProjectSkillScalarWhereWithAggregatesInput = {
    AND?: ProjectSkillScalarWhereWithAggregatesInput | ProjectSkillScalarWhereWithAggregatesInput[]
    OR?: ProjectSkillScalarWhereWithAggregatesInput[]
    NOT?: ProjectSkillScalarWhereWithAggregatesInput | ProjectSkillScalarWhereWithAggregatesInput[]
    projectId?: StringWithAggregatesFilter<"ProjectSkill"> | string
    skillId?: StringWithAggregatesFilter<"ProjectSkill"> | string
  }

  export type ProjectCollaboratorWhereInput = {
    AND?: ProjectCollaboratorWhereInput | ProjectCollaboratorWhereInput[]
    OR?: ProjectCollaboratorWhereInput[]
    NOT?: ProjectCollaboratorWhereInput | ProjectCollaboratorWhereInput[]
    projectId?: StringFilter<"ProjectCollaborator"> | string
    userId?: StringFilter<"ProjectCollaborator"> | string
    role?: StringNullableFilter<"ProjectCollaborator"> | string | null
    joinedAt?: DateTimeFilter<"ProjectCollaborator"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProjectCollaboratorOrderByWithRelationInput = {
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProjectCollaboratorWhereUniqueInput = Prisma.AtLeast<{
    projectId_userId?: ProjectCollaboratorProjectIdUserIdCompoundUniqueInput
    AND?: ProjectCollaboratorWhereInput | ProjectCollaboratorWhereInput[]
    OR?: ProjectCollaboratorWhereInput[]
    NOT?: ProjectCollaboratorWhereInput | ProjectCollaboratorWhereInput[]
    projectId?: StringFilter<"ProjectCollaborator"> | string
    userId?: StringFilter<"ProjectCollaborator"> | string
    role?: StringNullableFilter<"ProjectCollaborator"> | string | null
    joinedAt?: DateTimeFilter<"ProjectCollaborator"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "projectId_userId">

  export type ProjectCollaboratorOrderByWithAggregationInput = {
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    _count?: ProjectCollaboratorCountOrderByAggregateInput
    _max?: ProjectCollaboratorMaxOrderByAggregateInput
    _min?: ProjectCollaboratorMinOrderByAggregateInput
  }

  export type ProjectCollaboratorScalarWhereWithAggregatesInput = {
    AND?: ProjectCollaboratorScalarWhereWithAggregatesInput | ProjectCollaboratorScalarWhereWithAggregatesInput[]
    OR?: ProjectCollaboratorScalarWhereWithAggregatesInput[]
    NOT?: ProjectCollaboratorScalarWhereWithAggregatesInput | ProjectCollaboratorScalarWhereWithAggregatesInput[]
    projectId?: StringWithAggregatesFilter<"ProjectCollaborator"> | string
    userId?: StringWithAggregatesFilter<"ProjectCollaborator"> | string
    role?: StringNullableWithAggregatesFilter<"ProjectCollaborator"> | string | null
    joinedAt?: DateTimeWithAggregatesFilter<"ProjectCollaborator"> | Date | string
  }

  export type EndorsementWhereInput = {
    AND?: EndorsementWhereInput | EndorsementWhereInput[]
    OR?: EndorsementWhereInput[]
    NOT?: EndorsementWhereInput | EndorsementWhereInput[]
    id?: StringFilter<"Endorsement"> | string
    endorserId?: StringFilter<"Endorsement"> | string
    comment?: StringNullableFilter<"Endorsement"> | string | null
    createdAt?: DateTimeFilter<"Endorsement"> | Date | string
    projectId?: StringNullableFilter<"Endorsement"> | string | null
    endorser?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
  }

  export type EndorsementOrderByWithRelationInput = {
    id?: SortOrder
    endorserId?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    projectId?: SortOrderInput | SortOrder
    endorser?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type EndorsementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EndorsementWhereInput | EndorsementWhereInput[]
    OR?: EndorsementWhereInput[]
    NOT?: EndorsementWhereInput | EndorsementWhereInput[]
    endorserId?: StringFilter<"Endorsement"> | string
    comment?: StringNullableFilter<"Endorsement"> | string | null
    createdAt?: DateTimeFilter<"Endorsement"> | Date | string
    projectId?: StringNullableFilter<"Endorsement"> | string | null
    endorser?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
  }, "id">

  export type EndorsementOrderByWithAggregationInput = {
    id?: SortOrder
    endorserId?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    projectId?: SortOrderInput | SortOrder
    _count?: EndorsementCountOrderByAggregateInput
    _max?: EndorsementMaxOrderByAggregateInput
    _min?: EndorsementMinOrderByAggregateInput
  }

  export type EndorsementScalarWhereWithAggregatesInput = {
    AND?: EndorsementScalarWhereWithAggregatesInput | EndorsementScalarWhereWithAggregatesInput[]
    OR?: EndorsementScalarWhereWithAggregatesInput[]
    NOT?: EndorsementScalarWhereWithAggregatesInput | EndorsementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Endorsement"> | string
    endorserId?: StringWithAggregatesFilter<"Endorsement"> | string
    comment?: StringNullableWithAggregatesFilter<"Endorsement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Endorsement"> | Date | string
    projectId?: StringNullableWithAggregatesFilter<"Endorsement"> | string | null
  }

  export type OpportunityWhereInput = {
    AND?: OpportunityWhereInput | OpportunityWhereInput[]
    OR?: OpportunityWhereInput[]
    NOT?: OpportunityWhereInput | OpportunityWhereInput[]
    id?: StringFilter<"Opportunity"> | string
    title?: StringFilter<"Opportunity"> | string
    company?: StringFilter<"Opportunity"> | string
    companyLogo?: StringNullableFilter<"Opportunity"> | string | null
    type?: EnumOpportunityTypeFilter<"Opportunity"> | $Enums.OpportunityType
    location?: StringFilter<"Opportunity"> | string
    remote?: BoolFilter<"Opportunity"> | boolean
    description?: StringFilter<"Opportunity"> | string
    salaryMin?: BigIntNullableFilter<"Opportunity"> | bigint | number | null
    salaryMax?: BigIntNullableFilter<"Opportunity"> | bigint | number | null
    postedDate?: DateTimeFilter<"Opportunity"> | Date | string
    deadline?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    applicationUrl?: StringNullableFilter<"Opportunity"> | string | null
    createdAt?: DateTimeFilter<"Opportunity"> | Date | string
    requirements?: OpportunityRequirementListRelationFilter
    skills?: OpportunitySkillListRelationFilter
    applications?: ApplicationListRelationFilter
  }

  export type OpportunityOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    company?: SortOrder
    companyLogo?: SortOrderInput | SortOrder
    type?: SortOrder
    location?: SortOrder
    remote?: SortOrder
    description?: SortOrder
    salaryMin?: SortOrderInput | SortOrder
    salaryMax?: SortOrderInput | SortOrder
    postedDate?: SortOrder
    deadline?: SortOrderInput | SortOrder
    applicationUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    requirements?: OpportunityRequirementOrderByRelationAggregateInput
    skills?: OpportunitySkillOrderByRelationAggregateInput
    applications?: ApplicationOrderByRelationAggregateInput
  }

  export type OpportunityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OpportunityWhereInput | OpportunityWhereInput[]
    OR?: OpportunityWhereInput[]
    NOT?: OpportunityWhereInput | OpportunityWhereInput[]
    title?: StringFilter<"Opportunity"> | string
    company?: StringFilter<"Opportunity"> | string
    companyLogo?: StringNullableFilter<"Opportunity"> | string | null
    type?: EnumOpportunityTypeFilter<"Opportunity"> | $Enums.OpportunityType
    location?: StringFilter<"Opportunity"> | string
    remote?: BoolFilter<"Opportunity"> | boolean
    description?: StringFilter<"Opportunity"> | string
    salaryMin?: BigIntNullableFilter<"Opportunity"> | bigint | number | null
    salaryMax?: BigIntNullableFilter<"Opportunity"> | bigint | number | null
    postedDate?: DateTimeFilter<"Opportunity"> | Date | string
    deadline?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    applicationUrl?: StringNullableFilter<"Opportunity"> | string | null
    createdAt?: DateTimeFilter<"Opportunity"> | Date | string
    requirements?: OpportunityRequirementListRelationFilter
    skills?: OpportunitySkillListRelationFilter
    applications?: ApplicationListRelationFilter
  }, "id">

  export type OpportunityOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    company?: SortOrder
    companyLogo?: SortOrderInput | SortOrder
    type?: SortOrder
    location?: SortOrder
    remote?: SortOrder
    description?: SortOrder
    salaryMin?: SortOrderInput | SortOrder
    salaryMax?: SortOrderInput | SortOrder
    postedDate?: SortOrder
    deadline?: SortOrderInput | SortOrder
    applicationUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OpportunityCountOrderByAggregateInput
    _avg?: OpportunityAvgOrderByAggregateInput
    _max?: OpportunityMaxOrderByAggregateInput
    _min?: OpportunityMinOrderByAggregateInput
    _sum?: OpportunitySumOrderByAggregateInput
  }

  export type OpportunityScalarWhereWithAggregatesInput = {
    AND?: OpportunityScalarWhereWithAggregatesInput | OpportunityScalarWhereWithAggregatesInput[]
    OR?: OpportunityScalarWhereWithAggregatesInput[]
    NOT?: OpportunityScalarWhereWithAggregatesInput | OpportunityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Opportunity"> | string
    title?: StringWithAggregatesFilter<"Opportunity"> | string
    company?: StringWithAggregatesFilter<"Opportunity"> | string
    companyLogo?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    type?: EnumOpportunityTypeWithAggregatesFilter<"Opportunity"> | $Enums.OpportunityType
    location?: StringWithAggregatesFilter<"Opportunity"> | string
    remote?: BoolWithAggregatesFilter<"Opportunity"> | boolean
    description?: StringWithAggregatesFilter<"Opportunity"> | string
    salaryMin?: BigIntNullableWithAggregatesFilter<"Opportunity"> | bigint | number | null
    salaryMax?: BigIntNullableWithAggregatesFilter<"Opportunity"> | bigint | number | null
    postedDate?: DateTimeWithAggregatesFilter<"Opportunity"> | Date | string
    deadline?: DateTimeNullableWithAggregatesFilter<"Opportunity"> | Date | string | null
    applicationUrl?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Opportunity"> | Date | string
  }

  export type OpportunityRequirementWhereInput = {
    AND?: OpportunityRequirementWhereInput | OpportunityRequirementWhereInput[]
    OR?: OpportunityRequirementWhereInput[]
    NOT?: OpportunityRequirementWhereInput | OpportunityRequirementWhereInput[]
    id?: StringFilter<"OpportunityRequirement"> | string
    opportunityId?: StringFilter<"OpportunityRequirement"> | string
    requirement?: StringFilter<"OpportunityRequirement"> | string
    displayOrder?: IntFilter<"OpportunityRequirement"> | number
    opportunity?: XOR<OpportunityRelationFilter, OpportunityWhereInput>
  }

  export type OpportunityRequirementOrderByWithRelationInput = {
    id?: SortOrder
    opportunityId?: SortOrder
    requirement?: SortOrder
    displayOrder?: SortOrder
    opportunity?: OpportunityOrderByWithRelationInput
  }

  export type OpportunityRequirementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OpportunityRequirementWhereInput | OpportunityRequirementWhereInput[]
    OR?: OpportunityRequirementWhereInput[]
    NOT?: OpportunityRequirementWhereInput | OpportunityRequirementWhereInput[]
    opportunityId?: StringFilter<"OpportunityRequirement"> | string
    requirement?: StringFilter<"OpportunityRequirement"> | string
    displayOrder?: IntFilter<"OpportunityRequirement"> | number
    opportunity?: XOR<OpportunityRelationFilter, OpportunityWhereInput>
  }, "id">

  export type OpportunityRequirementOrderByWithAggregationInput = {
    id?: SortOrder
    opportunityId?: SortOrder
    requirement?: SortOrder
    displayOrder?: SortOrder
    _count?: OpportunityRequirementCountOrderByAggregateInput
    _avg?: OpportunityRequirementAvgOrderByAggregateInput
    _max?: OpportunityRequirementMaxOrderByAggregateInput
    _min?: OpportunityRequirementMinOrderByAggregateInput
    _sum?: OpportunityRequirementSumOrderByAggregateInput
  }

  export type OpportunityRequirementScalarWhereWithAggregatesInput = {
    AND?: OpportunityRequirementScalarWhereWithAggregatesInput | OpportunityRequirementScalarWhereWithAggregatesInput[]
    OR?: OpportunityRequirementScalarWhereWithAggregatesInput[]
    NOT?: OpportunityRequirementScalarWhereWithAggregatesInput | OpportunityRequirementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OpportunityRequirement"> | string
    opportunityId?: StringWithAggregatesFilter<"OpportunityRequirement"> | string
    requirement?: StringWithAggregatesFilter<"OpportunityRequirement"> | string
    displayOrder?: IntWithAggregatesFilter<"OpportunityRequirement"> | number
  }

  export type OpportunitySkillWhereInput = {
    AND?: OpportunitySkillWhereInput | OpportunitySkillWhereInput[]
    OR?: OpportunitySkillWhereInput[]
    NOT?: OpportunitySkillWhereInput | OpportunitySkillWhereInput[]
    opportunityId?: StringFilter<"OpportunitySkill"> | string
    skillId?: StringFilter<"OpportunitySkill"> | string
    opportunity?: XOR<OpportunityRelationFilter, OpportunityWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }

  export type OpportunitySkillOrderByWithRelationInput = {
    opportunityId?: SortOrder
    skillId?: SortOrder
    opportunity?: OpportunityOrderByWithRelationInput
    skill?: SkillOrderByWithRelationInput
  }

  export type OpportunitySkillWhereUniqueInput = Prisma.AtLeast<{
    opportunityId_skillId?: OpportunitySkillOpportunityIdSkillIdCompoundUniqueInput
    AND?: OpportunitySkillWhereInput | OpportunitySkillWhereInput[]
    OR?: OpportunitySkillWhereInput[]
    NOT?: OpportunitySkillWhereInput | OpportunitySkillWhereInput[]
    opportunityId?: StringFilter<"OpportunitySkill"> | string
    skillId?: StringFilter<"OpportunitySkill"> | string
    opportunity?: XOR<OpportunityRelationFilter, OpportunityWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }, "opportunityId_skillId">

  export type OpportunitySkillOrderByWithAggregationInput = {
    opportunityId?: SortOrder
    skillId?: SortOrder
    _count?: OpportunitySkillCountOrderByAggregateInput
    _max?: OpportunitySkillMaxOrderByAggregateInput
    _min?: OpportunitySkillMinOrderByAggregateInput
  }

  export type OpportunitySkillScalarWhereWithAggregatesInput = {
    AND?: OpportunitySkillScalarWhereWithAggregatesInput | OpportunitySkillScalarWhereWithAggregatesInput[]
    OR?: OpportunitySkillScalarWhereWithAggregatesInput[]
    NOT?: OpportunitySkillScalarWhereWithAggregatesInput | OpportunitySkillScalarWhereWithAggregatesInput[]
    opportunityId?: StringWithAggregatesFilter<"OpportunitySkill"> | string
    skillId?: StringWithAggregatesFilter<"OpportunitySkill"> | string
  }

  export type ApplicationWhereInput = {
    AND?: ApplicationWhereInput | ApplicationWhereInput[]
    OR?: ApplicationWhereInput[]
    NOT?: ApplicationWhereInput | ApplicationWhereInput[]
    id?: StringFilter<"Application"> | string
    userId?: StringFilter<"Application"> | string
    opportunityId?: StringFilter<"Application"> | string
    status?: EnumApplicationStatusFilter<"Application"> | $Enums.ApplicationStatus
    coverLetter?: StringNullableFilter<"Application"> | string | null
    resumeUrl?: StringNullableFilter<"Application"> | string | null
    appliedAt?: DateTimeFilter<"Application"> | Date | string
    updatedAt?: DateTimeFilter<"Application"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    opportunity?: XOR<OpportunityRelationFilter, OpportunityWhereInput>
  }

  export type ApplicationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    opportunityId?: SortOrder
    status?: SortOrder
    coverLetter?: SortOrderInput | SortOrder
    resumeUrl?: SortOrderInput | SortOrder
    appliedAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    opportunity?: OpportunityOrderByWithRelationInput
  }

  export type ApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_opportunityId?: ApplicationUserIdOpportunityIdCompoundUniqueInput
    AND?: ApplicationWhereInput | ApplicationWhereInput[]
    OR?: ApplicationWhereInput[]
    NOT?: ApplicationWhereInput | ApplicationWhereInput[]
    userId?: StringFilter<"Application"> | string
    opportunityId?: StringFilter<"Application"> | string
    status?: EnumApplicationStatusFilter<"Application"> | $Enums.ApplicationStatus
    coverLetter?: StringNullableFilter<"Application"> | string | null
    resumeUrl?: StringNullableFilter<"Application"> | string | null
    appliedAt?: DateTimeFilter<"Application"> | Date | string
    updatedAt?: DateTimeFilter<"Application"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    opportunity?: XOR<OpportunityRelationFilter, OpportunityWhereInput>
  }, "id" | "userId_opportunityId">

  export type ApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    opportunityId?: SortOrder
    status?: SortOrder
    coverLetter?: SortOrderInput | SortOrder
    resumeUrl?: SortOrderInput | SortOrder
    appliedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApplicationCountOrderByAggregateInput
    _max?: ApplicationMaxOrderByAggregateInput
    _min?: ApplicationMinOrderByAggregateInput
  }

  export type ApplicationScalarWhereWithAggregatesInput = {
    AND?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[]
    OR?: ApplicationScalarWhereWithAggregatesInput[]
    NOT?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Application"> | string
    userId?: StringWithAggregatesFilter<"Application"> | string
    opportunityId?: StringWithAggregatesFilter<"Application"> | string
    status?: EnumApplicationStatusWithAggregatesFilter<"Application"> | $Enums.ApplicationStatus
    coverLetter?: StringNullableWithAggregatesFilter<"Application"> | string | null
    resumeUrl?: StringNullableWithAggregatesFilter<"Application"> | string | null
    appliedAt?: DateTimeWithAggregatesFilter<"Application"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Application"> | Date | string
  }

  export type ConnectionWhereInput = {
    AND?: ConnectionWhereInput | ConnectionWhereInput[]
    OR?: ConnectionWhereInput[]
    NOT?: ConnectionWhereInput | ConnectionWhereInput[]
    id?: StringFilter<"Connection"> | string
    userId?: StringFilter<"Connection"> | string
    connectedUserId?: StringFilter<"Connection"> | string
    type?: EnumConnectionTypeFilter<"Connection"> | $Enums.ConnectionType
    mutualConnections?: IntFilter<"Connection"> | number
    connectedAt?: DateTimeFilter<"Connection"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    connectedUser?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ConnectionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    connectedUserId?: SortOrder
    type?: SortOrder
    mutualConnections?: SortOrder
    connectedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    connectedUser?: UserOrderByWithRelationInput
  }

  export type ConnectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_connectedUserId?: ConnectionUserIdConnectedUserIdCompoundUniqueInput
    AND?: ConnectionWhereInput | ConnectionWhereInput[]
    OR?: ConnectionWhereInput[]
    NOT?: ConnectionWhereInput | ConnectionWhereInput[]
    userId?: StringFilter<"Connection"> | string
    connectedUserId?: StringFilter<"Connection"> | string
    type?: EnumConnectionTypeFilter<"Connection"> | $Enums.ConnectionType
    mutualConnections?: IntFilter<"Connection"> | number
    connectedAt?: DateTimeFilter<"Connection"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    connectedUser?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_connectedUserId">

  export type ConnectionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    connectedUserId?: SortOrder
    type?: SortOrder
    mutualConnections?: SortOrder
    connectedAt?: SortOrder
    _count?: ConnectionCountOrderByAggregateInput
    _avg?: ConnectionAvgOrderByAggregateInput
    _max?: ConnectionMaxOrderByAggregateInput
    _min?: ConnectionMinOrderByAggregateInput
    _sum?: ConnectionSumOrderByAggregateInput
  }

  export type ConnectionScalarWhereWithAggregatesInput = {
    AND?: ConnectionScalarWhereWithAggregatesInput | ConnectionScalarWhereWithAggregatesInput[]
    OR?: ConnectionScalarWhereWithAggregatesInput[]
    NOT?: ConnectionScalarWhereWithAggregatesInput | ConnectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Connection"> | string
    userId?: StringWithAggregatesFilter<"Connection"> | string
    connectedUserId?: StringWithAggregatesFilter<"Connection"> | string
    type?: EnumConnectionTypeWithAggregatesFilter<"Connection"> | $Enums.ConnectionType
    mutualConnections?: IntWithAggregatesFilter<"Connection"> | number
    connectedAt?: DateTimeWithAggregatesFilter<"Connection"> | Date | string
  }

  export type ConnectionRequestWhereInput = {
    AND?: ConnectionRequestWhereInput | ConnectionRequestWhereInput[]
    OR?: ConnectionRequestWhereInput[]
    NOT?: ConnectionRequestWhereInput | ConnectionRequestWhereInput[]
    id?: StringFilter<"ConnectionRequest"> | string
    senderId?: StringFilter<"ConnectionRequest"> | string
    receiverId?: StringFilter<"ConnectionRequest"> | string
    message?: StringNullableFilter<"ConnectionRequest"> | string | null
    status?: EnumConnectionStatusFilter<"ConnectionRequest"> | $Enums.ConnectionStatus
    requestedAt?: DateTimeFilter<"ConnectionRequest"> | Date | string
    respondedAt?: DateTimeNullableFilter<"ConnectionRequest"> | Date | string | null
    sender?: XOR<UserRelationFilter, UserWhereInput>
    receiver?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ConnectionRequestOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    message?: SortOrderInput | SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    respondedAt?: SortOrderInput | SortOrder
    sender?: UserOrderByWithRelationInput
    receiver?: UserOrderByWithRelationInput
  }

  export type ConnectionRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    senderId_receiverId?: ConnectionRequestSenderIdReceiverIdCompoundUniqueInput
    AND?: ConnectionRequestWhereInput | ConnectionRequestWhereInput[]
    OR?: ConnectionRequestWhereInput[]
    NOT?: ConnectionRequestWhereInput | ConnectionRequestWhereInput[]
    senderId?: StringFilter<"ConnectionRequest"> | string
    receiverId?: StringFilter<"ConnectionRequest"> | string
    message?: StringNullableFilter<"ConnectionRequest"> | string | null
    status?: EnumConnectionStatusFilter<"ConnectionRequest"> | $Enums.ConnectionStatus
    requestedAt?: DateTimeFilter<"ConnectionRequest"> | Date | string
    respondedAt?: DateTimeNullableFilter<"ConnectionRequest"> | Date | string | null
    sender?: XOR<UserRelationFilter, UserWhereInput>
    receiver?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "senderId_receiverId">

  export type ConnectionRequestOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    message?: SortOrderInput | SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    respondedAt?: SortOrderInput | SortOrder
    _count?: ConnectionRequestCountOrderByAggregateInput
    _max?: ConnectionRequestMaxOrderByAggregateInput
    _min?: ConnectionRequestMinOrderByAggregateInput
  }

  export type ConnectionRequestScalarWhereWithAggregatesInput = {
    AND?: ConnectionRequestScalarWhereWithAggregatesInput | ConnectionRequestScalarWhereWithAggregatesInput[]
    OR?: ConnectionRequestScalarWhereWithAggregatesInput[]
    NOT?: ConnectionRequestScalarWhereWithAggregatesInput | ConnectionRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConnectionRequest"> | string
    senderId?: StringWithAggregatesFilter<"ConnectionRequest"> | string
    receiverId?: StringWithAggregatesFilter<"ConnectionRequest"> | string
    message?: StringNullableWithAggregatesFilter<"ConnectionRequest"> | string | null
    status?: EnumConnectionStatusWithAggregatesFilter<"ConnectionRequest"> | $Enums.ConnectionStatus
    requestedAt?: DateTimeWithAggregatesFilter<"ConnectionRequest"> | Date | string
    respondedAt?: DateTimeNullableWithAggregatesFilter<"ConnectionRequest"> | Date | string | null
  }

  export type FeedItemWhereInput = {
    AND?: FeedItemWhereInput | FeedItemWhereInput[]
    OR?: FeedItemWhereInput[]
    NOT?: FeedItemWhereInput | FeedItemWhereInput[]
    id?: StringFilter<"FeedItem"> | string
    type?: EnumFeedItemTypeFilter<"FeedItem"> | $Enums.FeedItemType
    userId?: StringFilter<"FeedItem"> | string
    priority?: EnumPriorityFilter<"FeedItem"> | $Enums.Priority
    title?: StringFilter<"FeedItem"> | string
    description?: StringFilter<"FeedItem"> | string
    image?: StringNullableFilter<"FeedItem"> | string | null
    data?: JsonNullableFilter<"FeedItem">
    timestamp?: DateTimeFilter<"FeedItem"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FeedItemOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type FeedItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeedItemWhereInput | FeedItemWhereInput[]
    OR?: FeedItemWhereInput[]
    NOT?: FeedItemWhereInput | FeedItemWhereInput[]
    type?: EnumFeedItemTypeFilter<"FeedItem"> | $Enums.FeedItemType
    userId?: StringFilter<"FeedItem"> | string
    priority?: EnumPriorityFilter<"FeedItem"> | $Enums.Priority
    title?: StringFilter<"FeedItem"> | string
    description?: StringFilter<"FeedItem"> | string
    image?: StringNullableFilter<"FeedItem"> | string | null
    data?: JsonNullableFilter<"FeedItem">
    timestamp?: DateTimeFilter<"FeedItem"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type FeedItemOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: FeedItemCountOrderByAggregateInput
    _max?: FeedItemMaxOrderByAggregateInput
    _min?: FeedItemMinOrderByAggregateInput
  }

  export type FeedItemScalarWhereWithAggregatesInput = {
    AND?: FeedItemScalarWhereWithAggregatesInput | FeedItemScalarWhereWithAggregatesInput[]
    OR?: FeedItemScalarWhereWithAggregatesInput[]
    NOT?: FeedItemScalarWhereWithAggregatesInput | FeedItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeedItem"> | string
    type?: EnumFeedItemTypeWithAggregatesFilter<"FeedItem"> | $Enums.FeedItemType
    userId?: StringWithAggregatesFilter<"FeedItem"> | string
    priority?: EnumPriorityWithAggregatesFilter<"FeedItem"> | $Enums.Priority
    title?: StringWithAggregatesFilter<"FeedItem"> | string
    description?: StringWithAggregatesFilter<"FeedItem"> | string
    image?: StringNullableWithAggregatesFilter<"FeedItem"> | string | null
    data?: JsonNullableWithAggregatesFilter<"FeedItem">
    timestamp?: DateTimeWithAggregatesFilter<"FeedItem"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    icon?: StringNullableFilter<"Notification"> | string | null
    timestamp?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    icon?: StringNullableFilter<"Notification"> | string | null
    timestamp?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    actionUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type CareerPathWhereInput = {
    AND?: CareerPathWhereInput | CareerPathWhereInput[]
    OR?: CareerPathWhereInput[]
    NOT?: CareerPathWhereInput | CareerPathWhereInput[]
    id?: StringFilter<"CareerPath"> | string
    userId?: StringFilter<"CareerPath"> | string
    currentRole?: StringFilter<"CareerPath"> | string
    targetRole?: StringFilter<"CareerPath"> | string
    estimatedDuration?: IntFilter<"CareerPath"> | number
    createdAt?: DateTimeFilter<"CareerPath"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    nodes?: CareerPathNodeListRelationFilter
    skillGaps?: SkillGapListRelationFilter
  }

  export type CareerPathOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentRole?: SortOrder
    targetRole?: SortOrder
    estimatedDuration?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    nodes?: CareerPathNodeOrderByRelationAggregateInput
    skillGaps?: SkillGapOrderByRelationAggregateInput
  }

  export type CareerPathWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CareerPathWhereInput | CareerPathWhereInput[]
    OR?: CareerPathWhereInput[]
    NOT?: CareerPathWhereInput | CareerPathWhereInput[]
    userId?: StringFilter<"CareerPath"> | string
    currentRole?: StringFilter<"CareerPath"> | string
    targetRole?: StringFilter<"CareerPath"> | string
    estimatedDuration?: IntFilter<"CareerPath"> | number
    createdAt?: DateTimeFilter<"CareerPath"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    nodes?: CareerPathNodeListRelationFilter
    skillGaps?: SkillGapListRelationFilter
  }, "id">

  export type CareerPathOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentRole?: SortOrder
    targetRole?: SortOrder
    estimatedDuration?: SortOrder
    createdAt?: SortOrder
    _count?: CareerPathCountOrderByAggregateInput
    _avg?: CareerPathAvgOrderByAggregateInput
    _max?: CareerPathMaxOrderByAggregateInput
    _min?: CareerPathMinOrderByAggregateInput
    _sum?: CareerPathSumOrderByAggregateInput
  }

  export type CareerPathScalarWhereWithAggregatesInput = {
    AND?: CareerPathScalarWhereWithAggregatesInput | CareerPathScalarWhereWithAggregatesInput[]
    OR?: CareerPathScalarWhereWithAggregatesInput[]
    NOT?: CareerPathScalarWhereWithAggregatesInput | CareerPathScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CareerPath"> | string
    userId?: StringWithAggregatesFilter<"CareerPath"> | string
    currentRole?: StringWithAggregatesFilter<"CareerPath"> | string
    targetRole?: StringWithAggregatesFilter<"CareerPath"> | string
    estimatedDuration?: IntWithAggregatesFilter<"CareerPath"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CareerPath"> | Date | string
  }

  export type CareerPathNodeWhereInput = {
    AND?: CareerPathNodeWhereInput | CareerPathNodeWhereInput[]
    OR?: CareerPathNodeWhereInput[]
    NOT?: CareerPathNodeWhereInput | CareerPathNodeWhereInput[]
    id?: StringFilter<"CareerPathNode"> | string
    careerPathId?: StringFilter<"CareerPathNode"> | string
    stageNumber?: IntFilter<"CareerPathNode"> | number
    title?: StringFilter<"CareerPathNode"> | string
    duration?: IntFilter<"CareerPathNode"> | number
    completed?: BoolFilter<"CareerPathNode"> | boolean
    careerPath?: XOR<CareerPathRelationFilter, CareerPathWhereInput>
  }

  export type CareerPathNodeOrderByWithRelationInput = {
    id?: SortOrder
    careerPathId?: SortOrder
    stageNumber?: SortOrder
    title?: SortOrder
    duration?: SortOrder
    completed?: SortOrder
    careerPath?: CareerPathOrderByWithRelationInput
  }

  export type CareerPathNodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CareerPathNodeWhereInput | CareerPathNodeWhereInput[]
    OR?: CareerPathNodeWhereInput[]
    NOT?: CareerPathNodeWhereInput | CareerPathNodeWhereInput[]
    careerPathId?: StringFilter<"CareerPathNode"> | string
    stageNumber?: IntFilter<"CareerPathNode"> | number
    title?: StringFilter<"CareerPathNode"> | string
    duration?: IntFilter<"CareerPathNode"> | number
    completed?: BoolFilter<"CareerPathNode"> | boolean
    careerPath?: XOR<CareerPathRelationFilter, CareerPathWhereInput>
  }, "id">

  export type CareerPathNodeOrderByWithAggregationInput = {
    id?: SortOrder
    careerPathId?: SortOrder
    stageNumber?: SortOrder
    title?: SortOrder
    duration?: SortOrder
    completed?: SortOrder
    _count?: CareerPathNodeCountOrderByAggregateInput
    _avg?: CareerPathNodeAvgOrderByAggregateInput
    _max?: CareerPathNodeMaxOrderByAggregateInput
    _min?: CareerPathNodeMinOrderByAggregateInput
    _sum?: CareerPathNodeSumOrderByAggregateInput
  }

  export type CareerPathNodeScalarWhereWithAggregatesInput = {
    AND?: CareerPathNodeScalarWhereWithAggregatesInput | CareerPathNodeScalarWhereWithAggregatesInput[]
    OR?: CareerPathNodeScalarWhereWithAggregatesInput[]
    NOT?: CareerPathNodeScalarWhereWithAggregatesInput | CareerPathNodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CareerPathNode"> | string
    careerPathId?: StringWithAggregatesFilter<"CareerPathNode"> | string
    stageNumber?: IntWithAggregatesFilter<"CareerPathNode"> | number
    title?: StringWithAggregatesFilter<"CareerPathNode"> | string
    duration?: IntWithAggregatesFilter<"CareerPathNode"> | number
    completed?: BoolWithAggregatesFilter<"CareerPathNode"> | boolean
  }

  export type SkillGapWhereInput = {
    AND?: SkillGapWhereInput | SkillGapWhereInput[]
    OR?: SkillGapWhereInput[]
    NOT?: SkillGapWhereInput | SkillGapWhereInput[]
    id?: StringFilter<"SkillGap"> | string
    careerPathId?: StringFilter<"SkillGap"> | string
    skillId?: StringFilter<"SkillGap"> | string
    currentLevel?: EnumSkillLevelFilter<"SkillGap"> | $Enums.SkillLevel
    targetLevel?: EnumSkillLevelFilter<"SkillGap"> | $Enums.SkillLevel
    priority?: EnumPriorityFilter<"SkillGap"> | $Enums.Priority
    careerPath?: XOR<CareerPathRelationFilter, CareerPathWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }

  export type SkillGapOrderByWithRelationInput = {
    id?: SortOrder
    careerPathId?: SortOrder
    skillId?: SortOrder
    currentLevel?: SortOrder
    targetLevel?: SortOrder
    priority?: SortOrder
    careerPath?: CareerPathOrderByWithRelationInput
    skill?: SkillOrderByWithRelationInput
  }

  export type SkillGapWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SkillGapWhereInput | SkillGapWhereInput[]
    OR?: SkillGapWhereInput[]
    NOT?: SkillGapWhereInput | SkillGapWhereInput[]
    careerPathId?: StringFilter<"SkillGap"> | string
    skillId?: StringFilter<"SkillGap"> | string
    currentLevel?: EnumSkillLevelFilter<"SkillGap"> | $Enums.SkillLevel
    targetLevel?: EnumSkillLevelFilter<"SkillGap"> | $Enums.SkillLevel
    priority?: EnumPriorityFilter<"SkillGap"> | $Enums.Priority
    careerPath?: XOR<CareerPathRelationFilter, CareerPathWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }, "id">

  export type SkillGapOrderByWithAggregationInput = {
    id?: SortOrder
    careerPathId?: SortOrder
    skillId?: SortOrder
    currentLevel?: SortOrder
    targetLevel?: SortOrder
    priority?: SortOrder
    _count?: SkillGapCountOrderByAggregateInput
    _max?: SkillGapMaxOrderByAggregateInput
    _min?: SkillGapMinOrderByAggregateInput
  }

  export type SkillGapScalarWhereWithAggregatesInput = {
    AND?: SkillGapScalarWhereWithAggregatesInput | SkillGapScalarWhereWithAggregatesInput[]
    OR?: SkillGapScalarWhereWithAggregatesInput[]
    NOT?: SkillGapScalarWhereWithAggregatesInput | SkillGapScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SkillGap"> | string
    careerPathId?: StringWithAggregatesFilter<"SkillGap"> | string
    skillId?: StringWithAggregatesFilter<"SkillGap"> | string
    currentLevel?: EnumSkillLevelWithAggregatesFilter<"SkillGap"> | $Enums.SkillLevel
    targetLevel?: EnumSkillLevelWithAggregatesFilter<"SkillGap"> | $Enums.SkillLevel
    priority?: EnumPriorityWithAggregatesFilter<"SkillGap"> | $Enums.Priority
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    provider?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    thumbnail?: StringNullableFilter<"Course"> | string | null
    duration?: IntFilter<"Course"> | number
    level?: EnumSkillLevelFilter<"Course"> | $Enums.SkillLevel
    rating?: DecimalFilter<"Course"> | Decimal | DecimalJsLike | number | string
    reviewCount?: IntFilter<"Course"> | number
    price?: BigIntFilter<"Course"> | bigint | number
    url?: StringFilter<"Course"> | string
    skills?: CourseSkillListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    provider?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    duration?: SortOrder
    level?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    price?: SortOrder
    url?: SortOrder
    skills?: CourseSkillOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    title?: StringFilter<"Course"> | string
    provider?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    thumbnail?: StringNullableFilter<"Course"> | string | null
    duration?: IntFilter<"Course"> | number
    level?: EnumSkillLevelFilter<"Course"> | $Enums.SkillLevel
    rating?: DecimalFilter<"Course"> | Decimal | DecimalJsLike | number | string
    reviewCount?: IntFilter<"Course"> | number
    price?: BigIntFilter<"Course"> | bigint | number
    url?: StringFilter<"Course"> | string
    skills?: CourseSkillListRelationFilter
  }, "id">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    provider?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    duration?: SortOrder
    level?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    price?: SortOrder
    url?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Course"> | string
    title?: StringWithAggregatesFilter<"Course"> | string
    provider?: StringWithAggregatesFilter<"Course"> | string
    description?: StringWithAggregatesFilter<"Course"> | string
    thumbnail?: StringNullableWithAggregatesFilter<"Course"> | string | null
    duration?: IntWithAggregatesFilter<"Course"> | number
    level?: EnumSkillLevelWithAggregatesFilter<"Course"> | $Enums.SkillLevel
    rating?: DecimalWithAggregatesFilter<"Course"> | Decimal | DecimalJsLike | number | string
    reviewCount?: IntWithAggregatesFilter<"Course"> | number
    price?: BigIntWithAggregatesFilter<"Course"> | bigint | number
    url?: StringWithAggregatesFilter<"Course"> | string
  }

  export type CourseSkillWhereInput = {
    AND?: CourseSkillWhereInput | CourseSkillWhereInput[]
    OR?: CourseSkillWhereInput[]
    NOT?: CourseSkillWhereInput | CourseSkillWhereInput[]
    courseId?: StringFilter<"CourseSkill"> | string
    skillId?: StringFilter<"CourseSkill"> | string
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }

  export type CourseSkillOrderByWithRelationInput = {
    courseId?: SortOrder
    skillId?: SortOrder
    course?: CourseOrderByWithRelationInput
    skill?: SkillOrderByWithRelationInput
  }

  export type CourseSkillWhereUniqueInput = Prisma.AtLeast<{
    courseId_skillId?: CourseSkillCourseIdSkillIdCompoundUniqueInput
    AND?: CourseSkillWhereInput | CourseSkillWhereInput[]
    OR?: CourseSkillWhereInput[]
    NOT?: CourseSkillWhereInput | CourseSkillWhereInput[]
    courseId?: StringFilter<"CourseSkill"> | string
    skillId?: StringFilter<"CourseSkill"> | string
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }, "courseId_skillId">

  export type CourseSkillOrderByWithAggregationInput = {
    courseId?: SortOrder
    skillId?: SortOrder
    _count?: CourseSkillCountOrderByAggregateInput
    _max?: CourseSkillMaxOrderByAggregateInput
    _min?: CourseSkillMinOrderByAggregateInput
  }

  export type CourseSkillScalarWhereWithAggregatesInput = {
    AND?: CourseSkillScalarWhereWithAggregatesInput | CourseSkillScalarWhereWithAggregatesInput[]
    OR?: CourseSkillScalarWhereWithAggregatesInput[]
    NOT?: CourseSkillScalarWhereWithAggregatesInput | CourseSkillScalarWhereWithAggregatesInput[]
    courseId?: StringWithAggregatesFilter<"CourseSkill"> | string
    skillId?: StringWithAggregatesFilter<"CourseSkill"> | string
  }

  export type VerificationRequestWhereInput = {
    AND?: VerificationRequestWhereInput | VerificationRequestWhereInput[]
    OR?: VerificationRequestWhereInput[]
    NOT?: VerificationRequestWhereInput | VerificationRequestWhereInput[]
    id?: StringFilter<"VerificationRequest"> | string
    credentialId?: StringFilter<"VerificationRequest"> | string
    requestedBy?: StringFilter<"VerificationRequest"> | string
    status?: EnumVerificationStatusFilter<"VerificationRequest"> | $Enums.VerificationStatus
    blockchainHash?: StringNullableFilter<"VerificationRequest"> | string | null
    requestedAt?: DateTimeFilter<"VerificationRequest"> | Date | string
    processedAt?: DateTimeNullableFilter<"VerificationRequest"> | Date | string | null
    credential?: XOR<CredentialRelationFilter, CredentialWhereInput>
    requester?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type VerificationRequestOrderByWithRelationInput = {
    id?: SortOrder
    credentialId?: SortOrder
    requestedBy?: SortOrder
    status?: SortOrder
    blockchainHash?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    credential?: CredentialOrderByWithRelationInput
    requester?: UserOrderByWithRelationInput
  }

  export type VerificationRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationRequestWhereInput | VerificationRequestWhereInput[]
    OR?: VerificationRequestWhereInput[]
    NOT?: VerificationRequestWhereInput | VerificationRequestWhereInput[]
    credentialId?: StringFilter<"VerificationRequest"> | string
    requestedBy?: StringFilter<"VerificationRequest"> | string
    status?: EnumVerificationStatusFilter<"VerificationRequest"> | $Enums.VerificationStatus
    blockchainHash?: StringNullableFilter<"VerificationRequest"> | string | null
    requestedAt?: DateTimeFilter<"VerificationRequest"> | Date | string
    processedAt?: DateTimeNullableFilter<"VerificationRequest"> | Date | string | null
    credential?: XOR<CredentialRelationFilter, CredentialWhereInput>
    requester?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type VerificationRequestOrderByWithAggregationInput = {
    id?: SortOrder
    credentialId?: SortOrder
    requestedBy?: SortOrder
    status?: SortOrder
    blockchainHash?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    _count?: VerificationRequestCountOrderByAggregateInput
    _max?: VerificationRequestMaxOrderByAggregateInput
    _min?: VerificationRequestMinOrderByAggregateInput
  }

  export type VerificationRequestScalarWhereWithAggregatesInput = {
    AND?: VerificationRequestScalarWhereWithAggregatesInput | VerificationRequestScalarWhereWithAggregatesInput[]
    OR?: VerificationRequestScalarWhereWithAggregatesInput[]
    NOT?: VerificationRequestScalarWhereWithAggregatesInput | VerificationRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerificationRequest"> | string
    credentialId?: StringWithAggregatesFilter<"VerificationRequest"> | string
    requestedBy?: StringWithAggregatesFilter<"VerificationRequest"> | string
    status?: EnumVerificationStatusWithAggregatesFilter<"VerificationRequest"> | $Enums.VerificationStatus
    blockchainHash?: StringNullableWithAggregatesFilter<"VerificationRequest"> | string | null
    requestedAt?: DateTimeWithAggregatesFilter<"VerificationRequest"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"VerificationRequest"> | Date | string | null
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    read?: BoolFilter<"Message"> | boolean
    sentAt?: DateTimeFilter<"Message"> | Date | string
    sender?: XOR<UserRelationFilter, UserWhereInput>
    receiver?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    read?: SortOrder
    sentAt?: SortOrder
    sender?: UserOrderByWithRelationInput
    receiver?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    read?: BoolFilter<"Message"> | boolean
    sentAt?: DateTimeFilter<"Message"> | Date | string
    sender?: XOR<UserRelationFilter, UserWhereInput>
    receiver?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    read?: SortOrder
    sentAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    receiverId?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    read?: BoolWithAggregatesFilter<"Message"> | boolean
    sentAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileCreateNestedOneWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    credentials?: CredentialCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    applications?: ApplicationCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathCreateNestedManyWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    endorsements?: EndorsementCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestCreateNestedManyWithoutRequesterInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileUncheckedCreateNestedOneWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    credentials?: CredentialUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionUncheckedCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionUncheckedCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestUncheckedCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestUncheckedCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    endorsements?: EndorsementUncheckedCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    credentials?: CredentialUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    applications?: ApplicationUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUpdateManyWithoutRequesterNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUncheckedUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    credentials?: CredentialUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUncheckedUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUncheckedUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUncheckedUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUncheckedUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUncheckedUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUncheckedUpdateManyWithoutRequesterNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearnerProfileCreateInput = {
    bio?: string | null
    location?: string | null
    university?: string | null
    major?: string | null
    graduationYear?: number | null
    skillsMatchPercentage?: number
    verificationStatus?: $Enums.VerificationStatus
    user: UserCreateNestedOneWithoutLearnerProfileInput
  }

  export type LearnerProfileUncheckedCreateInput = {
    userId: string
    bio?: string | null
    location?: string | null
    university?: string | null
    major?: string | null
    graduationYear?: number | null
    skillsMatchPercentage?: number
    verificationStatus?: $Enums.VerificationStatus
  }

  export type LearnerProfileUpdateInput = {
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    university?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    skillsMatchPercentage?: IntFieldUpdateOperationsInput | number
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    user?: UserUpdateOneRequiredWithoutLearnerProfileNestedInput
  }

  export type LearnerProfileUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    university?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    skillsMatchPercentage?: IntFieldUpdateOperationsInput | number
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
  }

  export type LearnerProfileCreateManyInput = {
    userId: string
    bio?: string | null
    location?: string | null
    university?: string | null
    major?: string | null
    graduationYear?: number | null
    skillsMatchPercentage?: number
    verificationStatus?: $Enums.VerificationStatus
  }

  export type LearnerProfileUpdateManyMutationInput = {
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    university?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    skillsMatchPercentage?: IntFieldUpdateOperationsInput | number
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
  }

  export type LearnerProfileUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    university?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    skillsMatchPercentage?: IntFieldUpdateOperationsInput | number
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
  }

  export type SkillCreateInput = {
    id?: string
    name: string
    category: $Enums.SkillCategory
    description?: string | null
    verified?: boolean
    trending?: boolean
    userSkills?: UserSkillCreateNestedManyWithoutSkillInput
    credentialSkills?: CredentialSkillCreateNestedManyWithoutSkillInput
    projectSkills?: ProjectSkillCreateNestedManyWithoutSkillInput
    opportunitySkills?: OpportunitySkillCreateNestedManyWithoutSkillInput
    courseSkills?: CourseSkillCreateNestedManyWithoutSkillInput
    trendingData?: TrendingSkillCreateNestedOneWithoutSkillInput
    skillGaps?: SkillGapCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateInput = {
    id?: string
    name: string
    category: $Enums.SkillCategory
    description?: string | null
    verified?: boolean
    trending?: boolean
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutSkillInput
    credentialSkills?: CredentialSkillUncheckedCreateNestedManyWithoutSkillInput
    projectSkills?: ProjectSkillUncheckedCreateNestedManyWithoutSkillInput
    opportunitySkills?: OpportunitySkillUncheckedCreateNestedManyWithoutSkillInput
    courseSkills?: CourseSkillUncheckedCreateNestedManyWithoutSkillInput
    trendingData?: TrendingSkillUncheckedCreateNestedOneWithoutSkillInput
    skillGaps?: SkillGapUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    userSkills?: UserSkillUpdateManyWithoutSkillNestedInput
    credentialSkills?: CredentialSkillUpdateManyWithoutSkillNestedInput
    projectSkills?: ProjectSkillUpdateManyWithoutSkillNestedInput
    opportunitySkills?: OpportunitySkillUpdateManyWithoutSkillNestedInput
    courseSkills?: CourseSkillUpdateManyWithoutSkillNestedInput
    trendingData?: TrendingSkillUpdateOneWithoutSkillNestedInput
    skillGaps?: SkillGapUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    userSkills?: UserSkillUncheckedUpdateManyWithoutSkillNestedInput
    credentialSkills?: CredentialSkillUncheckedUpdateManyWithoutSkillNestedInput
    projectSkills?: ProjectSkillUncheckedUpdateManyWithoutSkillNestedInput
    opportunitySkills?: OpportunitySkillUncheckedUpdateManyWithoutSkillNestedInput
    courseSkills?: CourseSkillUncheckedUpdateManyWithoutSkillNestedInput
    trendingData?: TrendingSkillUncheckedUpdateOneWithoutSkillNestedInput
    skillGaps?: SkillGapUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type SkillCreateManyInput = {
    id?: string
    name: string
    category: $Enums.SkillCategory
    description?: string | null
    verified?: boolean
    trending?: boolean
  }

  export type SkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserSkillCreateInput = {
    id?: string
    level: $Enums.SkillLevel
    endorsements?: number
    verified?: boolean
    addedAt?: Date | string
    user: UserCreateNestedOneWithoutUserSkillsInput
    skill: SkillCreateNestedOneWithoutUserSkillsInput
  }

  export type UserSkillUncheckedCreateInput = {
    id?: string
    userId: string
    skillId: string
    level: $Enums.SkillLevel
    endorsements?: number
    verified?: boolean
    addedAt?: Date | string
  }

  export type UserSkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    endorsements?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserSkillsNestedInput
    skill?: SkillUpdateOneRequiredWithoutUserSkillsNestedInput
  }

  export type UserSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    endorsements?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSkillCreateManyInput = {
    id?: string
    userId: string
    skillId: string
    level: $Enums.SkillLevel
    endorsements?: number
    verified?: boolean
    addedAt?: Date | string
  }

  export type UserSkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    endorsements?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    endorsements?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrendingSkillCreateInput = {
    demandPercentage: Decimal | DecimalJsLike | number | string
    growthRate: Decimal | DecimalJsLike | number | string
    averageSalary: bigint | number
    openPositions: number
    updatedAt?: Date | string
    skill: SkillCreateNestedOneWithoutTrendingDataInput
  }

  export type TrendingSkillUncheckedCreateInput = {
    skillId: string
    demandPercentage: Decimal | DecimalJsLike | number | string
    growthRate: Decimal | DecimalJsLike | number | string
    averageSalary: bigint | number
    openPositions: number
    updatedAt?: Date | string
  }

  export type TrendingSkillUpdateInput = {
    demandPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    growthRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    averageSalary?: BigIntFieldUpdateOperationsInput | bigint | number
    openPositions?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skill?: SkillUpdateOneRequiredWithoutTrendingDataNestedInput
  }

  export type TrendingSkillUncheckedUpdateInput = {
    skillId?: StringFieldUpdateOperationsInput | string
    demandPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    growthRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    averageSalary?: BigIntFieldUpdateOperationsInput | bigint | number
    openPositions?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrendingSkillCreateManyInput = {
    skillId: string
    demandPercentage: Decimal | DecimalJsLike | number | string
    growthRate: Decimal | DecimalJsLike | number | string
    averageSalary: bigint | number
    openPositions: number
    updatedAt?: Date | string
  }

  export type TrendingSkillUpdateManyMutationInput = {
    demandPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    growthRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    averageSalary?: BigIntFieldUpdateOperationsInput | bigint | number
    openPositions?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrendingSkillUncheckedUpdateManyInput = {
    skillId?: StringFieldUpdateOperationsInput | string
    demandPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    growthRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    averageSalary?: BigIntFieldUpdateOperationsInput | bigint | number
    openPositions?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CredentialCreateInput = {
    id?: string
    title: string
    issuer: string
    type: $Enums.CredentialType
    issueDate: Date | string
    expiryDate?: Date | string | null
    verified?: boolean
    blockchainHash?: string | null
    qrCode?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCredentialsInput
    skills?: CredentialSkillCreateNestedManyWithoutCredentialInput
    verificationRequests?: VerificationRequestCreateNestedManyWithoutCredentialInput
  }

  export type CredentialUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    issuer: string
    type: $Enums.CredentialType
    issueDate: Date | string
    expiryDate?: Date | string | null
    verified?: boolean
    blockchainHash?: string | null
    qrCode?: string | null
    createdAt?: Date | string
    skills?: CredentialSkillUncheckedCreateNestedManyWithoutCredentialInput
    verificationRequests?: VerificationRequestUncheckedCreateNestedManyWithoutCredentialInput
  }

  export type CredentialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    blockchainHash?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCredentialsNestedInput
    skills?: CredentialSkillUpdateManyWithoutCredentialNestedInput
    verificationRequests?: VerificationRequestUpdateManyWithoutCredentialNestedInput
  }

  export type CredentialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    blockchainHash?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: CredentialSkillUncheckedUpdateManyWithoutCredentialNestedInput
    verificationRequests?: VerificationRequestUncheckedUpdateManyWithoutCredentialNestedInput
  }

  export type CredentialCreateManyInput = {
    id?: string
    userId: string
    title: string
    issuer: string
    type: $Enums.CredentialType
    issueDate: Date | string
    expiryDate?: Date | string | null
    verified?: boolean
    blockchainHash?: string | null
    qrCode?: string | null
    createdAt?: Date | string
  }

  export type CredentialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    blockchainHash?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CredentialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    blockchainHash?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CredentialSkillCreateInput = {
    credential: CredentialCreateNestedOneWithoutSkillsInput
    skill: SkillCreateNestedOneWithoutCredentialSkillsInput
  }

  export type CredentialSkillUncheckedCreateInput = {
    credentialId: string
    skillId: string
  }

  export type CredentialSkillUpdateInput = {
    credential?: CredentialUpdateOneRequiredWithoutSkillsNestedInput
    skill?: SkillUpdateOneRequiredWithoutCredentialSkillsNestedInput
  }

  export type CredentialSkillUncheckedUpdateInput = {
    credentialId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
  }

  export type CredentialSkillCreateManyInput = {
    credentialId: string
    skillId: string
  }

  export type CredentialSkillUpdateManyMutationInput = {

  }

  export type CredentialSkillUncheckedUpdateManyInput = {
    credentialId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCreateInput = {
    id?: string
    title: string
    description: string
    visibility: $Enums.ProjectVisibility
    verified?: boolean
    githubUrl?: string | null
    liveUrl?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    media?: ProjectMediaCreateNestedManyWithoutProjectInput
    skills?: ProjectSkillCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorCreateNestedManyWithoutProjectInput
    endorsements?: EndorsementCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    description: string
    visibility: $Enums.ProjectVisibility
    verified?: boolean
    githubUrl?: string | null
    liveUrl?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: ProjectMediaUncheckedCreateNestedManyWithoutProjectInput
    skills?: ProjectSkillUncheckedCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorUncheckedCreateNestedManyWithoutProjectInput
    endorsements?: EndorsementUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    visibility?: EnumProjectVisibilityFieldUpdateOperationsInput | $Enums.ProjectVisibility
    verified?: BoolFieldUpdateOperationsInput | boolean
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    media?: ProjectMediaUpdateManyWithoutProjectNestedInput
    skills?: ProjectSkillUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUpdateManyWithoutProjectNestedInput
    endorsements?: EndorsementUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    visibility?: EnumProjectVisibilityFieldUpdateOperationsInput | $Enums.ProjectVisibility
    verified?: BoolFieldUpdateOperationsInput | boolean
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: ProjectMediaUncheckedUpdateManyWithoutProjectNestedInput
    skills?: ProjectSkillUncheckedUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUncheckedUpdateManyWithoutProjectNestedInput
    endorsements?: EndorsementUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    userId: string
    title: string
    description: string
    visibility: $Enums.ProjectVisibility
    verified?: boolean
    githubUrl?: string | null
    liveUrl?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    visibility?: EnumProjectVisibilityFieldUpdateOperationsInput | $Enums.ProjectVisibility
    verified?: BoolFieldUpdateOperationsInput | boolean
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    visibility?: EnumProjectVisibilityFieldUpdateOperationsInput | $Enums.ProjectVisibility
    verified?: BoolFieldUpdateOperationsInput | boolean
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMediaCreateInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    thumbnail?: string | null
    caption?: string | null
    displayOrder?: number
    project: ProjectCreateNestedOneWithoutMediaInput
  }

  export type ProjectMediaUncheckedCreateInput = {
    id?: string
    projectId: string
    type: $Enums.MediaType
    url: string
    thumbnail?: string | null
    caption?: string | null
    displayOrder?: number
  }

  export type ProjectMediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    project?: ProjectUpdateOneRequiredWithoutMediaNestedInput
  }

  export type ProjectMediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectMediaCreateManyInput = {
    id?: string
    projectId: string
    type: $Enums.MediaType
    url: string
    thumbnail?: string | null
    caption?: string | null
    displayOrder?: number
  }

  export type ProjectMediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectMediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectSkillCreateInput = {
    project: ProjectCreateNestedOneWithoutSkillsInput
    skill: SkillCreateNestedOneWithoutProjectSkillsInput
  }

  export type ProjectSkillUncheckedCreateInput = {
    projectId: string
    skillId: string
  }

  export type ProjectSkillUpdateInput = {
    project?: ProjectUpdateOneRequiredWithoutSkillsNestedInput
    skill?: SkillUpdateOneRequiredWithoutProjectSkillsNestedInput
  }

  export type ProjectSkillUncheckedUpdateInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectSkillCreateManyInput = {
    projectId: string
    skillId: string
  }

  export type ProjectSkillUpdateManyMutationInput = {

  }

  export type ProjectSkillUncheckedUpdateManyInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCollaboratorCreateInput = {
    role?: string | null
    joinedAt?: Date | string
    project: ProjectCreateNestedOneWithoutCollaboratorsInput
    user: UserCreateNestedOneWithoutProjectCollaborationsInput
  }

  export type ProjectCollaboratorUncheckedCreateInput = {
    projectId: string
    userId: string
    role?: string | null
    joinedAt?: Date | string
  }

  export type ProjectCollaboratorUpdateInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutCollaboratorsNestedInput
    user?: UserUpdateOneRequiredWithoutProjectCollaborationsNestedInput
  }

  export type ProjectCollaboratorUncheckedUpdateInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCollaboratorCreateManyInput = {
    projectId: string
    userId: string
    role?: string | null
    joinedAt?: Date | string
  }

  export type ProjectCollaboratorUpdateManyMutationInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCollaboratorUncheckedUpdateManyInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EndorsementCreateInput = {
    id?: string
    comment?: string | null
    createdAt?: Date | string
    endorser: UserCreateNestedOneWithoutEndorsementsInput
    project?: ProjectCreateNestedOneWithoutEndorsementsInput
  }

  export type EndorsementUncheckedCreateInput = {
    id?: string
    endorserId: string
    comment?: string | null
    createdAt?: Date | string
    projectId?: string | null
  }

  export type EndorsementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endorser?: UserUpdateOneRequiredWithoutEndorsementsNestedInput
    project?: ProjectUpdateOneWithoutEndorsementsNestedInput
  }

  export type EndorsementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endorserId?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EndorsementCreateManyInput = {
    id?: string
    endorserId: string
    comment?: string | null
    createdAt?: Date | string
    projectId?: string | null
  }

  export type EndorsementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EndorsementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    endorserId?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OpportunityCreateInput = {
    id?: string
    title: string
    company: string
    companyLogo?: string | null
    type: $Enums.OpportunityType
    location: string
    remote?: boolean
    description: string
    salaryMin?: bigint | number | null
    salaryMax?: bigint | number | null
    postedDate: Date | string
    deadline?: Date | string | null
    applicationUrl?: string | null
    createdAt?: Date | string
    requirements?: OpportunityRequirementCreateNestedManyWithoutOpportunityInput
    skills?: OpportunitySkillCreateNestedManyWithoutOpportunityInput
    applications?: ApplicationCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateInput = {
    id?: string
    title: string
    company: string
    companyLogo?: string | null
    type: $Enums.OpportunityType
    location: string
    remote?: boolean
    description: string
    salaryMin?: bigint | number | null
    salaryMax?: bigint | number | null
    postedDate: Date | string
    deadline?: Date | string | null
    applicationUrl?: string | null
    createdAt?: Date | string
    requirements?: OpportunityRequirementUncheckedCreateNestedManyWithoutOpportunityInput
    skills?: OpportunitySkillUncheckedCreateNestedManyWithoutOpportunityInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOpportunityTypeFieldUpdateOperationsInput | $Enums.OpportunityType
    location?: StringFieldUpdateOperationsInput | string
    remote?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    salaryMin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salaryMax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    postedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirements?: OpportunityRequirementUpdateManyWithoutOpportunityNestedInput
    skills?: OpportunitySkillUpdateManyWithoutOpportunityNestedInput
    applications?: ApplicationUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOpportunityTypeFieldUpdateOperationsInput | $Enums.OpportunityType
    location?: StringFieldUpdateOperationsInput | string
    remote?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    salaryMin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salaryMax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    postedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirements?: OpportunityRequirementUncheckedUpdateManyWithoutOpportunityNestedInput
    skills?: OpportunitySkillUncheckedUpdateManyWithoutOpportunityNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityCreateManyInput = {
    id?: string
    title: string
    company: string
    companyLogo?: string | null
    type: $Enums.OpportunityType
    location: string
    remote?: boolean
    description: string
    salaryMin?: bigint | number | null
    salaryMax?: bigint | number | null
    postedDate: Date | string
    deadline?: Date | string | null
    applicationUrl?: string | null
    createdAt?: Date | string
  }

  export type OpportunityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOpportunityTypeFieldUpdateOperationsInput | $Enums.OpportunityType
    location?: StringFieldUpdateOperationsInput | string
    remote?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    salaryMin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salaryMax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    postedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOpportunityTypeFieldUpdateOperationsInput | $Enums.OpportunityType
    location?: StringFieldUpdateOperationsInput | string
    remote?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    salaryMin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salaryMax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    postedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityRequirementCreateInput = {
    id?: string
    requirement: string
    displayOrder?: number
    opportunity: OpportunityCreateNestedOneWithoutRequirementsInput
  }

  export type OpportunityRequirementUncheckedCreateInput = {
    id?: string
    opportunityId: string
    requirement: string
    displayOrder?: number
  }

  export type OpportunityRequirementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirement?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    opportunity?: OpportunityUpdateOneRequiredWithoutRequirementsNestedInput
  }

  export type OpportunityRequirementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    requirement?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
  }

  export type OpportunityRequirementCreateManyInput = {
    id?: string
    opportunityId: string
    requirement: string
    displayOrder?: number
  }

  export type OpportunityRequirementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirement?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
  }

  export type OpportunityRequirementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    requirement?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
  }

  export type OpportunitySkillCreateInput = {
    opportunity: OpportunityCreateNestedOneWithoutSkillsInput
    skill: SkillCreateNestedOneWithoutOpportunitySkillsInput
  }

  export type OpportunitySkillUncheckedCreateInput = {
    opportunityId: string
    skillId: string
  }

  export type OpportunitySkillUpdateInput = {
    opportunity?: OpportunityUpdateOneRequiredWithoutSkillsNestedInput
    skill?: SkillUpdateOneRequiredWithoutOpportunitySkillsNestedInput
  }

  export type OpportunitySkillUncheckedUpdateInput = {
    opportunityId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
  }

  export type OpportunitySkillCreateManyInput = {
    opportunityId: string
    skillId: string
  }

  export type OpportunitySkillUpdateManyMutationInput = {

  }

  export type OpportunitySkillUncheckedUpdateManyInput = {
    opportunityId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
  }

  export type ApplicationCreateInput = {
    id?: string
    status: $Enums.ApplicationStatus
    coverLetter?: string | null
    resumeUrl?: string | null
    appliedAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutApplicationsInput
    opportunity: OpportunityCreateNestedOneWithoutApplicationsInput
  }

  export type ApplicationUncheckedCreateInput = {
    id?: string
    userId: string
    opportunityId: string
    status: $Enums.ApplicationStatus
    coverLetter?: string | null
    resumeUrl?: string | null
    appliedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutApplicationsNestedInput
    opportunity?: OpportunityUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type ApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationCreateManyInput = {
    id?: string
    userId: string
    opportunityId: string
    status: $Enums.ApplicationStatus
    coverLetter?: string | null
    resumeUrl?: string | null
    appliedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectionCreateInput = {
    id?: string
    type: $Enums.ConnectionType
    mutualConnections?: number
    connectedAt?: Date | string
    user: UserCreateNestedOneWithoutConnectionsSentInput
    connectedUser: UserCreateNestedOneWithoutConnectionsReceivedInput
  }

  export type ConnectionUncheckedCreateInput = {
    id?: string
    userId: string
    connectedUserId: string
    type: $Enums.ConnectionType
    mutualConnections?: number
    connectedAt?: Date | string
  }

  export type ConnectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType
    mutualConnections?: IntFieldUpdateOperationsInput | number
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConnectionsSentNestedInput
    connectedUser?: UserUpdateOneRequiredWithoutConnectionsReceivedNestedInput
  }

  export type ConnectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    connectedUserId?: StringFieldUpdateOperationsInput | string
    type?: EnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType
    mutualConnections?: IntFieldUpdateOperationsInput | number
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectionCreateManyInput = {
    id?: string
    userId: string
    connectedUserId: string
    type: $Enums.ConnectionType
    mutualConnections?: number
    connectedAt?: Date | string
  }

  export type ConnectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType
    mutualConnections?: IntFieldUpdateOperationsInput | number
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    connectedUserId?: StringFieldUpdateOperationsInput | string
    type?: EnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType
    mutualConnections?: IntFieldUpdateOperationsInput | number
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectionRequestCreateInput = {
    id?: string
    message?: string | null
    status: $Enums.ConnectionStatus
    requestedAt?: Date | string
    respondedAt?: Date | string | null
    sender: UserCreateNestedOneWithoutConnectionRequestsSentInput
    receiver: UserCreateNestedOneWithoutConnectionRequestsReceivedInput
  }

  export type ConnectionRequestUncheckedCreateInput = {
    id?: string
    senderId: string
    receiverId: string
    message?: string | null
    status: $Enums.ConnectionStatus
    requestedAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type ConnectionRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConnectionStatusFieldUpdateOperationsInput | $Enums.ConnectionStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender?: UserUpdateOneRequiredWithoutConnectionRequestsSentNestedInput
    receiver?: UserUpdateOneRequiredWithoutConnectionRequestsReceivedNestedInput
  }

  export type ConnectionRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConnectionStatusFieldUpdateOperationsInput | $Enums.ConnectionStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConnectionRequestCreateManyInput = {
    id?: string
    senderId: string
    receiverId: string
    message?: string | null
    status: $Enums.ConnectionStatus
    requestedAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type ConnectionRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConnectionStatusFieldUpdateOperationsInput | $Enums.ConnectionStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConnectionRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConnectionStatusFieldUpdateOperationsInput | $Enums.ConnectionStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FeedItemCreateInput = {
    id?: string
    type: $Enums.FeedItemType
    priority: $Enums.Priority
    title: string
    description: string
    image?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutFeedItemsInput
  }

  export type FeedItemUncheckedCreateInput = {
    id?: string
    type: $Enums.FeedItemType
    userId: string
    priority: $Enums.Priority
    title: string
    description: string
    image?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type FeedItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedItemTypeFieldUpdateOperationsInput | $Enums.FeedItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFeedItemsNestedInput
  }

  export type FeedItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedItemTypeFieldUpdateOperationsInput | $Enums.FeedItemType
    userId?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedItemCreateManyInput = {
    id?: string
    type: $Enums.FeedItemType
    userId: string
    priority: $Enums.Priority
    title: string
    description: string
    image?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type FeedItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedItemTypeFieldUpdateOperationsInput | $Enums.FeedItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedItemTypeFieldUpdateOperationsInput | $Enums.FeedItemType
    userId?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionUrl?: string | null
    icon?: string | null
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionUrl?: string | null
    icon?: string | null
    timestamp?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionUrl?: string | null
    icon?: string | null
    timestamp?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerPathCreateInput = {
    id?: string
    currentRole: string
    targetRole: string
    estimatedDuration: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCareerPathsInput
    nodes?: CareerPathNodeCreateNestedManyWithoutCareerPathInput
    skillGaps?: SkillGapCreateNestedManyWithoutCareerPathInput
  }

  export type CareerPathUncheckedCreateInput = {
    id?: string
    userId: string
    currentRole: string
    targetRole: string
    estimatedDuration: number
    createdAt?: Date | string
    nodes?: CareerPathNodeUncheckedCreateNestedManyWithoutCareerPathInput
    skillGaps?: SkillGapUncheckedCreateNestedManyWithoutCareerPathInput
  }

  export type CareerPathUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentRole?: StringFieldUpdateOperationsInput | string
    targetRole?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCareerPathsNestedInput
    nodes?: CareerPathNodeUpdateManyWithoutCareerPathNestedInput
    skillGaps?: SkillGapUpdateManyWithoutCareerPathNestedInput
  }

  export type CareerPathUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentRole?: StringFieldUpdateOperationsInput | string
    targetRole?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: CareerPathNodeUncheckedUpdateManyWithoutCareerPathNestedInput
    skillGaps?: SkillGapUncheckedUpdateManyWithoutCareerPathNestedInput
  }

  export type CareerPathCreateManyInput = {
    id?: string
    userId: string
    currentRole: string
    targetRole: string
    estimatedDuration: number
    createdAt?: Date | string
  }

  export type CareerPathUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentRole?: StringFieldUpdateOperationsInput | string
    targetRole?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerPathUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentRole?: StringFieldUpdateOperationsInput | string
    targetRole?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerPathNodeCreateInput = {
    id?: string
    stageNumber: number
    title: string
    duration: number
    completed?: boolean
    careerPath: CareerPathCreateNestedOneWithoutNodesInput
  }

  export type CareerPathNodeUncheckedCreateInput = {
    id?: string
    careerPathId: string
    stageNumber: number
    title: string
    duration: number
    completed?: boolean
  }

  export type CareerPathNodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    careerPath?: CareerPathUpdateOneRequiredWithoutNodesNestedInput
  }

  export type CareerPathNodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    careerPathId?: StringFieldUpdateOperationsInput | string
    stageNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CareerPathNodeCreateManyInput = {
    id?: string
    careerPathId: string
    stageNumber: number
    title: string
    duration: number
    completed?: boolean
  }

  export type CareerPathNodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CareerPathNodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    careerPathId?: StringFieldUpdateOperationsInput | string
    stageNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SkillGapCreateInput = {
    id?: string
    currentLevel: $Enums.SkillLevel
    targetLevel: $Enums.SkillLevel
    priority: $Enums.Priority
    careerPath: CareerPathCreateNestedOneWithoutSkillGapsInput
    skill: SkillCreateNestedOneWithoutSkillGapsInput
  }

  export type SkillGapUncheckedCreateInput = {
    id?: string
    careerPathId: string
    skillId: string
    currentLevel: $Enums.SkillLevel
    targetLevel: $Enums.SkillLevel
    priority: $Enums.Priority
  }

  export type SkillGapUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    targetLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    careerPath?: CareerPathUpdateOneRequiredWithoutSkillGapsNestedInput
    skill?: SkillUpdateOneRequiredWithoutSkillGapsNestedInput
  }

  export type SkillGapUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    careerPathId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    currentLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    targetLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
  }

  export type SkillGapCreateManyInput = {
    id?: string
    careerPathId: string
    skillId: string
    currentLevel: $Enums.SkillLevel
    targetLevel: $Enums.SkillLevel
    priority: $Enums.Priority
  }

  export type SkillGapUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    targetLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
  }

  export type SkillGapUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    careerPathId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    currentLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    targetLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
  }

  export type CourseCreateInput = {
    id?: string
    title: string
    provider: string
    description: string
    thumbnail?: string | null
    duration: number
    level: $Enums.SkillLevel
    rating?: Decimal | DecimalJsLike | number | string
    reviewCount?: number
    price: bigint | number
    url: string
    skills?: CourseSkillCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    title: string
    provider: string
    description: string
    thumbnail?: string | null
    duration: number
    level: $Enums.SkillLevel
    rating?: Decimal | DecimalJsLike | number | string
    reviewCount?: number
    price: bigint | number
    url: string
    skills?: CourseSkillUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reviewCount?: IntFieldUpdateOperationsInput | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    skills?: CourseSkillUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reviewCount?: IntFieldUpdateOperationsInput | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    skills?: CourseSkillUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    title: string
    provider: string
    description: string
    thumbnail?: string | null
    duration: number
    level: $Enums.SkillLevel
    rating?: Decimal | DecimalJsLike | number | string
    reviewCount?: number
    price: bigint | number
    url: string
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reviewCount?: IntFieldUpdateOperationsInput | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reviewCount?: IntFieldUpdateOperationsInput | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type CourseSkillCreateInput = {
    course: CourseCreateNestedOneWithoutSkillsInput
    skill: SkillCreateNestedOneWithoutCourseSkillsInput
  }

  export type CourseSkillUncheckedCreateInput = {
    courseId: string
    skillId: string
  }

  export type CourseSkillUpdateInput = {
    course?: CourseUpdateOneRequiredWithoutSkillsNestedInput
    skill?: SkillUpdateOneRequiredWithoutCourseSkillsNestedInput
  }

  export type CourseSkillUncheckedUpdateInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseSkillCreateManyInput = {
    courseId: string
    skillId: string
  }

  export type CourseSkillUpdateManyMutationInput = {

  }

  export type CourseSkillUncheckedUpdateManyInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationRequestCreateInput = {
    id?: string
    status: $Enums.VerificationStatus
    blockchainHash?: string | null
    requestedAt?: Date | string
    processedAt?: Date | string | null
    credential: CredentialCreateNestedOneWithoutVerificationRequestsInput
    requester: UserCreateNestedOneWithoutVerificationRequestsInput
  }

  export type VerificationRequestUncheckedCreateInput = {
    id?: string
    credentialId: string
    requestedBy: string
    status: $Enums.VerificationStatus
    blockchainHash?: string | null
    requestedAt?: Date | string
    processedAt?: Date | string | null
  }

  export type VerificationRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    blockchainHash?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    credential?: CredentialUpdateOneRequiredWithoutVerificationRequestsNestedInput
    requester?: UserUpdateOneRequiredWithoutVerificationRequestsNestedInput
  }

  export type VerificationRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    blockchainHash?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationRequestCreateManyInput = {
    id?: string
    credentialId: string
    requestedBy: string
    status: $Enums.VerificationStatus
    blockchainHash?: string | null
    requestedAt?: Date | string
    processedAt?: Date | string | null
  }

  export type VerificationRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    blockchainHash?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    blockchainHash?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    read?: boolean
    sentAt?: Date | string
    sender: UserCreateNestedOneWithoutMessagesSentInput
    receiver: UserCreateNestedOneWithoutMessagesReceivedInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    senderId: string
    receiverId: string
    content: string
    read?: boolean
    sentAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
    receiver?: UserUpdateOneRequiredWithoutMessagesReceivedNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    senderId: string
    receiverId: string
    content: string
    read?: boolean
    sentAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type LearnerProfileNullableRelationFilter = {
    is?: LearnerProfileWhereInput | null
    isNot?: LearnerProfileWhereInput | null
  }

  export type UserSkillListRelationFilter = {
    every?: UserSkillWhereInput
    some?: UserSkillWhereInput
    none?: UserSkillWhereInput
  }

  export type CredentialListRelationFilter = {
    every?: CredentialWhereInput
    some?: CredentialWhereInput
    none?: CredentialWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type ApplicationListRelationFilter = {
    every?: ApplicationWhereInput
    some?: ApplicationWhereInput
    none?: ApplicationWhereInput
  }

  export type ConnectionListRelationFilter = {
    every?: ConnectionWhereInput
    some?: ConnectionWhereInput
    none?: ConnectionWhereInput
  }

  export type ConnectionRequestListRelationFilter = {
    every?: ConnectionRequestWhereInput
    some?: ConnectionRequestWhereInput
    none?: ConnectionRequestWhereInput
  }

  export type FeedItemListRelationFilter = {
    every?: FeedItemWhereInput
    some?: FeedItemWhereInput
    none?: FeedItemWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type CareerPathListRelationFilter = {
    every?: CareerPathWhereInput
    some?: CareerPathWhereInput
    none?: CareerPathWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ProjectCollaboratorListRelationFilter = {
    every?: ProjectCollaboratorWhereInput
    some?: ProjectCollaboratorWhereInput
    none?: ProjectCollaboratorWhereInput
  }

  export type EndorsementListRelationFilter = {
    every?: EndorsementWhereInput
    some?: EndorsementWhereInput
    none?: EndorsementWhereInput
  }

  export type VerificationRequestListRelationFilter = {
    every?: VerificationRequestWhereInput
    some?: VerificationRequestWhereInput
    none?: VerificationRequestWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CredentialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConnectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConnectionRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CareerPathOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCollaboratorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EndorsementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerificationRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type LearnerProfileCountOrderByAggregateInput = {
    userId?: SortOrder
    bio?: SortOrder
    location?: SortOrder
    university?: SortOrder
    major?: SortOrder
    graduationYear?: SortOrder
    skillsMatchPercentage?: SortOrder
    verificationStatus?: SortOrder
  }

  export type LearnerProfileAvgOrderByAggregateInput = {
    graduationYear?: SortOrder
    skillsMatchPercentage?: SortOrder
  }

  export type LearnerProfileMaxOrderByAggregateInput = {
    userId?: SortOrder
    bio?: SortOrder
    location?: SortOrder
    university?: SortOrder
    major?: SortOrder
    graduationYear?: SortOrder
    skillsMatchPercentage?: SortOrder
    verificationStatus?: SortOrder
  }

  export type LearnerProfileMinOrderByAggregateInput = {
    userId?: SortOrder
    bio?: SortOrder
    location?: SortOrder
    university?: SortOrder
    major?: SortOrder
    graduationYear?: SortOrder
    skillsMatchPercentage?: SortOrder
    verificationStatus?: SortOrder
  }

  export type LearnerProfileSumOrderByAggregateInput = {
    graduationYear?: SortOrder
    skillsMatchPercentage?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }

  export type EnumSkillCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillCategory | EnumSkillCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SkillCategory[] | ListEnumSkillCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillCategory[] | ListEnumSkillCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillCategoryFilter<$PrismaModel> | $Enums.SkillCategory
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CredentialSkillListRelationFilter = {
    every?: CredentialSkillWhereInput
    some?: CredentialSkillWhereInput
    none?: CredentialSkillWhereInput
  }

  export type ProjectSkillListRelationFilter = {
    every?: ProjectSkillWhereInput
    some?: ProjectSkillWhereInput
    none?: ProjectSkillWhereInput
  }

  export type OpportunitySkillListRelationFilter = {
    every?: OpportunitySkillWhereInput
    some?: OpportunitySkillWhereInput
    none?: OpportunitySkillWhereInput
  }

  export type CourseSkillListRelationFilter = {
    every?: CourseSkillWhereInput
    some?: CourseSkillWhereInput
    none?: CourseSkillWhereInput
  }

  export type TrendingSkillNullableRelationFilter = {
    is?: TrendingSkillWhereInput | null
    isNot?: TrendingSkillWhereInput | null
  }

  export type SkillGapListRelationFilter = {
    every?: SkillGapWhereInput
    some?: SkillGapWhereInput
    none?: SkillGapWhereInput
  }

  export type CredentialSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OpportunitySkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkillGapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkillCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    verified?: SortOrder
    trending?: SortOrder
  }

  export type SkillMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    verified?: SortOrder
    trending?: SortOrder
  }

  export type SkillMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    verified?: SortOrder
    trending?: SortOrder
  }

  export type EnumSkillCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillCategory | EnumSkillCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SkillCategory[] | ListEnumSkillCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillCategory[] | ListEnumSkillCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillCategoryWithAggregatesFilter<$PrismaModel> | $Enums.SkillCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSkillCategoryFilter<$PrismaModel>
    _max?: NestedEnumSkillCategoryFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumSkillLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillLevel | EnumSkillLevelFieldRefInput<$PrismaModel>
    in?: $Enums.SkillLevel[] | ListEnumSkillLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillLevel[] | ListEnumSkillLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillLevelFilter<$PrismaModel> | $Enums.SkillLevel
  }

  export type SkillRelationFilter = {
    is?: SkillWhereInput
    isNot?: SkillWhereInput
  }

  export type UserSkillUserIdSkillIdCompoundUniqueInput = {
    userId: string
    skillId: string
  }

  export type UserSkillCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    endorsements?: SortOrder
    verified?: SortOrder
    addedAt?: SortOrder
  }

  export type UserSkillAvgOrderByAggregateInput = {
    endorsements?: SortOrder
  }

  export type UserSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    endorsements?: SortOrder
    verified?: SortOrder
    addedAt?: SortOrder
  }

  export type UserSkillMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    endorsements?: SortOrder
    verified?: SortOrder
    addedAt?: SortOrder
  }

  export type UserSkillSumOrderByAggregateInput = {
    endorsements?: SortOrder
  }

  export type EnumSkillLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillLevel | EnumSkillLevelFieldRefInput<$PrismaModel>
    in?: $Enums.SkillLevel[] | ListEnumSkillLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillLevel[] | ListEnumSkillLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillLevelWithAggregatesFilter<$PrismaModel> | $Enums.SkillLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSkillLevelFilter<$PrismaModel>
    _max?: NestedEnumSkillLevelFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type TrendingSkillCountOrderByAggregateInput = {
    skillId?: SortOrder
    demandPercentage?: SortOrder
    growthRate?: SortOrder
    averageSalary?: SortOrder
    openPositions?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrendingSkillAvgOrderByAggregateInput = {
    demandPercentage?: SortOrder
    growthRate?: SortOrder
    averageSalary?: SortOrder
    openPositions?: SortOrder
  }

  export type TrendingSkillMaxOrderByAggregateInput = {
    skillId?: SortOrder
    demandPercentage?: SortOrder
    growthRate?: SortOrder
    averageSalary?: SortOrder
    openPositions?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrendingSkillMinOrderByAggregateInput = {
    skillId?: SortOrder
    demandPercentage?: SortOrder
    growthRate?: SortOrder
    averageSalary?: SortOrder
    openPositions?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrendingSkillSumOrderByAggregateInput = {
    demandPercentage?: SortOrder
    growthRate?: SortOrder
    averageSalary?: SortOrder
    openPositions?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type EnumCredentialTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CredentialType | EnumCredentialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CredentialType[] | ListEnumCredentialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CredentialType[] | ListEnumCredentialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCredentialTypeFilter<$PrismaModel> | $Enums.CredentialType
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CredentialCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    issuer?: SortOrder
    type?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrder
    verified?: SortOrder
    blockchainHash?: SortOrder
    qrCode?: SortOrder
    createdAt?: SortOrder
  }

  export type CredentialMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    issuer?: SortOrder
    type?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrder
    verified?: SortOrder
    blockchainHash?: SortOrder
    qrCode?: SortOrder
    createdAt?: SortOrder
  }

  export type CredentialMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    issuer?: SortOrder
    type?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrder
    verified?: SortOrder
    blockchainHash?: SortOrder
    qrCode?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumCredentialTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CredentialType | EnumCredentialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CredentialType[] | ListEnumCredentialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CredentialType[] | ListEnumCredentialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCredentialTypeWithAggregatesFilter<$PrismaModel> | $Enums.CredentialType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCredentialTypeFilter<$PrismaModel>
    _max?: NestedEnumCredentialTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type CredentialRelationFilter = {
    is?: CredentialWhereInput
    isNot?: CredentialWhereInput
  }

  export type CredentialSkillCredentialIdSkillIdCompoundUniqueInput = {
    credentialId: string
    skillId: string
  }

  export type CredentialSkillCountOrderByAggregateInput = {
    credentialId?: SortOrder
    skillId?: SortOrder
  }

  export type CredentialSkillMaxOrderByAggregateInput = {
    credentialId?: SortOrder
    skillId?: SortOrder
  }

  export type CredentialSkillMinOrderByAggregateInput = {
    credentialId?: SortOrder
    skillId?: SortOrder
  }

  export type EnumProjectVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectVisibility | EnumProjectVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectVisibility[] | ListEnumProjectVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectVisibility[] | ListEnumProjectVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectVisibilityFilter<$PrismaModel> | $Enums.ProjectVisibility
  }

  export type ProjectMediaListRelationFilter = {
    every?: ProjectMediaWhereInput
    some?: ProjectMediaWhereInput
    none?: ProjectMediaWhereInput
  }

  export type ProjectMediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    visibility?: SortOrder
    verified?: SortOrder
    githubUrl?: SortOrder
    liveUrl?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    visibility?: SortOrder
    verified?: SortOrder
    githubUrl?: SortOrder
    liveUrl?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    visibility?: SortOrder
    verified?: SortOrder
    githubUrl?: SortOrder
    liveUrl?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumProjectVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectVisibility | EnumProjectVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectVisibility[] | ListEnumProjectVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectVisibility[] | ListEnumProjectVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.ProjectVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectVisibilityFilter<$PrismaModel>
    _max?: NestedEnumProjectVisibilityFilter<$PrismaModel>
  }

  export type EnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectMediaCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrder
    caption?: SortOrder
    displayOrder?: SortOrder
  }

  export type ProjectMediaAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type ProjectMediaMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrder
    caption?: SortOrder
    displayOrder?: SortOrder
  }

  export type ProjectMediaMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrder
    caption?: SortOrder
    displayOrder?: SortOrder
  }

  export type ProjectMediaSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type EnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type ProjectSkillProjectIdSkillIdCompoundUniqueInput = {
    projectId: string
    skillId: string
  }

  export type ProjectSkillCountOrderByAggregateInput = {
    projectId?: SortOrder
    skillId?: SortOrder
  }

  export type ProjectSkillMaxOrderByAggregateInput = {
    projectId?: SortOrder
    skillId?: SortOrder
  }

  export type ProjectSkillMinOrderByAggregateInput = {
    projectId?: SortOrder
    skillId?: SortOrder
  }

  export type ProjectCollaboratorProjectIdUserIdCompoundUniqueInput = {
    projectId: string
    userId: string
  }

  export type ProjectCollaboratorCountOrderByAggregateInput = {
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type ProjectCollaboratorMaxOrderByAggregateInput = {
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type ProjectCollaboratorMinOrderByAggregateInput = {
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type ProjectNullableRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type EndorsementCountOrderByAggregateInput = {
    id?: SortOrder
    endorserId?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
  }

  export type EndorsementMaxOrderByAggregateInput = {
    id?: SortOrder
    endorserId?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
  }

  export type EndorsementMinOrderByAggregateInput = {
    id?: SortOrder
    endorserId?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
  }

  export type EnumOpportunityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityType | EnumOpportunityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityType[] | ListEnumOpportunityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityType[] | ListEnumOpportunityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityTypeFilter<$PrismaModel> | $Enums.OpportunityType
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type OpportunityRequirementListRelationFilter = {
    every?: OpportunityRequirementWhereInput
    some?: OpportunityRequirementWhereInput
    none?: OpportunityRequirementWhereInput
  }

  export type OpportunityRequirementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OpportunityCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    company?: SortOrder
    companyLogo?: SortOrder
    type?: SortOrder
    location?: SortOrder
    remote?: SortOrder
    description?: SortOrder
    salaryMin?: SortOrder
    salaryMax?: SortOrder
    postedDate?: SortOrder
    deadline?: SortOrder
    applicationUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type OpportunityAvgOrderByAggregateInput = {
    salaryMin?: SortOrder
    salaryMax?: SortOrder
  }

  export type OpportunityMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    company?: SortOrder
    companyLogo?: SortOrder
    type?: SortOrder
    location?: SortOrder
    remote?: SortOrder
    description?: SortOrder
    salaryMin?: SortOrder
    salaryMax?: SortOrder
    postedDate?: SortOrder
    deadline?: SortOrder
    applicationUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type OpportunityMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    company?: SortOrder
    companyLogo?: SortOrder
    type?: SortOrder
    location?: SortOrder
    remote?: SortOrder
    description?: SortOrder
    salaryMin?: SortOrder
    salaryMax?: SortOrder
    postedDate?: SortOrder
    deadline?: SortOrder
    applicationUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type OpportunitySumOrderByAggregateInput = {
    salaryMin?: SortOrder
    salaryMax?: SortOrder
  }

  export type EnumOpportunityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityType | EnumOpportunityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityType[] | ListEnumOpportunityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityType[] | ListEnumOpportunityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityTypeWithAggregatesFilter<$PrismaModel> | $Enums.OpportunityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOpportunityTypeFilter<$PrismaModel>
    _max?: NestedEnumOpportunityTypeFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type OpportunityRelationFilter = {
    is?: OpportunityWhereInput
    isNot?: OpportunityWhereInput
  }

  export type OpportunityRequirementCountOrderByAggregateInput = {
    id?: SortOrder
    opportunityId?: SortOrder
    requirement?: SortOrder
    displayOrder?: SortOrder
  }

  export type OpportunityRequirementAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type OpportunityRequirementMaxOrderByAggregateInput = {
    id?: SortOrder
    opportunityId?: SortOrder
    requirement?: SortOrder
    displayOrder?: SortOrder
  }

  export type OpportunityRequirementMinOrderByAggregateInput = {
    id?: SortOrder
    opportunityId?: SortOrder
    requirement?: SortOrder
    displayOrder?: SortOrder
  }

  export type OpportunityRequirementSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type OpportunitySkillOpportunityIdSkillIdCompoundUniqueInput = {
    opportunityId: string
    skillId: string
  }

  export type OpportunitySkillCountOrderByAggregateInput = {
    opportunityId?: SortOrder
    skillId?: SortOrder
  }

  export type OpportunitySkillMaxOrderByAggregateInput = {
    opportunityId?: SortOrder
    skillId?: SortOrder
  }

  export type OpportunitySkillMinOrderByAggregateInput = {
    opportunityId?: SortOrder
    skillId?: SortOrder
  }

  export type EnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type ApplicationUserIdOpportunityIdCompoundUniqueInput = {
    userId: string
    opportunityId: string
  }

  export type ApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    opportunityId?: SortOrder
    status?: SortOrder
    coverLetter?: SortOrder
    resumeUrl?: SortOrder
    appliedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    opportunityId?: SortOrder
    status?: SortOrder
    coverLetter?: SortOrder
    resumeUrl?: SortOrder
    appliedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    opportunityId?: SortOrder
    status?: SortOrder
    coverLetter?: SortOrder
    resumeUrl?: SortOrder
    appliedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type EnumConnectionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConnectionType | EnumConnectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConnectionType[] | ListEnumConnectionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConnectionType[] | ListEnumConnectionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConnectionTypeFilter<$PrismaModel> | $Enums.ConnectionType
  }

  export type ConnectionUserIdConnectedUserIdCompoundUniqueInput = {
    userId: string
    connectedUserId: string
  }

  export type ConnectionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    connectedUserId?: SortOrder
    type?: SortOrder
    mutualConnections?: SortOrder
    connectedAt?: SortOrder
  }

  export type ConnectionAvgOrderByAggregateInput = {
    mutualConnections?: SortOrder
  }

  export type ConnectionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    connectedUserId?: SortOrder
    type?: SortOrder
    mutualConnections?: SortOrder
    connectedAt?: SortOrder
  }

  export type ConnectionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    connectedUserId?: SortOrder
    type?: SortOrder
    mutualConnections?: SortOrder
    connectedAt?: SortOrder
  }

  export type ConnectionSumOrderByAggregateInput = {
    mutualConnections?: SortOrder
  }

  export type EnumConnectionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConnectionType | EnumConnectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConnectionType[] | ListEnumConnectionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConnectionType[] | ListEnumConnectionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConnectionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ConnectionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConnectionTypeFilter<$PrismaModel>
    _max?: NestedEnumConnectionTypeFilter<$PrismaModel>
  }

  export type EnumConnectionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConnectionStatus | EnumConnectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConnectionStatus[] | ListEnumConnectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConnectionStatus[] | ListEnumConnectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConnectionStatusFilter<$PrismaModel> | $Enums.ConnectionStatus
  }

  export type ConnectionRequestSenderIdReceiverIdCompoundUniqueInput = {
    senderId: string
    receiverId: string
  }

  export type ConnectionRequestCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    respondedAt?: SortOrder
  }

  export type ConnectionRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    respondedAt?: SortOrder
  }

  export type ConnectionRequestMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    respondedAt?: SortOrder
  }

  export type EnumConnectionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConnectionStatus | EnumConnectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConnectionStatus[] | ListEnumConnectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConnectionStatus[] | ListEnumConnectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConnectionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConnectionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConnectionStatusFilter<$PrismaModel>
    _max?: NestedEnumConnectionStatusFilter<$PrismaModel>
  }

  export type EnumFeedItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedItemType | EnumFeedItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedItemType[] | ListEnumFeedItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedItemType[] | ListEnumFeedItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedItemTypeFilter<$PrismaModel> | $Enums.FeedItemType
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FeedItemCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    data?: SortOrder
    timestamp?: SortOrder
  }

  export type FeedItemMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    timestamp?: SortOrder
  }

  export type FeedItemMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    timestamp?: SortOrder
  }

  export type EnumFeedItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedItemType | EnumFeedItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedItemType[] | ListEnumFeedItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedItemType[] | ListEnumFeedItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeedItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedItemTypeFilter<$PrismaModel>
    _max?: NestedEnumFeedItemTypeFilter<$PrismaModel>
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrder
    icon?: SortOrder
    timestamp?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrder
    icon?: SortOrder
    timestamp?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrder
    icon?: SortOrder
    timestamp?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type CareerPathNodeListRelationFilter = {
    every?: CareerPathNodeWhereInput
    some?: CareerPathNodeWhereInput
    none?: CareerPathNodeWhereInput
  }

  export type CareerPathNodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CareerPathCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentRole?: SortOrder
    targetRole?: SortOrder
    estimatedDuration?: SortOrder
    createdAt?: SortOrder
  }

  export type CareerPathAvgOrderByAggregateInput = {
    estimatedDuration?: SortOrder
  }

  export type CareerPathMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentRole?: SortOrder
    targetRole?: SortOrder
    estimatedDuration?: SortOrder
    createdAt?: SortOrder
  }

  export type CareerPathMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentRole?: SortOrder
    targetRole?: SortOrder
    estimatedDuration?: SortOrder
    createdAt?: SortOrder
  }

  export type CareerPathSumOrderByAggregateInput = {
    estimatedDuration?: SortOrder
  }

  export type CareerPathRelationFilter = {
    is?: CareerPathWhereInput
    isNot?: CareerPathWhereInput
  }

  export type CareerPathNodeCountOrderByAggregateInput = {
    id?: SortOrder
    careerPathId?: SortOrder
    stageNumber?: SortOrder
    title?: SortOrder
    duration?: SortOrder
    completed?: SortOrder
  }

  export type CareerPathNodeAvgOrderByAggregateInput = {
    stageNumber?: SortOrder
    duration?: SortOrder
  }

  export type CareerPathNodeMaxOrderByAggregateInput = {
    id?: SortOrder
    careerPathId?: SortOrder
    stageNumber?: SortOrder
    title?: SortOrder
    duration?: SortOrder
    completed?: SortOrder
  }

  export type CareerPathNodeMinOrderByAggregateInput = {
    id?: SortOrder
    careerPathId?: SortOrder
    stageNumber?: SortOrder
    title?: SortOrder
    duration?: SortOrder
    completed?: SortOrder
  }

  export type CareerPathNodeSumOrderByAggregateInput = {
    stageNumber?: SortOrder
    duration?: SortOrder
  }

  export type SkillGapCountOrderByAggregateInput = {
    id?: SortOrder
    careerPathId?: SortOrder
    skillId?: SortOrder
    currentLevel?: SortOrder
    targetLevel?: SortOrder
    priority?: SortOrder
  }

  export type SkillGapMaxOrderByAggregateInput = {
    id?: SortOrder
    careerPathId?: SortOrder
    skillId?: SortOrder
    currentLevel?: SortOrder
    targetLevel?: SortOrder
    priority?: SortOrder
  }

  export type SkillGapMinOrderByAggregateInput = {
    id?: SortOrder
    careerPathId?: SortOrder
    skillId?: SortOrder
    currentLevel?: SortOrder
    targetLevel?: SortOrder
    priority?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    provider?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    duration?: SortOrder
    level?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    price?: SortOrder
    url?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    duration?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    price?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    provider?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    duration?: SortOrder
    level?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    price?: SortOrder
    url?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    provider?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    duration?: SortOrder
    level?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    price?: SortOrder
    url?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    duration?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    price?: SortOrder
  }

  export type CourseRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type CourseSkillCourseIdSkillIdCompoundUniqueInput = {
    courseId: string
    skillId: string
  }

  export type CourseSkillCountOrderByAggregateInput = {
    courseId?: SortOrder
    skillId?: SortOrder
  }

  export type CourseSkillMaxOrderByAggregateInput = {
    courseId?: SortOrder
    skillId?: SortOrder
  }

  export type CourseSkillMinOrderByAggregateInput = {
    courseId?: SortOrder
    skillId?: SortOrder
  }

  export type VerificationRequestCountOrderByAggregateInput = {
    id?: SortOrder
    credentialId?: SortOrder
    requestedBy?: SortOrder
    status?: SortOrder
    blockchainHash?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrder
  }

  export type VerificationRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    credentialId?: SortOrder
    requestedBy?: SortOrder
    status?: SortOrder
    blockchainHash?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrder
  }

  export type VerificationRequestMinOrderByAggregateInput = {
    id?: SortOrder
    credentialId?: SortOrder
    requestedBy?: SortOrder
    status?: SortOrder
    blockchainHash?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    read?: SortOrder
    sentAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    read?: SortOrder
    sentAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    read?: SortOrder
    sentAt?: SortOrder
  }

  export type LearnerProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<LearnerProfileCreateWithoutUserInput, LearnerProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: LearnerProfileCreateOrConnectWithoutUserInput
    connect?: LearnerProfileWhereUniqueInput
  }

  export type UserSkillCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSkillCreateWithoutUserInput, UserSkillUncheckedCreateWithoutUserInput> | UserSkillCreateWithoutUserInput[] | UserSkillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSkillCreateOrConnectWithoutUserInput | UserSkillCreateOrConnectWithoutUserInput[]
    createMany?: UserSkillCreateManyUserInputEnvelope
    connect?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
  }

  export type CredentialCreateNestedManyWithoutUserInput = {
    create?: XOR<CredentialCreateWithoutUserInput, CredentialUncheckedCreateWithoutUserInput> | CredentialCreateWithoutUserInput[] | CredentialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CredentialCreateOrConnectWithoutUserInput | CredentialCreateOrConnectWithoutUserInput[]
    createMany?: CredentialCreateManyUserInputEnvelope
    connect?: CredentialWhereUniqueInput | CredentialWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ApplicationCreateNestedManyWithoutUserInput = {
    create?: XOR<ApplicationCreateWithoutUserInput, ApplicationUncheckedCreateWithoutUserInput> | ApplicationCreateWithoutUserInput[] | ApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutUserInput | ApplicationCreateOrConnectWithoutUserInput[]
    createMany?: ApplicationCreateManyUserInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type ConnectionCreateNestedManyWithoutUserInput = {
    create?: XOR<ConnectionCreateWithoutUserInput, ConnectionUncheckedCreateWithoutUserInput> | ConnectionCreateWithoutUserInput[] | ConnectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutUserInput | ConnectionCreateOrConnectWithoutUserInput[]
    createMany?: ConnectionCreateManyUserInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type ConnectionCreateNestedManyWithoutConnectedUserInput = {
    create?: XOR<ConnectionCreateWithoutConnectedUserInput, ConnectionUncheckedCreateWithoutConnectedUserInput> | ConnectionCreateWithoutConnectedUserInput[] | ConnectionUncheckedCreateWithoutConnectedUserInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutConnectedUserInput | ConnectionCreateOrConnectWithoutConnectedUserInput[]
    createMany?: ConnectionCreateManyConnectedUserInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type ConnectionRequestCreateNestedManyWithoutSenderInput = {
    create?: XOR<ConnectionRequestCreateWithoutSenderInput, ConnectionRequestUncheckedCreateWithoutSenderInput> | ConnectionRequestCreateWithoutSenderInput[] | ConnectionRequestUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ConnectionRequestCreateOrConnectWithoutSenderInput | ConnectionRequestCreateOrConnectWithoutSenderInput[]
    createMany?: ConnectionRequestCreateManySenderInputEnvelope
    connect?: ConnectionRequestWhereUniqueInput | ConnectionRequestWhereUniqueInput[]
  }

  export type ConnectionRequestCreateNestedManyWithoutReceiverInput = {
    create?: XOR<ConnectionRequestCreateWithoutReceiverInput, ConnectionRequestUncheckedCreateWithoutReceiverInput> | ConnectionRequestCreateWithoutReceiverInput[] | ConnectionRequestUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: ConnectionRequestCreateOrConnectWithoutReceiverInput | ConnectionRequestCreateOrConnectWithoutReceiverInput[]
    createMany?: ConnectionRequestCreateManyReceiverInputEnvelope
    connect?: ConnectionRequestWhereUniqueInput | ConnectionRequestWhereUniqueInput[]
  }

  export type FeedItemCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedItemCreateWithoutUserInput, FeedItemUncheckedCreateWithoutUserInput> | FeedItemCreateWithoutUserInput[] | FeedItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedItemCreateOrConnectWithoutUserInput | FeedItemCreateOrConnectWithoutUserInput[]
    createMany?: FeedItemCreateManyUserInputEnvelope
    connect?: FeedItemWhereUniqueInput | FeedItemWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CareerPathCreateNestedManyWithoutUserInput = {
    create?: XOR<CareerPathCreateWithoutUserInput, CareerPathUncheckedCreateWithoutUserInput> | CareerPathCreateWithoutUserInput[] | CareerPathUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CareerPathCreateOrConnectWithoutUserInput | CareerPathCreateOrConnectWithoutUserInput[]
    createMany?: CareerPathCreateManyUserInputEnvelope
    connect?: CareerPathWhereUniqueInput | CareerPathWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ProjectCollaboratorCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCollaboratorCreateWithoutUserInput, ProjectCollaboratorUncheckedCreateWithoutUserInput> | ProjectCollaboratorCreateWithoutUserInput[] | ProjectCollaboratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCollaboratorCreateOrConnectWithoutUserInput | ProjectCollaboratorCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCollaboratorCreateManyUserInputEnvelope
    connect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
  }

  export type EndorsementCreateNestedManyWithoutEndorserInput = {
    create?: XOR<EndorsementCreateWithoutEndorserInput, EndorsementUncheckedCreateWithoutEndorserInput> | EndorsementCreateWithoutEndorserInput[] | EndorsementUncheckedCreateWithoutEndorserInput[]
    connectOrCreate?: EndorsementCreateOrConnectWithoutEndorserInput | EndorsementCreateOrConnectWithoutEndorserInput[]
    createMany?: EndorsementCreateManyEndorserInputEnvelope
    connect?: EndorsementWhereUniqueInput | EndorsementWhereUniqueInput[]
  }

  export type VerificationRequestCreateNestedManyWithoutRequesterInput = {
    create?: XOR<VerificationRequestCreateWithoutRequesterInput, VerificationRequestUncheckedCreateWithoutRequesterInput> | VerificationRequestCreateWithoutRequesterInput[] | VerificationRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: VerificationRequestCreateOrConnectWithoutRequesterInput | VerificationRequestCreateOrConnectWithoutRequesterInput[]
    createMany?: VerificationRequestCreateManyRequesterInputEnvelope
    connect?: VerificationRequestWhereUniqueInput | VerificationRequestWhereUniqueInput[]
  }

  export type LearnerProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<LearnerProfileCreateWithoutUserInput, LearnerProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: LearnerProfileCreateOrConnectWithoutUserInput
    connect?: LearnerProfileWhereUniqueInput
  }

  export type UserSkillUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSkillCreateWithoutUserInput, UserSkillUncheckedCreateWithoutUserInput> | UserSkillCreateWithoutUserInput[] | UserSkillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSkillCreateOrConnectWithoutUserInput | UserSkillCreateOrConnectWithoutUserInput[]
    createMany?: UserSkillCreateManyUserInputEnvelope
    connect?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
  }

  export type CredentialUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CredentialCreateWithoutUserInput, CredentialUncheckedCreateWithoutUserInput> | CredentialCreateWithoutUserInput[] | CredentialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CredentialCreateOrConnectWithoutUserInput | CredentialCreateOrConnectWithoutUserInput[]
    createMany?: CredentialCreateManyUserInputEnvelope
    connect?: CredentialWhereUniqueInput | CredentialWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ApplicationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ApplicationCreateWithoutUserInput, ApplicationUncheckedCreateWithoutUserInput> | ApplicationCreateWithoutUserInput[] | ApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutUserInput | ApplicationCreateOrConnectWithoutUserInput[]
    createMany?: ApplicationCreateManyUserInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type ConnectionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConnectionCreateWithoutUserInput, ConnectionUncheckedCreateWithoutUserInput> | ConnectionCreateWithoutUserInput[] | ConnectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutUserInput | ConnectionCreateOrConnectWithoutUserInput[]
    createMany?: ConnectionCreateManyUserInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type ConnectionUncheckedCreateNestedManyWithoutConnectedUserInput = {
    create?: XOR<ConnectionCreateWithoutConnectedUserInput, ConnectionUncheckedCreateWithoutConnectedUserInput> | ConnectionCreateWithoutConnectedUserInput[] | ConnectionUncheckedCreateWithoutConnectedUserInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutConnectedUserInput | ConnectionCreateOrConnectWithoutConnectedUserInput[]
    createMany?: ConnectionCreateManyConnectedUserInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type ConnectionRequestUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<ConnectionRequestCreateWithoutSenderInput, ConnectionRequestUncheckedCreateWithoutSenderInput> | ConnectionRequestCreateWithoutSenderInput[] | ConnectionRequestUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ConnectionRequestCreateOrConnectWithoutSenderInput | ConnectionRequestCreateOrConnectWithoutSenderInput[]
    createMany?: ConnectionRequestCreateManySenderInputEnvelope
    connect?: ConnectionRequestWhereUniqueInput | ConnectionRequestWhereUniqueInput[]
  }

  export type ConnectionRequestUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<ConnectionRequestCreateWithoutReceiverInput, ConnectionRequestUncheckedCreateWithoutReceiverInput> | ConnectionRequestCreateWithoutReceiverInput[] | ConnectionRequestUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: ConnectionRequestCreateOrConnectWithoutReceiverInput | ConnectionRequestCreateOrConnectWithoutReceiverInput[]
    createMany?: ConnectionRequestCreateManyReceiverInputEnvelope
    connect?: ConnectionRequestWhereUniqueInput | ConnectionRequestWhereUniqueInput[]
  }

  export type FeedItemUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedItemCreateWithoutUserInput, FeedItemUncheckedCreateWithoutUserInput> | FeedItemCreateWithoutUserInput[] | FeedItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedItemCreateOrConnectWithoutUserInput | FeedItemCreateOrConnectWithoutUserInput[]
    createMany?: FeedItemCreateManyUserInputEnvelope
    connect?: FeedItemWhereUniqueInput | FeedItemWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CareerPathUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CareerPathCreateWithoutUserInput, CareerPathUncheckedCreateWithoutUserInput> | CareerPathCreateWithoutUserInput[] | CareerPathUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CareerPathCreateOrConnectWithoutUserInput | CareerPathCreateOrConnectWithoutUserInput[]
    createMany?: CareerPathCreateManyUserInputEnvelope
    connect?: CareerPathWhereUniqueInput | CareerPathWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCollaboratorCreateWithoutUserInput, ProjectCollaboratorUncheckedCreateWithoutUserInput> | ProjectCollaboratorCreateWithoutUserInput[] | ProjectCollaboratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCollaboratorCreateOrConnectWithoutUserInput | ProjectCollaboratorCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCollaboratorCreateManyUserInputEnvelope
    connect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
  }

  export type EndorsementUncheckedCreateNestedManyWithoutEndorserInput = {
    create?: XOR<EndorsementCreateWithoutEndorserInput, EndorsementUncheckedCreateWithoutEndorserInput> | EndorsementCreateWithoutEndorserInput[] | EndorsementUncheckedCreateWithoutEndorserInput[]
    connectOrCreate?: EndorsementCreateOrConnectWithoutEndorserInput | EndorsementCreateOrConnectWithoutEndorserInput[]
    createMany?: EndorsementCreateManyEndorserInputEnvelope
    connect?: EndorsementWhereUniqueInput | EndorsementWhereUniqueInput[]
  }

  export type VerificationRequestUncheckedCreateNestedManyWithoutRequesterInput = {
    create?: XOR<VerificationRequestCreateWithoutRequesterInput, VerificationRequestUncheckedCreateWithoutRequesterInput> | VerificationRequestCreateWithoutRequesterInput[] | VerificationRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: VerificationRequestCreateOrConnectWithoutRequesterInput | VerificationRequestCreateOrConnectWithoutRequesterInput[]
    createMany?: VerificationRequestCreateManyRequesterInputEnvelope
    connect?: VerificationRequestWhereUniqueInput | VerificationRequestWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type LearnerProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<LearnerProfileCreateWithoutUserInput, LearnerProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: LearnerProfileCreateOrConnectWithoutUserInput
    upsert?: LearnerProfileUpsertWithoutUserInput
    disconnect?: LearnerProfileWhereInput | boolean
    delete?: LearnerProfileWhereInput | boolean
    connect?: LearnerProfileWhereUniqueInput
    update?: XOR<XOR<LearnerProfileUpdateToOneWithWhereWithoutUserInput, LearnerProfileUpdateWithoutUserInput>, LearnerProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserSkillUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSkillCreateWithoutUserInput, UserSkillUncheckedCreateWithoutUserInput> | UserSkillCreateWithoutUserInput[] | UserSkillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSkillCreateOrConnectWithoutUserInput | UserSkillCreateOrConnectWithoutUserInput[]
    upsert?: UserSkillUpsertWithWhereUniqueWithoutUserInput | UserSkillUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSkillCreateManyUserInputEnvelope
    set?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    disconnect?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    delete?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    connect?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    update?: UserSkillUpdateWithWhereUniqueWithoutUserInput | UserSkillUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSkillUpdateManyWithWhereWithoutUserInput | UserSkillUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSkillScalarWhereInput | UserSkillScalarWhereInput[]
  }

  export type CredentialUpdateManyWithoutUserNestedInput = {
    create?: XOR<CredentialCreateWithoutUserInput, CredentialUncheckedCreateWithoutUserInput> | CredentialCreateWithoutUserInput[] | CredentialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CredentialCreateOrConnectWithoutUserInput | CredentialCreateOrConnectWithoutUserInput[]
    upsert?: CredentialUpsertWithWhereUniqueWithoutUserInput | CredentialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CredentialCreateManyUserInputEnvelope
    set?: CredentialWhereUniqueInput | CredentialWhereUniqueInput[]
    disconnect?: CredentialWhereUniqueInput | CredentialWhereUniqueInput[]
    delete?: CredentialWhereUniqueInput | CredentialWhereUniqueInput[]
    connect?: CredentialWhereUniqueInput | CredentialWhereUniqueInput[]
    update?: CredentialUpdateWithWhereUniqueWithoutUserInput | CredentialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CredentialUpdateManyWithWhereWithoutUserInput | CredentialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CredentialScalarWhereInput | CredentialScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUserInput | ProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUserInput | ProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUserInput | ProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ApplicationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApplicationCreateWithoutUserInput, ApplicationUncheckedCreateWithoutUserInput> | ApplicationCreateWithoutUserInput[] | ApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutUserInput | ApplicationCreateOrConnectWithoutUserInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutUserInput | ApplicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApplicationCreateManyUserInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutUserInput | ApplicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutUserInput | ApplicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type ConnectionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConnectionCreateWithoutUserInput, ConnectionUncheckedCreateWithoutUserInput> | ConnectionCreateWithoutUserInput[] | ConnectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutUserInput | ConnectionCreateOrConnectWithoutUserInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutUserInput | ConnectionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConnectionCreateManyUserInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutUserInput | ConnectionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutUserInput | ConnectionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type ConnectionUpdateManyWithoutConnectedUserNestedInput = {
    create?: XOR<ConnectionCreateWithoutConnectedUserInput, ConnectionUncheckedCreateWithoutConnectedUserInput> | ConnectionCreateWithoutConnectedUserInput[] | ConnectionUncheckedCreateWithoutConnectedUserInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutConnectedUserInput | ConnectionCreateOrConnectWithoutConnectedUserInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutConnectedUserInput | ConnectionUpsertWithWhereUniqueWithoutConnectedUserInput[]
    createMany?: ConnectionCreateManyConnectedUserInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutConnectedUserInput | ConnectionUpdateWithWhereUniqueWithoutConnectedUserInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutConnectedUserInput | ConnectionUpdateManyWithWhereWithoutConnectedUserInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type ConnectionRequestUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ConnectionRequestCreateWithoutSenderInput, ConnectionRequestUncheckedCreateWithoutSenderInput> | ConnectionRequestCreateWithoutSenderInput[] | ConnectionRequestUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ConnectionRequestCreateOrConnectWithoutSenderInput | ConnectionRequestCreateOrConnectWithoutSenderInput[]
    upsert?: ConnectionRequestUpsertWithWhereUniqueWithoutSenderInput | ConnectionRequestUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ConnectionRequestCreateManySenderInputEnvelope
    set?: ConnectionRequestWhereUniqueInput | ConnectionRequestWhereUniqueInput[]
    disconnect?: ConnectionRequestWhereUniqueInput | ConnectionRequestWhereUniqueInput[]
    delete?: ConnectionRequestWhereUniqueInput | ConnectionRequestWhereUniqueInput[]
    connect?: ConnectionRequestWhereUniqueInput | ConnectionRequestWhereUniqueInput[]
    update?: ConnectionRequestUpdateWithWhereUniqueWithoutSenderInput | ConnectionRequestUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ConnectionRequestUpdateManyWithWhereWithoutSenderInput | ConnectionRequestUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ConnectionRequestScalarWhereInput | ConnectionRequestScalarWhereInput[]
  }

  export type ConnectionRequestUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<ConnectionRequestCreateWithoutReceiverInput, ConnectionRequestUncheckedCreateWithoutReceiverInput> | ConnectionRequestCreateWithoutReceiverInput[] | ConnectionRequestUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: ConnectionRequestCreateOrConnectWithoutReceiverInput | ConnectionRequestCreateOrConnectWithoutReceiverInput[]
    upsert?: ConnectionRequestUpsertWithWhereUniqueWithoutReceiverInput | ConnectionRequestUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: ConnectionRequestCreateManyReceiverInputEnvelope
    set?: ConnectionRequestWhereUniqueInput | ConnectionRequestWhereUniqueInput[]
    disconnect?: ConnectionRequestWhereUniqueInput | ConnectionRequestWhereUniqueInput[]
    delete?: ConnectionRequestWhereUniqueInput | ConnectionRequestWhereUniqueInput[]
    connect?: ConnectionRequestWhereUniqueInput | ConnectionRequestWhereUniqueInput[]
    update?: ConnectionRequestUpdateWithWhereUniqueWithoutReceiverInput | ConnectionRequestUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: ConnectionRequestUpdateManyWithWhereWithoutReceiverInput | ConnectionRequestUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: ConnectionRequestScalarWhereInput | ConnectionRequestScalarWhereInput[]
  }

  export type FeedItemUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedItemCreateWithoutUserInput, FeedItemUncheckedCreateWithoutUserInput> | FeedItemCreateWithoutUserInput[] | FeedItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedItemCreateOrConnectWithoutUserInput | FeedItemCreateOrConnectWithoutUserInput[]
    upsert?: FeedItemUpsertWithWhereUniqueWithoutUserInput | FeedItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedItemCreateManyUserInputEnvelope
    set?: FeedItemWhereUniqueInput | FeedItemWhereUniqueInput[]
    disconnect?: FeedItemWhereUniqueInput | FeedItemWhereUniqueInput[]
    delete?: FeedItemWhereUniqueInput | FeedItemWhereUniqueInput[]
    connect?: FeedItemWhereUniqueInput | FeedItemWhereUniqueInput[]
    update?: FeedItemUpdateWithWhereUniqueWithoutUserInput | FeedItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedItemUpdateManyWithWhereWithoutUserInput | FeedItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedItemScalarWhereInput | FeedItemScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CareerPathUpdateManyWithoutUserNestedInput = {
    create?: XOR<CareerPathCreateWithoutUserInput, CareerPathUncheckedCreateWithoutUserInput> | CareerPathCreateWithoutUserInput[] | CareerPathUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CareerPathCreateOrConnectWithoutUserInput | CareerPathCreateOrConnectWithoutUserInput[]
    upsert?: CareerPathUpsertWithWhereUniqueWithoutUserInput | CareerPathUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CareerPathCreateManyUserInputEnvelope
    set?: CareerPathWhereUniqueInput | CareerPathWhereUniqueInput[]
    disconnect?: CareerPathWhereUniqueInput | CareerPathWhereUniqueInput[]
    delete?: CareerPathWhereUniqueInput | CareerPathWhereUniqueInput[]
    connect?: CareerPathWhereUniqueInput | CareerPathWhereUniqueInput[]
    update?: CareerPathUpdateWithWhereUniqueWithoutUserInput | CareerPathUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CareerPathUpdateManyWithWhereWithoutUserInput | CareerPathUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CareerPathScalarWhereInput | CareerPathScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReceiverInput | MessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReceiverInput | MessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReceiverInput | MessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ProjectCollaboratorUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCollaboratorCreateWithoutUserInput, ProjectCollaboratorUncheckedCreateWithoutUserInput> | ProjectCollaboratorCreateWithoutUserInput[] | ProjectCollaboratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCollaboratorCreateOrConnectWithoutUserInput | ProjectCollaboratorCreateOrConnectWithoutUserInput[]
    upsert?: ProjectCollaboratorUpsertWithWhereUniqueWithoutUserInput | ProjectCollaboratorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCollaboratorCreateManyUserInputEnvelope
    set?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    disconnect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    delete?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    connect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    update?: ProjectCollaboratorUpdateWithWhereUniqueWithoutUserInput | ProjectCollaboratorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectCollaboratorUpdateManyWithWhereWithoutUserInput | ProjectCollaboratorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectCollaboratorScalarWhereInput | ProjectCollaboratorScalarWhereInput[]
  }

  export type EndorsementUpdateManyWithoutEndorserNestedInput = {
    create?: XOR<EndorsementCreateWithoutEndorserInput, EndorsementUncheckedCreateWithoutEndorserInput> | EndorsementCreateWithoutEndorserInput[] | EndorsementUncheckedCreateWithoutEndorserInput[]
    connectOrCreate?: EndorsementCreateOrConnectWithoutEndorserInput | EndorsementCreateOrConnectWithoutEndorserInput[]
    upsert?: EndorsementUpsertWithWhereUniqueWithoutEndorserInput | EndorsementUpsertWithWhereUniqueWithoutEndorserInput[]
    createMany?: EndorsementCreateManyEndorserInputEnvelope
    set?: EndorsementWhereUniqueInput | EndorsementWhereUniqueInput[]
    disconnect?: EndorsementWhereUniqueInput | EndorsementWhereUniqueInput[]
    delete?: EndorsementWhereUniqueInput | EndorsementWhereUniqueInput[]
    connect?: EndorsementWhereUniqueInput | EndorsementWhereUniqueInput[]
    update?: EndorsementUpdateWithWhereUniqueWithoutEndorserInput | EndorsementUpdateWithWhereUniqueWithoutEndorserInput[]
    updateMany?: EndorsementUpdateManyWithWhereWithoutEndorserInput | EndorsementUpdateManyWithWhereWithoutEndorserInput[]
    deleteMany?: EndorsementScalarWhereInput | EndorsementScalarWhereInput[]
  }

  export type VerificationRequestUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<VerificationRequestCreateWithoutRequesterInput, VerificationRequestUncheckedCreateWithoutRequesterInput> | VerificationRequestCreateWithoutRequesterInput[] | VerificationRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: VerificationRequestCreateOrConnectWithoutRequesterInput | VerificationRequestCreateOrConnectWithoutRequesterInput[]
    upsert?: VerificationRequestUpsertWithWhereUniqueWithoutRequesterInput | VerificationRequestUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: VerificationRequestCreateManyRequesterInputEnvelope
    set?: VerificationRequestWhereUniqueInput | VerificationRequestWhereUniqueInput[]
    disconnect?: VerificationRequestWhereUniqueInput | VerificationRequestWhereUniqueInput[]
    delete?: VerificationRequestWhereUniqueInput | VerificationRequestWhereUniqueInput[]
    connect?: VerificationRequestWhereUniqueInput | VerificationRequestWhereUniqueInput[]
    update?: VerificationRequestUpdateWithWhereUniqueWithoutRequesterInput | VerificationRequestUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: VerificationRequestUpdateManyWithWhereWithoutRequesterInput | VerificationRequestUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: VerificationRequestScalarWhereInput | VerificationRequestScalarWhereInput[]
  }

  export type LearnerProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<LearnerProfileCreateWithoutUserInput, LearnerProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: LearnerProfileCreateOrConnectWithoutUserInput
    upsert?: LearnerProfileUpsertWithoutUserInput
    disconnect?: LearnerProfileWhereInput | boolean
    delete?: LearnerProfileWhereInput | boolean
    connect?: LearnerProfileWhereUniqueInput
    update?: XOR<XOR<LearnerProfileUpdateToOneWithWhereWithoutUserInput, LearnerProfileUpdateWithoutUserInput>, LearnerProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserSkillUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSkillCreateWithoutUserInput, UserSkillUncheckedCreateWithoutUserInput> | UserSkillCreateWithoutUserInput[] | UserSkillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSkillCreateOrConnectWithoutUserInput | UserSkillCreateOrConnectWithoutUserInput[]
    upsert?: UserSkillUpsertWithWhereUniqueWithoutUserInput | UserSkillUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSkillCreateManyUserInputEnvelope
    set?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    disconnect?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    delete?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    connect?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    update?: UserSkillUpdateWithWhereUniqueWithoutUserInput | UserSkillUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSkillUpdateManyWithWhereWithoutUserInput | UserSkillUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSkillScalarWhereInput | UserSkillScalarWhereInput[]
  }

  export type CredentialUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CredentialCreateWithoutUserInput, CredentialUncheckedCreateWithoutUserInput> | CredentialCreateWithoutUserInput[] | CredentialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CredentialCreateOrConnectWithoutUserInput | CredentialCreateOrConnectWithoutUserInput[]
    upsert?: CredentialUpsertWithWhereUniqueWithoutUserInput | CredentialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CredentialCreateManyUserInputEnvelope
    set?: CredentialWhereUniqueInput | CredentialWhereUniqueInput[]
    disconnect?: CredentialWhereUniqueInput | CredentialWhereUniqueInput[]
    delete?: CredentialWhereUniqueInput | CredentialWhereUniqueInput[]
    connect?: CredentialWhereUniqueInput | CredentialWhereUniqueInput[]
    update?: CredentialUpdateWithWhereUniqueWithoutUserInput | CredentialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CredentialUpdateManyWithWhereWithoutUserInput | CredentialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CredentialScalarWhereInput | CredentialScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUserInput | ProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUserInput | ProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUserInput | ProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ApplicationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApplicationCreateWithoutUserInput, ApplicationUncheckedCreateWithoutUserInput> | ApplicationCreateWithoutUserInput[] | ApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutUserInput | ApplicationCreateOrConnectWithoutUserInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutUserInput | ApplicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApplicationCreateManyUserInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutUserInput | ApplicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutUserInput | ApplicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type ConnectionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConnectionCreateWithoutUserInput, ConnectionUncheckedCreateWithoutUserInput> | ConnectionCreateWithoutUserInput[] | ConnectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutUserInput | ConnectionCreateOrConnectWithoutUserInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutUserInput | ConnectionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConnectionCreateManyUserInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutUserInput | ConnectionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutUserInput | ConnectionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type ConnectionUncheckedUpdateManyWithoutConnectedUserNestedInput = {
    create?: XOR<ConnectionCreateWithoutConnectedUserInput, ConnectionUncheckedCreateWithoutConnectedUserInput> | ConnectionCreateWithoutConnectedUserInput[] | ConnectionUncheckedCreateWithoutConnectedUserInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutConnectedUserInput | ConnectionCreateOrConnectWithoutConnectedUserInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutConnectedUserInput | ConnectionUpsertWithWhereUniqueWithoutConnectedUserInput[]
    createMany?: ConnectionCreateManyConnectedUserInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutConnectedUserInput | ConnectionUpdateWithWhereUniqueWithoutConnectedUserInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutConnectedUserInput | ConnectionUpdateManyWithWhereWithoutConnectedUserInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type ConnectionRequestUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ConnectionRequestCreateWithoutSenderInput, ConnectionRequestUncheckedCreateWithoutSenderInput> | ConnectionRequestCreateWithoutSenderInput[] | ConnectionRequestUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ConnectionRequestCreateOrConnectWithoutSenderInput | ConnectionRequestCreateOrConnectWithoutSenderInput[]
    upsert?: ConnectionRequestUpsertWithWhereUniqueWithoutSenderInput | ConnectionRequestUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ConnectionRequestCreateManySenderInputEnvelope
    set?: ConnectionRequestWhereUniqueInput | ConnectionRequestWhereUniqueInput[]
    disconnect?: ConnectionRequestWhereUniqueInput | ConnectionRequestWhereUniqueInput[]
    delete?: ConnectionRequestWhereUniqueInput | ConnectionRequestWhereUniqueInput[]
    connect?: ConnectionRequestWhereUniqueInput | ConnectionRequestWhereUniqueInput[]
    update?: ConnectionRequestUpdateWithWhereUniqueWithoutSenderInput | ConnectionRequestUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ConnectionRequestUpdateManyWithWhereWithoutSenderInput | ConnectionRequestUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ConnectionRequestScalarWhereInput | ConnectionRequestScalarWhereInput[]
  }

  export type ConnectionRequestUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<ConnectionRequestCreateWithoutReceiverInput, ConnectionRequestUncheckedCreateWithoutReceiverInput> | ConnectionRequestCreateWithoutReceiverInput[] | ConnectionRequestUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: ConnectionRequestCreateOrConnectWithoutReceiverInput | ConnectionRequestCreateOrConnectWithoutReceiverInput[]
    upsert?: ConnectionRequestUpsertWithWhereUniqueWithoutReceiverInput | ConnectionRequestUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: ConnectionRequestCreateManyReceiverInputEnvelope
    set?: ConnectionRequestWhereUniqueInput | ConnectionRequestWhereUniqueInput[]
    disconnect?: ConnectionRequestWhereUniqueInput | ConnectionRequestWhereUniqueInput[]
    delete?: ConnectionRequestWhereUniqueInput | ConnectionRequestWhereUniqueInput[]
    connect?: ConnectionRequestWhereUniqueInput | ConnectionRequestWhereUniqueInput[]
    update?: ConnectionRequestUpdateWithWhereUniqueWithoutReceiverInput | ConnectionRequestUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: ConnectionRequestUpdateManyWithWhereWithoutReceiverInput | ConnectionRequestUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: ConnectionRequestScalarWhereInput | ConnectionRequestScalarWhereInput[]
  }

  export type FeedItemUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedItemCreateWithoutUserInput, FeedItemUncheckedCreateWithoutUserInput> | FeedItemCreateWithoutUserInput[] | FeedItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedItemCreateOrConnectWithoutUserInput | FeedItemCreateOrConnectWithoutUserInput[]
    upsert?: FeedItemUpsertWithWhereUniqueWithoutUserInput | FeedItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedItemCreateManyUserInputEnvelope
    set?: FeedItemWhereUniqueInput | FeedItemWhereUniqueInput[]
    disconnect?: FeedItemWhereUniqueInput | FeedItemWhereUniqueInput[]
    delete?: FeedItemWhereUniqueInput | FeedItemWhereUniqueInput[]
    connect?: FeedItemWhereUniqueInput | FeedItemWhereUniqueInput[]
    update?: FeedItemUpdateWithWhereUniqueWithoutUserInput | FeedItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedItemUpdateManyWithWhereWithoutUserInput | FeedItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedItemScalarWhereInput | FeedItemScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CareerPathUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CareerPathCreateWithoutUserInput, CareerPathUncheckedCreateWithoutUserInput> | CareerPathCreateWithoutUserInput[] | CareerPathUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CareerPathCreateOrConnectWithoutUserInput | CareerPathCreateOrConnectWithoutUserInput[]
    upsert?: CareerPathUpsertWithWhereUniqueWithoutUserInput | CareerPathUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CareerPathCreateManyUserInputEnvelope
    set?: CareerPathWhereUniqueInput | CareerPathWhereUniqueInput[]
    disconnect?: CareerPathWhereUniqueInput | CareerPathWhereUniqueInput[]
    delete?: CareerPathWhereUniqueInput | CareerPathWhereUniqueInput[]
    connect?: CareerPathWhereUniqueInput | CareerPathWhereUniqueInput[]
    update?: CareerPathUpdateWithWhereUniqueWithoutUserInput | CareerPathUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CareerPathUpdateManyWithWhereWithoutUserInput | CareerPathUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CareerPathScalarWhereInput | CareerPathScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReceiverInput | MessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReceiverInput | MessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReceiverInput | MessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCollaboratorCreateWithoutUserInput, ProjectCollaboratorUncheckedCreateWithoutUserInput> | ProjectCollaboratorCreateWithoutUserInput[] | ProjectCollaboratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCollaboratorCreateOrConnectWithoutUserInput | ProjectCollaboratorCreateOrConnectWithoutUserInput[]
    upsert?: ProjectCollaboratorUpsertWithWhereUniqueWithoutUserInput | ProjectCollaboratorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCollaboratorCreateManyUserInputEnvelope
    set?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    disconnect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    delete?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    connect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    update?: ProjectCollaboratorUpdateWithWhereUniqueWithoutUserInput | ProjectCollaboratorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectCollaboratorUpdateManyWithWhereWithoutUserInput | ProjectCollaboratorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectCollaboratorScalarWhereInput | ProjectCollaboratorScalarWhereInput[]
  }

  export type EndorsementUncheckedUpdateManyWithoutEndorserNestedInput = {
    create?: XOR<EndorsementCreateWithoutEndorserInput, EndorsementUncheckedCreateWithoutEndorserInput> | EndorsementCreateWithoutEndorserInput[] | EndorsementUncheckedCreateWithoutEndorserInput[]
    connectOrCreate?: EndorsementCreateOrConnectWithoutEndorserInput | EndorsementCreateOrConnectWithoutEndorserInput[]
    upsert?: EndorsementUpsertWithWhereUniqueWithoutEndorserInput | EndorsementUpsertWithWhereUniqueWithoutEndorserInput[]
    createMany?: EndorsementCreateManyEndorserInputEnvelope
    set?: EndorsementWhereUniqueInput | EndorsementWhereUniqueInput[]
    disconnect?: EndorsementWhereUniqueInput | EndorsementWhereUniqueInput[]
    delete?: EndorsementWhereUniqueInput | EndorsementWhereUniqueInput[]
    connect?: EndorsementWhereUniqueInput | EndorsementWhereUniqueInput[]
    update?: EndorsementUpdateWithWhereUniqueWithoutEndorserInput | EndorsementUpdateWithWhereUniqueWithoutEndorserInput[]
    updateMany?: EndorsementUpdateManyWithWhereWithoutEndorserInput | EndorsementUpdateManyWithWhereWithoutEndorserInput[]
    deleteMany?: EndorsementScalarWhereInput | EndorsementScalarWhereInput[]
  }

  export type VerificationRequestUncheckedUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<VerificationRequestCreateWithoutRequesterInput, VerificationRequestUncheckedCreateWithoutRequesterInput> | VerificationRequestCreateWithoutRequesterInput[] | VerificationRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: VerificationRequestCreateOrConnectWithoutRequesterInput | VerificationRequestCreateOrConnectWithoutRequesterInput[]
    upsert?: VerificationRequestUpsertWithWhereUniqueWithoutRequesterInput | VerificationRequestUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: VerificationRequestCreateManyRequesterInputEnvelope
    set?: VerificationRequestWhereUniqueInput | VerificationRequestWhereUniqueInput[]
    disconnect?: VerificationRequestWhereUniqueInput | VerificationRequestWhereUniqueInput[]
    delete?: VerificationRequestWhereUniqueInput | VerificationRequestWhereUniqueInput[]
    connect?: VerificationRequestWhereUniqueInput | VerificationRequestWhereUniqueInput[]
    update?: VerificationRequestUpdateWithWhereUniqueWithoutRequesterInput | VerificationRequestUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: VerificationRequestUpdateManyWithWhereWithoutRequesterInput | VerificationRequestUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: VerificationRequestScalarWhereInput | VerificationRequestScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLearnerProfileInput = {
    create?: XOR<UserCreateWithoutLearnerProfileInput, UserUncheckedCreateWithoutLearnerProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutLearnerProfileInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumVerificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.VerificationStatus
  }

  export type UserUpdateOneRequiredWithoutLearnerProfileNestedInput = {
    create?: XOR<UserCreateWithoutLearnerProfileInput, UserUncheckedCreateWithoutLearnerProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutLearnerProfileInput
    upsert?: UserUpsertWithoutLearnerProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLearnerProfileInput, UserUpdateWithoutLearnerProfileInput>, UserUncheckedUpdateWithoutLearnerProfileInput>
  }

  export type UserSkillCreateNestedManyWithoutSkillInput = {
    create?: XOR<UserSkillCreateWithoutSkillInput, UserSkillUncheckedCreateWithoutSkillInput> | UserSkillCreateWithoutSkillInput[] | UserSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: UserSkillCreateOrConnectWithoutSkillInput | UserSkillCreateOrConnectWithoutSkillInput[]
    createMany?: UserSkillCreateManySkillInputEnvelope
    connect?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
  }

  export type CredentialSkillCreateNestedManyWithoutSkillInput = {
    create?: XOR<CredentialSkillCreateWithoutSkillInput, CredentialSkillUncheckedCreateWithoutSkillInput> | CredentialSkillCreateWithoutSkillInput[] | CredentialSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: CredentialSkillCreateOrConnectWithoutSkillInput | CredentialSkillCreateOrConnectWithoutSkillInput[]
    createMany?: CredentialSkillCreateManySkillInputEnvelope
    connect?: CredentialSkillWhereUniqueInput | CredentialSkillWhereUniqueInput[]
  }

  export type ProjectSkillCreateNestedManyWithoutSkillInput = {
    create?: XOR<ProjectSkillCreateWithoutSkillInput, ProjectSkillUncheckedCreateWithoutSkillInput> | ProjectSkillCreateWithoutSkillInput[] | ProjectSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ProjectSkillCreateOrConnectWithoutSkillInput | ProjectSkillCreateOrConnectWithoutSkillInput[]
    createMany?: ProjectSkillCreateManySkillInputEnvelope
    connect?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
  }

  export type OpportunitySkillCreateNestedManyWithoutSkillInput = {
    create?: XOR<OpportunitySkillCreateWithoutSkillInput, OpportunitySkillUncheckedCreateWithoutSkillInput> | OpportunitySkillCreateWithoutSkillInput[] | OpportunitySkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: OpportunitySkillCreateOrConnectWithoutSkillInput | OpportunitySkillCreateOrConnectWithoutSkillInput[]
    createMany?: OpportunitySkillCreateManySkillInputEnvelope
    connect?: OpportunitySkillWhereUniqueInput | OpportunitySkillWhereUniqueInput[]
  }

  export type CourseSkillCreateNestedManyWithoutSkillInput = {
    create?: XOR<CourseSkillCreateWithoutSkillInput, CourseSkillUncheckedCreateWithoutSkillInput> | CourseSkillCreateWithoutSkillInput[] | CourseSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: CourseSkillCreateOrConnectWithoutSkillInput | CourseSkillCreateOrConnectWithoutSkillInput[]
    createMany?: CourseSkillCreateManySkillInputEnvelope
    connect?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
  }

  export type TrendingSkillCreateNestedOneWithoutSkillInput = {
    create?: XOR<TrendingSkillCreateWithoutSkillInput, TrendingSkillUncheckedCreateWithoutSkillInput>
    connectOrCreate?: TrendingSkillCreateOrConnectWithoutSkillInput
    connect?: TrendingSkillWhereUniqueInput
  }

  export type SkillGapCreateNestedManyWithoutSkillInput = {
    create?: XOR<SkillGapCreateWithoutSkillInput, SkillGapUncheckedCreateWithoutSkillInput> | SkillGapCreateWithoutSkillInput[] | SkillGapUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: SkillGapCreateOrConnectWithoutSkillInput | SkillGapCreateOrConnectWithoutSkillInput[]
    createMany?: SkillGapCreateManySkillInputEnvelope
    connect?: SkillGapWhereUniqueInput | SkillGapWhereUniqueInput[]
  }

  export type UserSkillUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<UserSkillCreateWithoutSkillInput, UserSkillUncheckedCreateWithoutSkillInput> | UserSkillCreateWithoutSkillInput[] | UserSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: UserSkillCreateOrConnectWithoutSkillInput | UserSkillCreateOrConnectWithoutSkillInput[]
    createMany?: UserSkillCreateManySkillInputEnvelope
    connect?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
  }

  export type CredentialSkillUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<CredentialSkillCreateWithoutSkillInput, CredentialSkillUncheckedCreateWithoutSkillInput> | CredentialSkillCreateWithoutSkillInput[] | CredentialSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: CredentialSkillCreateOrConnectWithoutSkillInput | CredentialSkillCreateOrConnectWithoutSkillInput[]
    createMany?: CredentialSkillCreateManySkillInputEnvelope
    connect?: CredentialSkillWhereUniqueInput | CredentialSkillWhereUniqueInput[]
  }

  export type ProjectSkillUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<ProjectSkillCreateWithoutSkillInput, ProjectSkillUncheckedCreateWithoutSkillInput> | ProjectSkillCreateWithoutSkillInput[] | ProjectSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ProjectSkillCreateOrConnectWithoutSkillInput | ProjectSkillCreateOrConnectWithoutSkillInput[]
    createMany?: ProjectSkillCreateManySkillInputEnvelope
    connect?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
  }

  export type OpportunitySkillUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<OpportunitySkillCreateWithoutSkillInput, OpportunitySkillUncheckedCreateWithoutSkillInput> | OpportunitySkillCreateWithoutSkillInput[] | OpportunitySkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: OpportunitySkillCreateOrConnectWithoutSkillInput | OpportunitySkillCreateOrConnectWithoutSkillInput[]
    createMany?: OpportunitySkillCreateManySkillInputEnvelope
    connect?: OpportunitySkillWhereUniqueInput | OpportunitySkillWhereUniqueInput[]
  }

  export type CourseSkillUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<CourseSkillCreateWithoutSkillInput, CourseSkillUncheckedCreateWithoutSkillInput> | CourseSkillCreateWithoutSkillInput[] | CourseSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: CourseSkillCreateOrConnectWithoutSkillInput | CourseSkillCreateOrConnectWithoutSkillInput[]
    createMany?: CourseSkillCreateManySkillInputEnvelope
    connect?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
  }

  export type TrendingSkillUncheckedCreateNestedOneWithoutSkillInput = {
    create?: XOR<TrendingSkillCreateWithoutSkillInput, TrendingSkillUncheckedCreateWithoutSkillInput>
    connectOrCreate?: TrendingSkillCreateOrConnectWithoutSkillInput
    connect?: TrendingSkillWhereUniqueInput
  }

  export type SkillGapUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<SkillGapCreateWithoutSkillInput, SkillGapUncheckedCreateWithoutSkillInput> | SkillGapCreateWithoutSkillInput[] | SkillGapUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: SkillGapCreateOrConnectWithoutSkillInput | SkillGapCreateOrConnectWithoutSkillInput[]
    createMany?: SkillGapCreateManySkillInputEnvelope
    connect?: SkillGapWhereUniqueInput | SkillGapWhereUniqueInput[]
  }

  export type EnumSkillCategoryFieldUpdateOperationsInput = {
    set?: $Enums.SkillCategory
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserSkillUpdateManyWithoutSkillNestedInput = {
    create?: XOR<UserSkillCreateWithoutSkillInput, UserSkillUncheckedCreateWithoutSkillInput> | UserSkillCreateWithoutSkillInput[] | UserSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: UserSkillCreateOrConnectWithoutSkillInput | UserSkillCreateOrConnectWithoutSkillInput[]
    upsert?: UserSkillUpsertWithWhereUniqueWithoutSkillInput | UserSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: UserSkillCreateManySkillInputEnvelope
    set?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    disconnect?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    delete?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    connect?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    update?: UserSkillUpdateWithWhereUniqueWithoutSkillInput | UserSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: UserSkillUpdateManyWithWhereWithoutSkillInput | UserSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: UserSkillScalarWhereInput | UserSkillScalarWhereInput[]
  }

  export type CredentialSkillUpdateManyWithoutSkillNestedInput = {
    create?: XOR<CredentialSkillCreateWithoutSkillInput, CredentialSkillUncheckedCreateWithoutSkillInput> | CredentialSkillCreateWithoutSkillInput[] | CredentialSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: CredentialSkillCreateOrConnectWithoutSkillInput | CredentialSkillCreateOrConnectWithoutSkillInput[]
    upsert?: CredentialSkillUpsertWithWhereUniqueWithoutSkillInput | CredentialSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: CredentialSkillCreateManySkillInputEnvelope
    set?: CredentialSkillWhereUniqueInput | CredentialSkillWhereUniqueInput[]
    disconnect?: CredentialSkillWhereUniqueInput | CredentialSkillWhereUniqueInput[]
    delete?: CredentialSkillWhereUniqueInput | CredentialSkillWhereUniqueInput[]
    connect?: CredentialSkillWhereUniqueInput | CredentialSkillWhereUniqueInput[]
    update?: CredentialSkillUpdateWithWhereUniqueWithoutSkillInput | CredentialSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: CredentialSkillUpdateManyWithWhereWithoutSkillInput | CredentialSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: CredentialSkillScalarWhereInput | CredentialSkillScalarWhereInput[]
  }

  export type ProjectSkillUpdateManyWithoutSkillNestedInput = {
    create?: XOR<ProjectSkillCreateWithoutSkillInput, ProjectSkillUncheckedCreateWithoutSkillInput> | ProjectSkillCreateWithoutSkillInput[] | ProjectSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ProjectSkillCreateOrConnectWithoutSkillInput | ProjectSkillCreateOrConnectWithoutSkillInput[]
    upsert?: ProjectSkillUpsertWithWhereUniqueWithoutSkillInput | ProjectSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: ProjectSkillCreateManySkillInputEnvelope
    set?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    disconnect?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    delete?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    connect?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    update?: ProjectSkillUpdateWithWhereUniqueWithoutSkillInput | ProjectSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: ProjectSkillUpdateManyWithWhereWithoutSkillInput | ProjectSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: ProjectSkillScalarWhereInput | ProjectSkillScalarWhereInput[]
  }

  export type OpportunitySkillUpdateManyWithoutSkillNestedInput = {
    create?: XOR<OpportunitySkillCreateWithoutSkillInput, OpportunitySkillUncheckedCreateWithoutSkillInput> | OpportunitySkillCreateWithoutSkillInput[] | OpportunitySkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: OpportunitySkillCreateOrConnectWithoutSkillInput | OpportunitySkillCreateOrConnectWithoutSkillInput[]
    upsert?: OpportunitySkillUpsertWithWhereUniqueWithoutSkillInput | OpportunitySkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: OpportunitySkillCreateManySkillInputEnvelope
    set?: OpportunitySkillWhereUniqueInput | OpportunitySkillWhereUniqueInput[]
    disconnect?: OpportunitySkillWhereUniqueInput | OpportunitySkillWhereUniqueInput[]
    delete?: OpportunitySkillWhereUniqueInput | OpportunitySkillWhereUniqueInput[]
    connect?: OpportunitySkillWhereUniqueInput | OpportunitySkillWhereUniqueInput[]
    update?: OpportunitySkillUpdateWithWhereUniqueWithoutSkillInput | OpportunitySkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: OpportunitySkillUpdateManyWithWhereWithoutSkillInput | OpportunitySkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: OpportunitySkillScalarWhereInput | OpportunitySkillScalarWhereInput[]
  }

  export type CourseSkillUpdateManyWithoutSkillNestedInput = {
    create?: XOR<CourseSkillCreateWithoutSkillInput, CourseSkillUncheckedCreateWithoutSkillInput> | CourseSkillCreateWithoutSkillInput[] | CourseSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: CourseSkillCreateOrConnectWithoutSkillInput | CourseSkillCreateOrConnectWithoutSkillInput[]
    upsert?: CourseSkillUpsertWithWhereUniqueWithoutSkillInput | CourseSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: CourseSkillCreateManySkillInputEnvelope
    set?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    disconnect?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    delete?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    connect?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    update?: CourseSkillUpdateWithWhereUniqueWithoutSkillInput | CourseSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: CourseSkillUpdateManyWithWhereWithoutSkillInput | CourseSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: CourseSkillScalarWhereInput | CourseSkillScalarWhereInput[]
  }

  export type TrendingSkillUpdateOneWithoutSkillNestedInput = {
    create?: XOR<TrendingSkillCreateWithoutSkillInput, TrendingSkillUncheckedCreateWithoutSkillInput>
    connectOrCreate?: TrendingSkillCreateOrConnectWithoutSkillInput
    upsert?: TrendingSkillUpsertWithoutSkillInput
    disconnect?: TrendingSkillWhereInput | boolean
    delete?: TrendingSkillWhereInput | boolean
    connect?: TrendingSkillWhereUniqueInput
    update?: XOR<XOR<TrendingSkillUpdateToOneWithWhereWithoutSkillInput, TrendingSkillUpdateWithoutSkillInput>, TrendingSkillUncheckedUpdateWithoutSkillInput>
  }

  export type SkillGapUpdateManyWithoutSkillNestedInput = {
    create?: XOR<SkillGapCreateWithoutSkillInput, SkillGapUncheckedCreateWithoutSkillInput> | SkillGapCreateWithoutSkillInput[] | SkillGapUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: SkillGapCreateOrConnectWithoutSkillInput | SkillGapCreateOrConnectWithoutSkillInput[]
    upsert?: SkillGapUpsertWithWhereUniqueWithoutSkillInput | SkillGapUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: SkillGapCreateManySkillInputEnvelope
    set?: SkillGapWhereUniqueInput | SkillGapWhereUniqueInput[]
    disconnect?: SkillGapWhereUniqueInput | SkillGapWhereUniqueInput[]
    delete?: SkillGapWhereUniqueInput | SkillGapWhereUniqueInput[]
    connect?: SkillGapWhereUniqueInput | SkillGapWhereUniqueInput[]
    update?: SkillGapUpdateWithWhereUniqueWithoutSkillInput | SkillGapUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: SkillGapUpdateManyWithWhereWithoutSkillInput | SkillGapUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: SkillGapScalarWhereInput | SkillGapScalarWhereInput[]
  }

  export type UserSkillUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<UserSkillCreateWithoutSkillInput, UserSkillUncheckedCreateWithoutSkillInput> | UserSkillCreateWithoutSkillInput[] | UserSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: UserSkillCreateOrConnectWithoutSkillInput | UserSkillCreateOrConnectWithoutSkillInput[]
    upsert?: UserSkillUpsertWithWhereUniqueWithoutSkillInput | UserSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: UserSkillCreateManySkillInputEnvelope
    set?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    disconnect?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    delete?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    connect?: UserSkillWhereUniqueInput | UserSkillWhereUniqueInput[]
    update?: UserSkillUpdateWithWhereUniqueWithoutSkillInput | UserSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: UserSkillUpdateManyWithWhereWithoutSkillInput | UserSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: UserSkillScalarWhereInput | UserSkillScalarWhereInput[]
  }

  export type CredentialSkillUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<CredentialSkillCreateWithoutSkillInput, CredentialSkillUncheckedCreateWithoutSkillInput> | CredentialSkillCreateWithoutSkillInput[] | CredentialSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: CredentialSkillCreateOrConnectWithoutSkillInput | CredentialSkillCreateOrConnectWithoutSkillInput[]
    upsert?: CredentialSkillUpsertWithWhereUniqueWithoutSkillInput | CredentialSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: CredentialSkillCreateManySkillInputEnvelope
    set?: CredentialSkillWhereUniqueInput | CredentialSkillWhereUniqueInput[]
    disconnect?: CredentialSkillWhereUniqueInput | CredentialSkillWhereUniqueInput[]
    delete?: CredentialSkillWhereUniqueInput | CredentialSkillWhereUniqueInput[]
    connect?: CredentialSkillWhereUniqueInput | CredentialSkillWhereUniqueInput[]
    update?: CredentialSkillUpdateWithWhereUniqueWithoutSkillInput | CredentialSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: CredentialSkillUpdateManyWithWhereWithoutSkillInput | CredentialSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: CredentialSkillScalarWhereInput | CredentialSkillScalarWhereInput[]
  }

  export type ProjectSkillUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<ProjectSkillCreateWithoutSkillInput, ProjectSkillUncheckedCreateWithoutSkillInput> | ProjectSkillCreateWithoutSkillInput[] | ProjectSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ProjectSkillCreateOrConnectWithoutSkillInput | ProjectSkillCreateOrConnectWithoutSkillInput[]
    upsert?: ProjectSkillUpsertWithWhereUniqueWithoutSkillInput | ProjectSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: ProjectSkillCreateManySkillInputEnvelope
    set?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    disconnect?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    delete?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    connect?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    update?: ProjectSkillUpdateWithWhereUniqueWithoutSkillInput | ProjectSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: ProjectSkillUpdateManyWithWhereWithoutSkillInput | ProjectSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: ProjectSkillScalarWhereInput | ProjectSkillScalarWhereInput[]
  }

  export type OpportunitySkillUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<OpportunitySkillCreateWithoutSkillInput, OpportunitySkillUncheckedCreateWithoutSkillInput> | OpportunitySkillCreateWithoutSkillInput[] | OpportunitySkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: OpportunitySkillCreateOrConnectWithoutSkillInput | OpportunitySkillCreateOrConnectWithoutSkillInput[]
    upsert?: OpportunitySkillUpsertWithWhereUniqueWithoutSkillInput | OpportunitySkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: OpportunitySkillCreateManySkillInputEnvelope
    set?: OpportunitySkillWhereUniqueInput | OpportunitySkillWhereUniqueInput[]
    disconnect?: OpportunitySkillWhereUniqueInput | OpportunitySkillWhereUniqueInput[]
    delete?: OpportunitySkillWhereUniqueInput | OpportunitySkillWhereUniqueInput[]
    connect?: OpportunitySkillWhereUniqueInput | OpportunitySkillWhereUniqueInput[]
    update?: OpportunitySkillUpdateWithWhereUniqueWithoutSkillInput | OpportunitySkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: OpportunitySkillUpdateManyWithWhereWithoutSkillInput | OpportunitySkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: OpportunitySkillScalarWhereInput | OpportunitySkillScalarWhereInput[]
  }

  export type CourseSkillUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<CourseSkillCreateWithoutSkillInput, CourseSkillUncheckedCreateWithoutSkillInput> | CourseSkillCreateWithoutSkillInput[] | CourseSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: CourseSkillCreateOrConnectWithoutSkillInput | CourseSkillCreateOrConnectWithoutSkillInput[]
    upsert?: CourseSkillUpsertWithWhereUniqueWithoutSkillInput | CourseSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: CourseSkillCreateManySkillInputEnvelope
    set?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    disconnect?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    delete?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    connect?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    update?: CourseSkillUpdateWithWhereUniqueWithoutSkillInput | CourseSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: CourseSkillUpdateManyWithWhereWithoutSkillInput | CourseSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: CourseSkillScalarWhereInput | CourseSkillScalarWhereInput[]
  }

  export type TrendingSkillUncheckedUpdateOneWithoutSkillNestedInput = {
    create?: XOR<TrendingSkillCreateWithoutSkillInput, TrendingSkillUncheckedCreateWithoutSkillInput>
    connectOrCreate?: TrendingSkillCreateOrConnectWithoutSkillInput
    upsert?: TrendingSkillUpsertWithoutSkillInput
    disconnect?: TrendingSkillWhereInput | boolean
    delete?: TrendingSkillWhereInput | boolean
    connect?: TrendingSkillWhereUniqueInput
    update?: XOR<XOR<TrendingSkillUpdateToOneWithWhereWithoutSkillInput, TrendingSkillUpdateWithoutSkillInput>, TrendingSkillUncheckedUpdateWithoutSkillInput>
  }

  export type SkillGapUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<SkillGapCreateWithoutSkillInput, SkillGapUncheckedCreateWithoutSkillInput> | SkillGapCreateWithoutSkillInput[] | SkillGapUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: SkillGapCreateOrConnectWithoutSkillInput | SkillGapCreateOrConnectWithoutSkillInput[]
    upsert?: SkillGapUpsertWithWhereUniqueWithoutSkillInput | SkillGapUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: SkillGapCreateManySkillInputEnvelope
    set?: SkillGapWhereUniqueInput | SkillGapWhereUniqueInput[]
    disconnect?: SkillGapWhereUniqueInput | SkillGapWhereUniqueInput[]
    delete?: SkillGapWhereUniqueInput | SkillGapWhereUniqueInput[]
    connect?: SkillGapWhereUniqueInput | SkillGapWhereUniqueInput[]
    update?: SkillGapUpdateWithWhereUniqueWithoutSkillInput | SkillGapUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: SkillGapUpdateManyWithWhereWithoutSkillInput | SkillGapUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: SkillGapScalarWhereInput | SkillGapScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserSkillsInput = {
    create?: XOR<UserCreateWithoutUserSkillsInput, UserUncheckedCreateWithoutUserSkillsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSkillsInput
    connect?: UserWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutUserSkillsInput = {
    create?: XOR<SkillCreateWithoutUserSkillsInput, SkillUncheckedCreateWithoutUserSkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutUserSkillsInput
    connect?: SkillWhereUniqueInput
  }

  export type EnumSkillLevelFieldUpdateOperationsInput = {
    set?: $Enums.SkillLevel
  }

  export type UserUpdateOneRequiredWithoutUserSkillsNestedInput = {
    create?: XOR<UserCreateWithoutUserSkillsInput, UserUncheckedCreateWithoutUserSkillsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSkillsInput
    upsert?: UserUpsertWithoutUserSkillsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserSkillsInput, UserUpdateWithoutUserSkillsInput>, UserUncheckedUpdateWithoutUserSkillsInput>
  }

  export type SkillUpdateOneRequiredWithoutUserSkillsNestedInput = {
    create?: XOR<SkillCreateWithoutUserSkillsInput, SkillUncheckedCreateWithoutUserSkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutUserSkillsInput
    upsert?: SkillUpsertWithoutUserSkillsInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutUserSkillsInput, SkillUpdateWithoutUserSkillsInput>, SkillUncheckedUpdateWithoutUserSkillsInput>
  }

  export type SkillCreateNestedOneWithoutTrendingDataInput = {
    create?: XOR<SkillCreateWithoutTrendingDataInput, SkillUncheckedCreateWithoutTrendingDataInput>
    connectOrCreate?: SkillCreateOrConnectWithoutTrendingDataInput
    connect?: SkillWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type SkillUpdateOneRequiredWithoutTrendingDataNestedInput = {
    create?: XOR<SkillCreateWithoutTrendingDataInput, SkillUncheckedCreateWithoutTrendingDataInput>
    connectOrCreate?: SkillCreateOrConnectWithoutTrendingDataInput
    upsert?: SkillUpsertWithoutTrendingDataInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutTrendingDataInput, SkillUpdateWithoutTrendingDataInput>, SkillUncheckedUpdateWithoutTrendingDataInput>
  }

  export type UserCreateNestedOneWithoutCredentialsInput = {
    create?: XOR<UserCreateWithoutCredentialsInput, UserUncheckedCreateWithoutCredentialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCredentialsInput
    connect?: UserWhereUniqueInput
  }

  export type CredentialSkillCreateNestedManyWithoutCredentialInput = {
    create?: XOR<CredentialSkillCreateWithoutCredentialInput, CredentialSkillUncheckedCreateWithoutCredentialInput> | CredentialSkillCreateWithoutCredentialInput[] | CredentialSkillUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: CredentialSkillCreateOrConnectWithoutCredentialInput | CredentialSkillCreateOrConnectWithoutCredentialInput[]
    createMany?: CredentialSkillCreateManyCredentialInputEnvelope
    connect?: CredentialSkillWhereUniqueInput | CredentialSkillWhereUniqueInput[]
  }

  export type VerificationRequestCreateNestedManyWithoutCredentialInput = {
    create?: XOR<VerificationRequestCreateWithoutCredentialInput, VerificationRequestUncheckedCreateWithoutCredentialInput> | VerificationRequestCreateWithoutCredentialInput[] | VerificationRequestUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: VerificationRequestCreateOrConnectWithoutCredentialInput | VerificationRequestCreateOrConnectWithoutCredentialInput[]
    createMany?: VerificationRequestCreateManyCredentialInputEnvelope
    connect?: VerificationRequestWhereUniqueInput | VerificationRequestWhereUniqueInput[]
  }

  export type CredentialSkillUncheckedCreateNestedManyWithoutCredentialInput = {
    create?: XOR<CredentialSkillCreateWithoutCredentialInput, CredentialSkillUncheckedCreateWithoutCredentialInput> | CredentialSkillCreateWithoutCredentialInput[] | CredentialSkillUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: CredentialSkillCreateOrConnectWithoutCredentialInput | CredentialSkillCreateOrConnectWithoutCredentialInput[]
    createMany?: CredentialSkillCreateManyCredentialInputEnvelope
    connect?: CredentialSkillWhereUniqueInput | CredentialSkillWhereUniqueInput[]
  }

  export type VerificationRequestUncheckedCreateNestedManyWithoutCredentialInput = {
    create?: XOR<VerificationRequestCreateWithoutCredentialInput, VerificationRequestUncheckedCreateWithoutCredentialInput> | VerificationRequestCreateWithoutCredentialInput[] | VerificationRequestUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: VerificationRequestCreateOrConnectWithoutCredentialInput | VerificationRequestCreateOrConnectWithoutCredentialInput[]
    createMany?: VerificationRequestCreateManyCredentialInputEnvelope
    connect?: VerificationRequestWhereUniqueInput | VerificationRequestWhereUniqueInput[]
  }

  export type EnumCredentialTypeFieldUpdateOperationsInput = {
    set?: $Enums.CredentialType
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutCredentialsNestedInput = {
    create?: XOR<UserCreateWithoutCredentialsInput, UserUncheckedCreateWithoutCredentialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCredentialsInput
    upsert?: UserUpsertWithoutCredentialsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCredentialsInput, UserUpdateWithoutCredentialsInput>, UserUncheckedUpdateWithoutCredentialsInput>
  }

  export type CredentialSkillUpdateManyWithoutCredentialNestedInput = {
    create?: XOR<CredentialSkillCreateWithoutCredentialInput, CredentialSkillUncheckedCreateWithoutCredentialInput> | CredentialSkillCreateWithoutCredentialInput[] | CredentialSkillUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: CredentialSkillCreateOrConnectWithoutCredentialInput | CredentialSkillCreateOrConnectWithoutCredentialInput[]
    upsert?: CredentialSkillUpsertWithWhereUniqueWithoutCredentialInput | CredentialSkillUpsertWithWhereUniqueWithoutCredentialInput[]
    createMany?: CredentialSkillCreateManyCredentialInputEnvelope
    set?: CredentialSkillWhereUniqueInput | CredentialSkillWhereUniqueInput[]
    disconnect?: CredentialSkillWhereUniqueInput | CredentialSkillWhereUniqueInput[]
    delete?: CredentialSkillWhereUniqueInput | CredentialSkillWhereUniqueInput[]
    connect?: CredentialSkillWhereUniqueInput | CredentialSkillWhereUniqueInput[]
    update?: CredentialSkillUpdateWithWhereUniqueWithoutCredentialInput | CredentialSkillUpdateWithWhereUniqueWithoutCredentialInput[]
    updateMany?: CredentialSkillUpdateManyWithWhereWithoutCredentialInput | CredentialSkillUpdateManyWithWhereWithoutCredentialInput[]
    deleteMany?: CredentialSkillScalarWhereInput | CredentialSkillScalarWhereInput[]
  }

  export type VerificationRequestUpdateManyWithoutCredentialNestedInput = {
    create?: XOR<VerificationRequestCreateWithoutCredentialInput, VerificationRequestUncheckedCreateWithoutCredentialInput> | VerificationRequestCreateWithoutCredentialInput[] | VerificationRequestUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: VerificationRequestCreateOrConnectWithoutCredentialInput | VerificationRequestCreateOrConnectWithoutCredentialInput[]
    upsert?: VerificationRequestUpsertWithWhereUniqueWithoutCredentialInput | VerificationRequestUpsertWithWhereUniqueWithoutCredentialInput[]
    createMany?: VerificationRequestCreateManyCredentialInputEnvelope
    set?: VerificationRequestWhereUniqueInput | VerificationRequestWhereUniqueInput[]
    disconnect?: VerificationRequestWhereUniqueInput | VerificationRequestWhereUniqueInput[]
    delete?: VerificationRequestWhereUniqueInput | VerificationRequestWhereUniqueInput[]
    connect?: VerificationRequestWhereUniqueInput | VerificationRequestWhereUniqueInput[]
    update?: VerificationRequestUpdateWithWhereUniqueWithoutCredentialInput | VerificationRequestUpdateWithWhereUniqueWithoutCredentialInput[]
    updateMany?: VerificationRequestUpdateManyWithWhereWithoutCredentialInput | VerificationRequestUpdateManyWithWhereWithoutCredentialInput[]
    deleteMany?: VerificationRequestScalarWhereInput | VerificationRequestScalarWhereInput[]
  }

  export type CredentialSkillUncheckedUpdateManyWithoutCredentialNestedInput = {
    create?: XOR<CredentialSkillCreateWithoutCredentialInput, CredentialSkillUncheckedCreateWithoutCredentialInput> | CredentialSkillCreateWithoutCredentialInput[] | CredentialSkillUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: CredentialSkillCreateOrConnectWithoutCredentialInput | CredentialSkillCreateOrConnectWithoutCredentialInput[]
    upsert?: CredentialSkillUpsertWithWhereUniqueWithoutCredentialInput | CredentialSkillUpsertWithWhereUniqueWithoutCredentialInput[]
    createMany?: CredentialSkillCreateManyCredentialInputEnvelope
    set?: CredentialSkillWhereUniqueInput | CredentialSkillWhereUniqueInput[]
    disconnect?: CredentialSkillWhereUniqueInput | CredentialSkillWhereUniqueInput[]
    delete?: CredentialSkillWhereUniqueInput | CredentialSkillWhereUniqueInput[]
    connect?: CredentialSkillWhereUniqueInput | CredentialSkillWhereUniqueInput[]
    update?: CredentialSkillUpdateWithWhereUniqueWithoutCredentialInput | CredentialSkillUpdateWithWhereUniqueWithoutCredentialInput[]
    updateMany?: CredentialSkillUpdateManyWithWhereWithoutCredentialInput | CredentialSkillUpdateManyWithWhereWithoutCredentialInput[]
    deleteMany?: CredentialSkillScalarWhereInput | CredentialSkillScalarWhereInput[]
  }

  export type VerificationRequestUncheckedUpdateManyWithoutCredentialNestedInput = {
    create?: XOR<VerificationRequestCreateWithoutCredentialInput, VerificationRequestUncheckedCreateWithoutCredentialInput> | VerificationRequestCreateWithoutCredentialInput[] | VerificationRequestUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: VerificationRequestCreateOrConnectWithoutCredentialInput | VerificationRequestCreateOrConnectWithoutCredentialInput[]
    upsert?: VerificationRequestUpsertWithWhereUniqueWithoutCredentialInput | VerificationRequestUpsertWithWhereUniqueWithoutCredentialInput[]
    createMany?: VerificationRequestCreateManyCredentialInputEnvelope
    set?: VerificationRequestWhereUniqueInput | VerificationRequestWhereUniqueInput[]
    disconnect?: VerificationRequestWhereUniqueInput | VerificationRequestWhereUniqueInput[]
    delete?: VerificationRequestWhereUniqueInput | VerificationRequestWhereUniqueInput[]
    connect?: VerificationRequestWhereUniqueInput | VerificationRequestWhereUniqueInput[]
    update?: VerificationRequestUpdateWithWhereUniqueWithoutCredentialInput | VerificationRequestUpdateWithWhereUniqueWithoutCredentialInput[]
    updateMany?: VerificationRequestUpdateManyWithWhereWithoutCredentialInput | VerificationRequestUpdateManyWithWhereWithoutCredentialInput[]
    deleteMany?: VerificationRequestScalarWhereInput | VerificationRequestScalarWhereInput[]
  }

  export type CredentialCreateNestedOneWithoutSkillsInput = {
    create?: XOR<CredentialCreateWithoutSkillsInput, CredentialUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: CredentialCreateOrConnectWithoutSkillsInput
    connect?: CredentialWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutCredentialSkillsInput = {
    create?: XOR<SkillCreateWithoutCredentialSkillsInput, SkillUncheckedCreateWithoutCredentialSkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutCredentialSkillsInput
    connect?: SkillWhereUniqueInput
  }

  export type CredentialUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<CredentialCreateWithoutSkillsInput, CredentialUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: CredentialCreateOrConnectWithoutSkillsInput
    upsert?: CredentialUpsertWithoutSkillsInput
    connect?: CredentialWhereUniqueInput
    update?: XOR<XOR<CredentialUpdateToOneWithWhereWithoutSkillsInput, CredentialUpdateWithoutSkillsInput>, CredentialUncheckedUpdateWithoutSkillsInput>
  }

  export type SkillUpdateOneRequiredWithoutCredentialSkillsNestedInput = {
    create?: XOR<SkillCreateWithoutCredentialSkillsInput, SkillUncheckedCreateWithoutCredentialSkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutCredentialSkillsInput
    upsert?: SkillUpsertWithoutCredentialSkillsInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutCredentialSkillsInput, SkillUpdateWithoutCredentialSkillsInput>, SkillUncheckedUpdateWithoutCredentialSkillsInput>
  }

  export type UserCreateNestedOneWithoutProjectsInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectMediaCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMediaCreateWithoutProjectInput, ProjectMediaUncheckedCreateWithoutProjectInput> | ProjectMediaCreateWithoutProjectInput[] | ProjectMediaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMediaCreateOrConnectWithoutProjectInput | ProjectMediaCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMediaCreateManyProjectInputEnvelope
    connect?: ProjectMediaWhereUniqueInput | ProjectMediaWhereUniqueInput[]
  }

  export type ProjectSkillCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectSkillCreateWithoutProjectInput, ProjectSkillUncheckedCreateWithoutProjectInput> | ProjectSkillCreateWithoutProjectInput[] | ProjectSkillUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectSkillCreateOrConnectWithoutProjectInput | ProjectSkillCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectSkillCreateManyProjectInputEnvelope
    connect?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
  }

  export type ProjectCollaboratorCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectCollaboratorCreateWithoutProjectInput, ProjectCollaboratorUncheckedCreateWithoutProjectInput> | ProjectCollaboratorCreateWithoutProjectInput[] | ProjectCollaboratorUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectCollaboratorCreateOrConnectWithoutProjectInput | ProjectCollaboratorCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectCollaboratorCreateManyProjectInputEnvelope
    connect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
  }

  export type EndorsementCreateNestedManyWithoutProjectInput = {
    create?: XOR<EndorsementCreateWithoutProjectInput, EndorsementUncheckedCreateWithoutProjectInput> | EndorsementCreateWithoutProjectInput[] | EndorsementUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EndorsementCreateOrConnectWithoutProjectInput | EndorsementCreateOrConnectWithoutProjectInput[]
    createMany?: EndorsementCreateManyProjectInputEnvelope
    connect?: EndorsementWhereUniqueInput | EndorsementWhereUniqueInput[]
  }

  export type ProjectMediaUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMediaCreateWithoutProjectInput, ProjectMediaUncheckedCreateWithoutProjectInput> | ProjectMediaCreateWithoutProjectInput[] | ProjectMediaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMediaCreateOrConnectWithoutProjectInput | ProjectMediaCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMediaCreateManyProjectInputEnvelope
    connect?: ProjectMediaWhereUniqueInput | ProjectMediaWhereUniqueInput[]
  }

  export type ProjectSkillUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectSkillCreateWithoutProjectInput, ProjectSkillUncheckedCreateWithoutProjectInput> | ProjectSkillCreateWithoutProjectInput[] | ProjectSkillUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectSkillCreateOrConnectWithoutProjectInput | ProjectSkillCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectSkillCreateManyProjectInputEnvelope
    connect?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
  }

  export type ProjectCollaboratorUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectCollaboratorCreateWithoutProjectInput, ProjectCollaboratorUncheckedCreateWithoutProjectInput> | ProjectCollaboratorCreateWithoutProjectInput[] | ProjectCollaboratorUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectCollaboratorCreateOrConnectWithoutProjectInput | ProjectCollaboratorCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectCollaboratorCreateManyProjectInputEnvelope
    connect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
  }

  export type EndorsementUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<EndorsementCreateWithoutProjectInput, EndorsementUncheckedCreateWithoutProjectInput> | EndorsementCreateWithoutProjectInput[] | EndorsementUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EndorsementCreateOrConnectWithoutProjectInput | EndorsementCreateOrConnectWithoutProjectInput[]
    createMany?: EndorsementCreateManyProjectInputEnvelope
    connect?: EndorsementWhereUniqueInput | EndorsementWhereUniqueInput[]
  }

  export type EnumProjectVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.ProjectVisibility
  }

  export type UserUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    upsert?: UserUpsertWithoutProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectsInput, UserUpdateWithoutProjectsInput>, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectMediaUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMediaCreateWithoutProjectInput, ProjectMediaUncheckedCreateWithoutProjectInput> | ProjectMediaCreateWithoutProjectInput[] | ProjectMediaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMediaCreateOrConnectWithoutProjectInput | ProjectMediaCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMediaUpsertWithWhereUniqueWithoutProjectInput | ProjectMediaUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMediaCreateManyProjectInputEnvelope
    set?: ProjectMediaWhereUniqueInput | ProjectMediaWhereUniqueInput[]
    disconnect?: ProjectMediaWhereUniqueInput | ProjectMediaWhereUniqueInput[]
    delete?: ProjectMediaWhereUniqueInput | ProjectMediaWhereUniqueInput[]
    connect?: ProjectMediaWhereUniqueInput | ProjectMediaWhereUniqueInput[]
    update?: ProjectMediaUpdateWithWhereUniqueWithoutProjectInput | ProjectMediaUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMediaUpdateManyWithWhereWithoutProjectInput | ProjectMediaUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMediaScalarWhereInput | ProjectMediaScalarWhereInput[]
  }

  export type ProjectSkillUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectSkillCreateWithoutProjectInput, ProjectSkillUncheckedCreateWithoutProjectInput> | ProjectSkillCreateWithoutProjectInput[] | ProjectSkillUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectSkillCreateOrConnectWithoutProjectInput | ProjectSkillCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectSkillUpsertWithWhereUniqueWithoutProjectInput | ProjectSkillUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectSkillCreateManyProjectInputEnvelope
    set?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    disconnect?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    delete?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    connect?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    update?: ProjectSkillUpdateWithWhereUniqueWithoutProjectInput | ProjectSkillUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectSkillUpdateManyWithWhereWithoutProjectInput | ProjectSkillUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectSkillScalarWhereInput | ProjectSkillScalarWhereInput[]
  }

  export type ProjectCollaboratorUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectCollaboratorCreateWithoutProjectInput, ProjectCollaboratorUncheckedCreateWithoutProjectInput> | ProjectCollaboratorCreateWithoutProjectInput[] | ProjectCollaboratorUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectCollaboratorCreateOrConnectWithoutProjectInput | ProjectCollaboratorCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectCollaboratorUpsertWithWhereUniqueWithoutProjectInput | ProjectCollaboratorUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectCollaboratorCreateManyProjectInputEnvelope
    set?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    disconnect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    delete?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    connect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    update?: ProjectCollaboratorUpdateWithWhereUniqueWithoutProjectInput | ProjectCollaboratorUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectCollaboratorUpdateManyWithWhereWithoutProjectInput | ProjectCollaboratorUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectCollaboratorScalarWhereInput | ProjectCollaboratorScalarWhereInput[]
  }

  export type EndorsementUpdateManyWithoutProjectNestedInput = {
    create?: XOR<EndorsementCreateWithoutProjectInput, EndorsementUncheckedCreateWithoutProjectInput> | EndorsementCreateWithoutProjectInput[] | EndorsementUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EndorsementCreateOrConnectWithoutProjectInput | EndorsementCreateOrConnectWithoutProjectInput[]
    upsert?: EndorsementUpsertWithWhereUniqueWithoutProjectInput | EndorsementUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: EndorsementCreateManyProjectInputEnvelope
    set?: EndorsementWhereUniqueInput | EndorsementWhereUniqueInput[]
    disconnect?: EndorsementWhereUniqueInput | EndorsementWhereUniqueInput[]
    delete?: EndorsementWhereUniqueInput | EndorsementWhereUniqueInput[]
    connect?: EndorsementWhereUniqueInput | EndorsementWhereUniqueInput[]
    update?: EndorsementUpdateWithWhereUniqueWithoutProjectInput | EndorsementUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: EndorsementUpdateManyWithWhereWithoutProjectInput | EndorsementUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: EndorsementScalarWhereInput | EndorsementScalarWhereInput[]
  }

  export type ProjectMediaUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMediaCreateWithoutProjectInput, ProjectMediaUncheckedCreateWithoutProjectInput> | ProjectMediaCreateWithoutProjectInput[] | ProjectMediaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMediaCreateOrConnectWithoutProjectInput | ProjectMediaCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMediaUpsertWithWhereUniqueWithoutProjectInput | ProjectMediaUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMediaCreateManyProjectInputEnvelope
    set?: ProjectMediaWhereUniqueInput | ProjectMediaWhereUniqueInput[]
    disconnect?: ProjectMediaWhereUniqueInput | ProjectMediaWhereUniqueInput[]
    delete?: ProjectMediaWhereUniqueInput | ProjectMediaWhereUniqueInput[]
    connect?: ProjectMediaWhereUniqueInput | ProjectMediaWhereUniqueInput[]
    update?: ProjectMediaUpdateWithWhereUniqueWithoutProjectInput | ProjectMediaUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMediaUpdateManyWithWhereWithoutProjectInput | ProjectMediaUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMediaScalarWhereInput | ProjectMediaScalarWhereInput[]
  }

  export type ProjectSkillUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectSkillCreateWithoutProjectInput, ProjectSkillUncheckedCreateWithoutProjectInput> | ProjectSkillCreateWithoutProjectInput[] | ProjectSkillUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectSkillCreateOrConnectWithoutProjectInput | ProjectSkillCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectSkillUpsertWithWhereUniqueWithoutProjectInput | ProjectSkillUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectSkillCreateManyProjectInputEnvelope
    set?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    disconnect?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    delete?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    connect?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    update?: ProjectSkillUpdateWithWhereUniqueWithoutProjectInput | ProjectSkillUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectSkillUpdateManyWithWhereWithoutProjectInput | ProjectSkillUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectSkillScalarWhereInput | ProjectSkillScalarWhereInput[]
  }

  export type ProjectCollaboratorUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectCollaboratorCreateWithoutProjectInput, ProjectCollaboratorUncheckedCreateWithoutProjectInput> | ProjectCollaboratorCreateWithoutProjectInput[] | ProjectCollaboratorUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectCollaboratorCreateOrConnectWithoutProjectInput | ProjectCollaboratorCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectCollaboratorUpsertWithWhereUniqueWithoutProjectInput | ProjectCollaboratorUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectCollaboratorCreateManyProjectInputEnvelope
    set?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    disconnect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    delete?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    connect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    update?: ProjectCollaboratorUpdateWithWhereUniqueWithoutProjectInput | ProjectCollaboratorUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectCollaboratorUpdateManyWithWhereWithoutProjectInput | ProjectCollaboratorUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectCollaboratorScalarWhereInput | ProjectCollaboratorScalarWhereInput[]
  }

  export type EndorsementUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<EndorsementCreateWithoutProjectInput, EndorsementUncheckedCreateWithoutProjectInput> | EndorsementCreateWithoutProjectInput[] | EndorsementUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EndorsementCreateOrConnectWithoutProjectInput | EndorsementCreateOrConnectWithoutProjectInput[]
    upsert?: EndorsementUpsertWithWhereUniqueWithoutProjectInput | EndorsementUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: EndorsementCreateManyProjectInputEnvelope
    set?: EndorsementWhereUniqueInput | EndorsementWhereUniqueInput[]
    disconnect?: EndorsementWhereUniqueInput | EndorsementWhereUniqueInput[]
    delete?: EndorsementWhereUniqueInput | EndorsementWhereUniqueInput[]
    connect?: EndorsementWhereUniqueInput | EndorsementWhereUniqueInput[]
    update?: EndorsementUpdateWithWhereUniqueWithoutProjectInput | EndorsementUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: EndorsementUpdateManyWithWhereWithoutProjectInput | EndorsementUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: EndorsementScalarWhereInput | EndorsementScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutMediaInput = {
    create?: XOR<ProjectCreateWithoutMediaInput, ProjectUncheckedCreateWithoutMediaInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMediaInput
    connect?: ProjectWhereUniqueInput
  }

  export type EnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType
  }

  export type ProjectUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<ProjectCreateWithoutMediaInput, ProjectUncheckedCreateWithoutMediaInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMediaInput
    upsert?: ProjectUpsertWithoutMediaInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMediaInput, ProjectUpdateWithoutMediaInput>, ProjectUncheckedUpdateWithoutMediaInput>
  }

  export type ProjectCreateNestedOneWithoutSkillsInput = {
    create?: XOR<ProjectCreateWithoutSkillsInput, ProjectUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSkillsInput
    connect?: ProjectWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutProjectSkillsInput = {
    create?: XOR<SkillCreateWithoutProjectSkillsInput, SkillUncheckedCreateWithoutProjectSkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutProjectSkillsInput
    connect?: SkillWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<ProjectCreateWithoutSkillsInput, ProjectUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSkillsInput
    upsert?: ProjectUpsertWithoutSkillsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSkillsInput, ProjectUpdateWithoutSkillsInput>, ProjectUncheckedUpdateWithoutSkillsInput>
  }

  export type SkillUpdateOneRequiredWithoutProjectSkillsNestedInput = {
    create?: XOR<SkillCreateWithoutProjectSkillsInput, SkillUncheckedCreateWithoutProjectSkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutProjectSkillsInput
    upsert?: SkillUpsertWithoutProjectSkillsInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutProjectSkillsInput, SkillUpdateWithoutProjectSkillsInput>, SkillUncheckedUpdateWithoutProjectSkillsInput>
  }

  export type ProjectCreateNestedOneWithoutCollaboratorsInput = {
    create?: XOR<ProjectCreateWithoutCollaboratorsInput, ProjectUncheckedCreateWithoutCollaboratorsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCollaboratorsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectCollaborationsInput = {
    create?: XOR<UserCreateWithoutProjectCollaborationsInput, UserUncheckedCreateWithoutProjectCollaborationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectCollaborationsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutCollaboratorsNestedInput = {
    create?: XOR<ProjectCreateWithoutCollaboratorsInput, ProjectUncheckedCreateWithoutCollaboratorsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCollaboratorsInput
    upsert?: ProjectUpsertWithoutCollaboratorsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutCollaboratorsInput, ProjectUpdateWithoutCollaboratorsInput>, ProjectUncheckedUpdateWithoutCollaboratorsInput>
  }

  export type UserUpdateOneRequiredWithoutProjectCollaborationsNestedInput = {
    create?: XOR<UserCreateWithoutProjectCollaborationsInput, UserUncheckedCreateWithoutProjectCollaborationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectCollaborationsInput
    upsert?: UserUpsertWithoutProjectCollaborationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectCollaborationsInput, UserUpdateWithoutProjectCollaborationsInput>, UserUncheckedUpdateWithoutProjectCollaborationsInput>
  }

  export type UserCreateNestedOneWithoutEndorsementsInput = {
    create?: XOR<UserCreateWithoutEndorsementsInput, UserUncheckedCreateWithoutEndorsementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEndorsementsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutEndorsementsInput = {
    create?: XOR<ProjectCreateWithoutEndorsementsInput, ProjectUncheckedCreateWithoutEndorsementsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutEndorsementsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEndorsementsNestedInput = {
    create?: XOR<UserCreateWithoutEndorsementsInput, UserUncheckedCreateWithoutEndorsementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEndorsementsInput
    upsert?: UserUpsertWithoutEndorsementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEndorsementsInput, UserUpdateWithoutEndorsementsInput>, UserUncheckedUpdateWithoutEndorsementsInput>
  }

  export type ProjectUpdateOneWithoutEndorsementsNestedInput = {
    create?: XOR<ProjectCreateWithoutEndorsementsInput, ProjectUncheckedCreateWithoutEndorsementsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutEndorsementsInput
    upsert?: ProjectUpsertWithoutEndorsementsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutEndorsementsInput, ProjectUpdateWithoutEndorsementsInput>, ProjectUncheckedUpdateWithoutEndorsementsInput>
  }

  export type OpportunityRequirementCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<OpportunityRequirementCreateWithoutOpportunityInput, OpportunityRequirementUncheckedCreateWithoutOpportunityInput> | OpportunityRequirementCreateWithoutOpportunityInput[] | OpportunityRequirementUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: OpportunityRequirementCreateOrConnectWithoutOpportunityInput | OpportunityRequirementCreateOrConnectWithoutOpportunityInput[]
    createMany?: OpportunityRequirementCreateManyOpportunityInputEnvelope
    connect?: OpportunityRequirementWhereUniqueInput | OpportunityRequirementWhereUniqueInput[]
  }

  export type OpportunitySkillCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<OpportunitySkillCreateWithoutOpportunityInput, OpportunitySkillUncheckedCreateWithoutOpportunityInput> | OpportunitySkillCreateWithoutOpportunityInput[] | OpportunitySkillUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: OpportunitySkillCreateOrConnectWithoutOpportunityInput | OpportunitySkillCreateOrConnectWithoutOpportunityInput[]
    createMany?: OpportunitySkillCreateManyOpportunityInputEnvelope
    connect?: OpportunitySkillWhereUniqueInput | OpportunitySkillWhereUniqueInput[]
  }

  export type ApplicationCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<ApplicationCreateWithoutOpportunityInput, ApplicationUncheckedCreateWithoutOpportunityInput> | ApplicationCreateWithoutOpportunityInput[] | ApplicationUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutOpportunityInput | ApplicationCreateOrConnectWithoutOpportunityInput[]
    createMany?: ApplicationCreateManyOpportunityInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type OpportunityRequirementUncheckedCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<OpportunityRequirementCreateWithoutOpportunityInput, OpportunityRequirementUncheckedCreateWithoutOpportunityInput> | OpportunityRequirementCreateWithoutOpportunityInput[] | OpportunityRequirementUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: OpportunityRequirementCreateOrConnectWithoutOpportunityInput | OpportunityRequirementCreateOrConnectWithoutOpportunityInput[]
    createMany?: OpportunityRequirementCreateManyOpportunityInputEnvelope
    connect?: OpportunityRequirementWhereUniqueInput | OpportunityRequirementWhereUniqueInput[]
  }

  export type OpportunitySkillUncheckedCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<OpportunitySkillCreateWithoutOpportunityInput, OpportunitySkillUncheckedCreateWithoutOpportunityInput> | OpportunitySkillCreateWithoutOpportunityInput[] | OpportunitySkillUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: OpportunitySkillCreateOrConnectWithoutOpportunityInput | OpportunitySkillCreateOrConnectWithoutOpportunityInput[]
    createMany?: OpportunitySkillCreateManyOpportunityInputEnvelope
    connect?: OpportunitySkillWhereUniqueInput | OpportunitySkillWhereUniqueInput[]
  }

  export type ApplicationUncheckedCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<ApplicationCreateWithoutOpportunityInput, ApplicationUncheckedCreateWithoutOpportunityInput> | ApplicationCreateWithoutOpportunityInput[] | ApplicationUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutOpportunityInput | ApplicationCreateOrConnectWithoutOpportunityInput[]
    createMany?: ApplicationCreateManyOpportunityInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type EnumOpportunityTypeFieldUpdateOperationsInput = {
    set?: $Enums.OpportunityType
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type OpportunityRequirementUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<OpportunityRequirementCreateWithoutOpportunityInput, OpportunityRequirementUncheckedCreateWithoutOpportunityInput> | OpportunityRequirementCreateWithoutOpportunityInput[] | OpportunityRequirementUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: OpportunityRequirementCreateOrConnectWithoutOpportunityInput | OpportunityRequirementCreateOrConnectWithoutOpportunityInput[]
    upsert?: OpportunityRequirementUpsertWithWhereUniqueWithoutOpportunityInput | OpportunityRequirementUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: OpportunityRequirementCreateManyOpportunityInputEnvelope
    set?: OpportunityRequirementWhereUniqueInput | OpportunityRequirementWhereUniqueInput[]
    disconnect?: OpportunityRequirementWhereUniqueInput | OpportunityRequirementWhereUniqueInput[]
    delete?: OpportunityRequirementWhereUniqueInput | OpportunityRequirementWhereUniqueInput[]
    connect?: OpportunityRequirementWhereUniqueInput | OpportunityRequirementWhereUniqueInput[]
    update?: OpportunityRequirementUpdateWithWhereUniqueWithoutOpportunityInput | OpportunityRequirementUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: OpportunityRequirementUpdateManyWithWhereWithoutOpportunityInput | OpportunityRequirementUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: OpportunityRequirementScalarWhereInput | OpportunityRequirementScalarWhereInput[]
  }

  export type OpportunitySkillUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<OpportunitySkillCreateWithoutOpportunityInput, OpportunitySkillUncheckedCreateWithoutOpportunityInput> | OpportunitySkillCreateWithoutOpportunityInput[] | OpportunitySkillUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: OpportunitySkillCreateOrConnectWithoutOpportunityInput | OpportunitySkillCreateOrConnectWithoutOpportunityInput[]
    upsert?: OpportunitySkillUpsertWithWhereUniqueWithoutOpportunityInput | OpportunitySkillUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: OpportunitySkillCreateManyOpportunityInputEnvelope
    set?: OpportunitySkillWhereUniqueInput | OpportunitySkillWhereUniqueInput[]
    disconnect?: OpportunitySkillWhereUniqueInput | OpportunitySkillWhereUniqueInput[]
    delete?: OpportunitySkillWhereUniqueInput | OpportunitySkillWhereUniqueInput[]
    connect?: OpportunitySkillWhereUniqueInput | OpportunitySkillWhereUniqueInput[]
    update?: OpportunitySkillUpdateWithWhereUniqueWithoutOpportunityInput | OpportunitySkillUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: OpportunitySkillUpdateManyWithWhereWithoutOpportunityInput | OpportunitySkillUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: OpportunitySkillScalarWhereInput | OpportunitySkillScalarWhereInput[]
  }

  export type ApplicationUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<ApplicationCreateWithoutOpportunityInput, ApplicationUncheckedCreateWithoutOpportunityInput> | ApplicationCreateWithoutOpportunityInput[] | ApplicationUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutOpportunityInput | ApplicationCreateOrConnectWithoutOpportunityInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutOpportunityInput | ApplicationUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: ApplicationCreateManyOpportunityInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutOpportunityInput | ApplicationUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutOpportunityInput | ApplicationUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type OpportunityRequirementUncheckedUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<OpportunityRequirementCreateWithoutOpportunityInput, OpportunityRequirementUncheckedCreateWithoutOpportunityInput> | OpportunityRequirementCreateWithoutOpportunityInput[] | OpportunityRequirementUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: OpportunityRequirementCreateOrConnectWithoutOpportunityInput | OpportunityRequirementCreateOrConnectWithoutOpportunityInput[]
    upsert?: OpportunityRequirementUpsertWithWhereUniqueWithoutOpportunityInput | OpportunityRequirementUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: OpportunityRequirementCreateManyOpportunityInputEnvelope
    set?: OpportunityRequirementWhereUniqueInput | OpportunityRequirementWhereUniqueInput[]
    disconnect?: OpportunityRequirementWhereUniqueInput | OpportunityRequirementWhereUniqueInput[]
    delete?: OpportunityRequirementWhereUniqueInput | OpportunityRequirementWhereUniqueInput[]
    connect?: OpportunityRequirementWhereUniqueInput | OpportunityRequirementWhereUniqueInput[]
    update?: OpportunityRequirementUpdateWithWhereUniqueWithoutOpportunityInput | OpportunityRequirementUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: OpportunityRequirementUpdateManyWithWhereWithoutOpportunityInput | OpportunityRequirementUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: OpportunityRequirementScalarWhereInput | OpportunityRequirementScalarWhereInput[]
  }

  export type OpportunitySkillUncheckedUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<OpportunitySkillCreateWithoutOpportunityInput, OpportunitySkillUncheckedCreateWithoutOpportunityInput> | OpportunitySkillCreateWithoutOpportunityInput[] | OpportunitySkillUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: OpportunitySkillCreateOrConnectWithoutOpportunityInput | OpportunitySkillCreateOrConnectWithoutOpportunityInput[]
    upsert?: OpportunitySkillUpsertWithWhereUniqueWithoutOpportunityInput | OpportunitySkillUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: OpportunitySkillCreateManyOpportunityInputEnvelope
    set?: OpportunitySkillWhereUniqueInput | OpportunitySkillWhereUniqueInput[]
    disconnect?: OpportunitySkillWhereUniqueInput | OpportunitySkillWhereUniqueInput[]
    delete?: OpportunitySkillWhereUniqueInput | OpportunitySkillWhereUniqueInput[]
    connect?: OpportunitySkillWhereUniqueInput | OpportunitySkillWhereUniqueInput[]
    update?: OpportunitySkillUpdateWithWhereUniqueWithoutOpportunityInput | OpportunitySkillUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: OpportunitySkillUpdateManyWithWhereWithoutOpportunityInput | OpportunitySkillUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: OpportunitySkillScalarWhereInput | OpportunitySkillScalarWhereInput[]
  }

  export type ApplicationUncheckedUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<ApplicationCreateWithoutOpportunityInput, ApplicationUncheckedCreateWithoutOpportunityInput> | ApplicationCreateWithoutOpportunityInput[] | ApplicationUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutOpportunityInput | ApplicationCreateOrConnectWithoutOpportunityInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutOpportunityInput | ApplicationUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: ApplicationCreateManyOpportunityInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutOpportunityInput | ApplicationUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutOpportunityInput | ApplicationUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type OpportunityCreateNestedOneWithoutRequirementsInput = {
    create?: XOR<OpportunityCreateWithoutRequirementsInput, OpportunityUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutRequirementsInput
    connect?: OpportunityWhereUniqueInput
  }

  export type OpportunityUpdateOneRequiredWithoutRequirementsNestedInput = {
    create?: XOR<OpportunityCreateWithoutRequirementsInput, OpportunityUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutRequirementsInput
    upsert?: OpportunityUpsertWithoutRequirementsInput
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutRequirementsInput, OpportunityUpdateWithoutRequirementsInput>, OpportunityUncheckedUpdateWithoutRequirementsInput>
  }

  export type OpportunityCreateNestedOneWithoutSkillsInput = {
    create?: XOR<OpportunityCreateWithoutSkillsInput, OpportunityUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutSkillsInput
    connect?: OpportunityWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutOpportunitySkillsInput = {
    create?: XOR<SkillCreateWithoutOpportunitySkillsInput, SkillUncheckedCreateWithoutOpportunitySkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutOpportunitySkillsInput
    connect?: SkillWhereUniqueInput
  }

  export type OpportunityUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<OpportunityCreateWithoutSkillsInput, OpportunityUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutSkillsInput
    upsert?: OpportunityUpsertWithoutSkillsInput
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutSkillsInput, OpportunityUpdateWithoutSkillsInput>, OpportunityUncheckedUpdateWithoutSkillsInput>
  }

  export type SkillUpdateOneRequiredWithoutOpportunitySkillsNestedInput = {
    create?: XOR<SkillCreateWithoutOpportunitySkillsInput, SkillUncheckedCreateWithoutOpportunitySkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutOpportunitySkillsInput
    upsert?: SkillUpsertWithoutOpportunitySkillsInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutOpportunitySkillsInput, SkillUpdateWithoutOpportunitySkillsInput>, SkillUncheckedUpdateWithoutOpportunitySkillsInput>
  }

  export type UserCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApplicationsInput
    connect?: UserWhereUniqueInput
  }

  export type OpportunityCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<OpportunityCreateWithoutApplicationsInput, OpportunityUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutApplicationsInput
    connect?: OpportunityWhereUniqueInput
  }

  export type EnumApplicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApplicationStatus
  }

  export type UserUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApplicationsInput
    upsert?: UserUpsertWithoutApplicationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApplicationsInput, UserUpdateWithoutApplicationsInput>, UserUncheckedUpdateWithoutApplicationsInput>
  }

  export type OpportunityUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<OpportunityCreateWithoutApplicationsInput, OpportunityUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutApplicationsInput
    upsert?: OpportunityUpsertWithoutApplicationsInput
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutApplicationsInput, OpportunityUpdateWithoutApplicationsInput>, OpportunityUncheckedUpdateWithoutApplicationsInput>
  }

  export type UserCreateNestedOneWithoutConnectionsSentInput = {
    create?: XOR<UserCreateWithoutConnectionsSentInput, UserUncheckedCreateWithoutConnectionsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutConnectionsSentInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConnectionsReceivedInput = {
    create?: XOR<UserCreateWithoutConnectionsReceivedInput, UserUncheckedCreateWithoutConnectionsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutConnectionsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type EnumConnectionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ConnectionType
  }

  export type UserUpdateOneRequiredWithoutConnectionsSentNestedInput = {
    create?: XOR<UserCreateWithoutConnectionsSentInput, UserUncheckedCreateWithoutConnectionsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutConnectionsSentInput
    upsert?: UserUpsertWithoutConnectionsSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConnectionsSentInput, UserUpdateWithoutConnectionsSentInput>, UserUncheckedUpdateWithoutConnectionsSentInput>
  }

  export type UserUpdateOneRequiredWithoutConnectionsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutConnectionsReceivedInput, UserUncheckedCreateWithoutConnectionsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutConnectionsReceivedInput
    upsert?: UserUpsertWithoutConnectionsReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConnectionsReceivedInput, UserUpdateWithoutConnectionsReceivedInput>, UserUncheckedUpdateWithoutConnectionsReceivedInput>
  }

  export type UserCreateNestedOneWithoutConnectionRequestsSentInput = {
    create?: XOR<UserCreateWithoutConnectionRequestsSentInput, UserUncheckedCreateWithoutConnectionRequestsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutConnectionRequestsSentInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConnectionRequestsReceivedInput = {
    create?: XOR<UserCreateWithoutConnectionRequestsReceivedInput, UserUncheckedCreateWithoutConnectionRequestsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutConnectionRequestsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type EnumConnectionStatusFieldUpdateOperationsInput = {
    set?: $Enums.ConnectionStatus
  }

  export type UserUpdateOneRequiredWithoutConnectionRequestsSentNestedInput = {
    create?: XOR<UserCreateWithoutConnectionRequestsSentInput, UserUncheckedCreateWithoutConnectionRequestsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutConnectionRequestsSentInput
    upsert?: UserUpsertWithoutConnectionRequestsSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConnectionRequestsSentInput, UserUpdateWithoutConnectionRequestsSentInput>, UserUncheckedUpdateWithoutConnectionRequestsSentInput>
  }

  export type UserUpdateOneRequiredWithoutConnectionRequestsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutConnectionRequestsReceivedInput, UserUncheckedCreateWithoutConnectionRequestsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutConnectionRequestsReceivedInput
    upsert?: UserUpsertWithoutConnectionRequestsReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConnectionRequestsReceivedInput, UserUpdateWithoutConnectionRequestsReceivedInput>, UserUncheckedUpdateWithoutConnectionRequestsReceivedInput>
  }

  export type UserCreateNestedOneWithoutFeedItemsInput = {
    create?: XOR<UserCreateWithoutFeedItemsInput, UserUncheckedCreateWithoutFeedItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedItemsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFeedItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.FeedItemType
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type UserUpdateOneRequiredWithoutFeedItemsNestedInput = {
    create?: XOR<UserCreateWithoutFeedItemsInput, UserUncheckedCreateWithoutFeedItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedItemsInput
    upsert?: UserUpsertWithoutFeedItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedItemsInput, UserUpdateWithoutFeedItemsInput>, UserUncheckedUpdateWithoutFeedItemsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutCareerPathsInput = {
    create?: XOR<UserCreateWithoutCareerPathsInput, UserUncheckedCreateWithoutCareerPathsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCareerPathsInput
    connect?: UserWhereUniqueInput
  }

  export type CareerPathNodeCreateNestedManyWithoutCareerPathInput = {
    create?: XOR<CareerPathNodeCreateWithoutCareerPathInput, CareerPathNodeUncheckedCreateWithoutCareerPathInput> | CareerPathNodeCreateWithoutCareerPathInput[] | CareerPathNodeUncheckedCreateWithoutCareerPathInput[]
    connectOrCreate?: CareerPathNodeCreateOrConnectWithoutCareerPathInput | CareerPathNodeCreateOrConnectWithoutCareerPathInput[]
    createMany?: CareerPathNodeCreateManyCareerPathInputEnvelope
    connect?: CareerPathNodeWhereUniqueInput | CareerPathNodeWhereUniqueInput[]
  }

  export type SkillGapCreateNestedManyWithoutCareerPathInput = {
    create?: XOR<SkillGapCreateWithoutCareerPathInput, SkillGapUncheckedCreateWithoutCareerPathInput> | SkillGapCreateWithoutCareerPathInput[] | SkillGapUncheckedCreateWithoutCareerPathInput[]
    connectOrCreate?: SkillGapCreateOrConnectWithoutCareerPathInput | SkillGapCreateOrConnectWithoutCareerPathInput[]
    createMany?: SkillGapCreateManyCareerPathInputEnvelope
    connect?: SkillGapWhereUniqueInput | SkillGapWhereUniqueInput[]
  }

  export type CareerPathNodeUncheckedCreateNestedManyWithoutCareerPathInput = {
    create?: XOR<CareerPathNodeCreateWithoutCareerPathInput, CareerPathNodeUncheckedCreateWithoutCareerPathInput> | CareerPathNodeCreateWithoutCareerPathInput[] | CareerPathNodeUncheckedCreateWithoutCareerPathInput[]
    connectOrCreate?: CareerPathNodeCreateOrConnectWithoutCareerPathInput | CareerPathNodeCreateOrConnectWithoutCareerPathInput[]
    createMany?: CareerPathNodeCreateManyCareerPathInputEnvelope
    connect?: CareerPathNodeWhereUniqueInput | CareerPathNodeWhereUniqueInput[]
  }

  export type SkillGapUncheckedCreateNestedManyWithoutCareerPathInput = {
    create?: XOR<SkillGapCreateWithoutCareerPathInput, SkillGapUncheckedCreateWithoutCareerPathInput> | SkillGapCreateWithoutCareerPathInput[] | SkillGapUncheckedCreateWithoutCareerPathInput[]
    connectOrCreate?: SkillGapCreateOrConnectWithoutCareerPathInput | SkillGapCreateOrConnectWithoutCareerPathInput[]
    createMany?: SkillGapCreateManyCareerPathInputEnvelope
    connect?: SkillGapWhereUniqueInput | SkillGapWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCareerPathsNestedInput = {
    create?: XOR<UserCreateWithoutCareerPathsInput, UserUncheckedCreateWithoutCareerPathsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCareerPathsInput
    upsert?: UserUpsertWithoutCareerPathsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCareerPathsInput, UserUpdateWithoutCareerPathsInput>, UserUncheckedUpdateWithoutCareerPathsInput>
  }

  export type CareerPathNodeUpdateManyWithoutCareerPathNestedInput = {
    create?: XOR<CareerPathNodeCreateWithoutCareerPathInput, CareerPathNodeUncheckedCreateWithoutCareerPathInput> | CareerPathNodeCreateWithoutCareerPathInput[] | CareerPathNodeUncheckedCreateWithoutCareerPathInput[]
    connectOrCreate?: CareerPathNodeCreateOrConnectWithoutCareerPathInput | CareerPathNodeCreateOrConnectWithoutCareerPathInput[]
    upsert?: CareerPathNodeUpsertWithWhereUniqueWithoutCareerPathInput | CareerPathNodeUpsertWithWhereUniqueWithoutCareerPathInput[]
    createMany?: CareerPathNodeCreateManyCareerPathInputEnvelope
    set?: CareerPathNodeWhereUniqueInput | CareerPathNodeWhereUniqueInput[]
    disconnect?: CareerPathNodeWhereUniqueInput | CareerPathNodeWhereUniqueInput[]
    delete?: CareerPathNodeWhereUniqueInput | CareerPathNodeWhereUniqueInput[]
    connect?: CareerPathNodeWhereUniqueInput | CareerPathNodeWhereUniqueInput[]
    update?: CareerPathNodeUpdateWithWhereUniqueWithoutCareerPathInput | CareerPathNodeUpdateWithWhereUniqueWithoutCareerPathInput[]
    updateMany?: CareerPathNodeUpdateManyWithWhereWithoutCareerPathInput | CareerPathNodeUpdateManyWithWhereWithoutCareerPathInput[]
    deleteMany?: CareerPathNodeScalarWhereInput | CareerPathNodeScalarWhereInput[]
  }

  export type SkillGapUpdateManyWithoutCareerPathNestedInput = {
    create?: XOR<SkillGapCreateWithoutCareerPathInput, SkillGapUncheckedCreateWithoutCareerPathInput> | SkillGapCreateWithoutCareerPathInput[] | SkillGapUncheckedCreateWithoutCareerPathInput[]
    connectOrCreate?: SkillGapCreateOrConnectWithoutCareerPathInput | SkillGapCreateOrConnectWithoutCareerPathInput[]
    upsert?: SkillGapUpsertWithWhereUniqueWithoutCareerPathInput | SkillGapUpsertWithWhereUniqueWithoutCareerPathInput[]
    createMany?: SkillGapCreateManyCareerPathInputEnvelope
    set?: SkillGapWhereUniqueInput | SkillGapWhereUniqueInput[]
    disconnect?: SkillGapWhereUniqueInput | SkillGapWhereUniqueInput[]
    delete?: SkillGapWhereUniqueInput | SkillGapWhereUniqueInput[]
    connect?: SkillGapWhereUniqueInput | SkillGapWhereUniqueInput[]
    update?: SkillGapUpdateWithWhereUniqueWithoutCareerPathInput | SkillGapUpdateWithWhereUniqueWithoutCareerPathInput[]
    updateMany?: SkillGapUpdateManyWithWhereWithoutCareerPathInput | SkillGapUpdateManyWithWhereWithoutCareerPathInput[]
    deleteMany?: SkillGapScalarWhereInput | SkillGapScalarWhereInput[]
  }

  export type CareerPathNodeUncheckedUpdateManyWithoutCareerPathNestedInput = {
    create?: XOR<CareerPathNodeCreateWithoutCareerPathInput, CareerPathNodeUncheckedCreateWithoutCareerPathInput> | CareerPathNodeCreateWithoutCareerPathInput[] | CareerPathNodeUncheckedCreateWithoutCareerPathInput[]
    connectOrCreate?: CareerPathNodeCreateOrConnectWithoutCareerPathInput | CareerPathNodeCreateOrConnectWithoutCareerPathInput[]
    upsert?: CareerPathNodeUpsertWithWhereUniqueWithoutCareerPathInput | CareerPathNodeUpsertWithWhereUniqueWithoutCareerPathInput[]
    createMany?: CareerPathNodeCreateManyCareerPathInputEnvelope
    set?: CareerPathNodeWhereUniqueInput | CareerPathNodeWhereUniqueInput[]
    disconnect?: CareerPathNodeWhereUniqueInput | CareerPathNodeWhereUniqueInput[]
    delete?: CareerPathNodeWhereUniqueInput | CareerPathNodeWhereUniqueInput[]
    connect?: CareerPathNodeWhereUniqueInput | CareerPathNodeWhereUniqueInput[]
    update?: CareerPathNodeUpdateWithWhereUniqueWithoutCareerPathInput | CareerPathNodeUpdateWithWhereUniqueWithoutCareerPathInput[]
    updateMany?: CareerPathNodeUpdateManyWithWhereWithoutCareerPathInput | CareerPathNodeUpdateManyWithWhereWithoutCareerPathInput[]
    deleteMany?: CareerPathNodeScalarWhereInput | CareerPathNodeScalarWhereInput[]
  }

  export type SkillGapUncheckedUpdateManyWithoutCareerPathNestedInput = {
    create?: XOR<SkillGapCreateWithoutCareerPathInput, SkillGapUncheckedCreateWithoutCareerPathInput> | SkillGapCreateWithoutCareerPathInput[] | SkillGapUncheckedCreateWithoutCareerPathInput[]
    connectOrCreate?: SkillGapCreateOrConnectWithoutCareerPathInput | SkillGapCreateOrConnectWithoutCareerPathInput[]
    upsert?: SkillGapUpsertWithWhereUniqueWithoutCareerPathInput | SkillGapUpsertWithWhereUniqueWithoutCareerPathInput[]
    createMany?: SkillGapCreateManyCareerPathInputEnvelope
    set?: SkillGapWhereUniqueInput | SkillGapWhereUniqueInput[]
    disconnect?: SkillGapWhereUniqueInput | SkillGapWhereUniqueInput[]
    delete?: SkillGapWhereUniqueInput | SkillGapWhereUniqueInput[]
    connect?: SkillGapWhereUniqueInput | SkillGapWhereUniqueInput[]
    update?: SkillGapUpdateWithWhereUniqueWithoutCareerPathInput | SkillGapUpdateWithWhereUniqueWithoutCareerPathInput[]
    updateMany?: SkillGapUpdateManyWithWhereWithoutCareerPathInput | SkillGapUpdateManyWithWhereWithoutCareerPathInput[]
    deleteMany?: SkillGapScalarWhereInput | SkillGapScalarWhereInput[]
  }

  export type CareerPathCreateNestedOneWithoutNodesInput = {
    create?: XOR<CareerPathCreateWithoutNodesInput, CareerPathUncheckedCreateWithoutNodesInput>
    connectOrCreate?: CareerPathCreateOrConnectWithoutNodesInput
    connect?: CareerPathWhereUniqueInput
  }

  export type CareerPathUpdateOneRequiredWithoutNodesNestedInput = {
    create?: XOR<CareerPathCreateWithoutNodesInput, CareerPathUncheckedCreateWithoutNodesInput>
    connectOrCreate?: CareerPathCreateOrConnectWithoutNodesInput
    upsert?: CareerPathUpsertWithoutNodesInput
    connect?: CareerPathWhereUniqueInput
    update?: XOR<XOR<CareerPathUpdateToOneWithWhereWithoutNodesInput, CareerPathUpdateWithoutNodesInput>, CareerPathUncheckedUpdateWithoutNodesInput>
  }

  export type CareerPathCreateNestedOneWithoutSkillGapsInput = {
    create?: XOR<CareerPathCreateWithoutSkillGapsInput, CareerPathUncheckedCreateWithoutSkillGapsInput>
    connectOrCreate?: CareerPathCreateOrConnectWithoutSkillGapsInput
    connect?: CareerPathWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutSkillGapsInput = {
    create?: XOR<SkillCreateWithoutSkillGapsInput, SkillUncheckedCreateWithoutSkillGapsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutSkillGapsInput
    connect?: SkillWhereUniqueInput
  }

  export type CareerPathUpdateOneRequiredWithoutSkillGapsNestedInput = {
    create?: XOR<CareerPathCreateWithoutSkillGapsInput, CareerPathUncheckedCreateWithoutSkillGapsInput>
    connectOrCreate?: CareerPathCreateOrConnectWithoutSkillGapsInput
    upsert?: CareerPathUpsertWithoutSkillGapsInput
    connect?: CareerPathWhereUniqueInput
    update?: XOR<XOR<CareerPathUpdateToOneWithWhereWithoutSkillGapsInput, CareerPathUpdateWithoutSkillGapsInput>, CareerPathUncheckedUpdateWithoutSkillGapsInput>
  }

  export type SkillUpdateOneRequiredWithoutSkillGapsNestedInput = {
    create?: XOR<SkillCreateWithoutSkillGapsInput, SkillUncheckedCreateWithoutSkillGapsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutSkillGapsInput
    upsert?: SkillUpsertWithoutSkillGapsInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutSkillGapsInput, SkillUpdateWithoutSkillGapsInput>, SkillUncheckedUpdateWithoutSkillGapsInput>
  }

  export type CourseSkillCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseSkillCreateWithoutCourseInput, CourseSkillUncheckedCreateWithoutCourseInput> | CourseSkillCreateWithoutCourseInput[] | CourseSkillUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseSkillCreateOrConnectWithoutCourseInput | CourseSkillCreateOrConnectWithoutCourseInput[]
    createMany?: CourseSkillCreateManyCourseInputEnvelope
    connect?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
  }

  export type CourseSkillUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseSkillCreateWithoutCourseInput, CourseSkillUncheckedCreateWithoutCourseInput> | CourseSkillCreateWithoutCourseInput[] | CourseSkillUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseSkillCreateOrConnectWithoutCourseInput | CourseSkillCreateOrConnectWithoutCourseInput[]
    createMany?: CourseSkillCreateManyCourseInputEnvelope
    connect?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
  }

  export type CourseSkillUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseSkillCreateWithoutCourseInput, CourseSkillUncheckedCreateWithoutCourseInput> | CourseSkillCreateWithoutCourseInput[] | CourseSkillUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseSkillCreateOrConnectWithoutCourseInput | CourseSkillCreateOrConnectWithoutCourseInput[]
    upsert?: CourseSkillUpsertWithWhereUniqueWithoutCourseInput | CourseSkillUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseSkillCreateManyCourseInputEnvelope
    set?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    disconnect?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    delete?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    connect?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    update?: CourseSkillUpdateWithWhereUniqueWithoutCourseInput | CourseSkillUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseSkillUpdateManyWithWhereWithoutCourseInput | CourseSkillUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseSkillScalarWhereInput | CourseSkillScalarWhereInput[]
  }

  export type CourseSkillUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseSkillCreateWithoutCourseInput, CourseSkillUncheckedCreateWithoutCourseInput> | CourseSkillCreateWithoutCourseInput[] | CourseSkillUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseSkillCreateOrConnectWithoutCourseInput | CourseSkillCreateOrConnectWithoutCourseInput[]
    upsert?: CourseSkillUpsertWithWhereUniqueWithoutCourseInput | CourseSkillUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseSkillCreateManyCourseInputEnvelope
    set?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    disconnect?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    delete?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    connect?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    update?: CourseSkillUpdateWithWhereUniqueWithoutCourseInput | CourseSkillUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseSkillUpdateManyWithWhereWithoutCourseInput | CourseSkillUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseSkillScalarWhereInput | CourseSkillScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutSkillsInput = {
    create?: XOR<CourseCreateWithoutSkillsInput, CourseUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutSkillsInput
    connect?: CourseWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutCourseSkillsInput = {
    create?: XOR<SkillCreateWithoutCourseSkillsInput, SkillUncheckedCreateWithoutCourseSkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutCourseSkillsInput
    connect?: SkillWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<CourseCreateWithoutSkillsInput, CourseUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutSkillsInput
    upsert?: CourseUpsertWithoutSkillsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutSkillsInput, CourseUpdateWithoutSkillsInput>, CourseUncheckedUpdateWithoutSkillsInput>
  }

  export type SkillUpdateOneRequiredWithoutCourseSkillsNestedInput = {
    create?: XOR<SkillCreateWithoutCourseSkillsInput, SkillUncheckedCreateWithoutCourseSkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutCourseSkillsInput
    upsert?: SkillUpsertWithoutCourseSkillsInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutCourseSkillsInput, SkillUpdateWithoutCourseSkillsInput>, SkillUncheckedUpdateWithoutCourseSkillsInput>
  }

  export type CredentialCreateNestedOneWithoutVerificationRequestsInput = {
    create?: XOR<CredentialCreateWithoutVerificationRequestsInput, CredentialUncheckedCreateWithoutVerificationRequestsInput>
    connectOrCreate?: CredentialCreateOrConnectWithoutVerificationRequestsInput
    connect?: CredentialWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVerificationRequestsInput = {
    create?: XOR<UserCreateWithoutVerificationRequestsInput, UserUncheckedCreateWithoutVerificationRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerificationRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type CredentialUpdateOneRequiredWithoutVerificationRequestsNestedInput = {
    create?: XOR<CredentialCreateWithoutVerificationRequestsInput, CredentialUncheckedCreateWithoutVerificationRequestsInput>
    connectOrCreate?: CredentialCreateOrConnectWithoutVerificationRequestsInput
    upsert?: CredentialUpsertWithoutVerificationRequestsInput
    connect?: CredentialWhereUniqueInput
    update?: XOR<XOR<CredentialUpdateToOneWithWhereWithoutVerificationRequestsInput, CredentialUpdateWithoutVerificationRequestsInput>, CredentialUncheckedUpdateWithoutVerificationRequestsInput>
  }

  export type UserUpdateOneRequiredWithoutVerificationRequestsNestedInput = {
    create?: XOR<UserCreateWithoutVerificationRequestsInput, UserUncheckedCreateWithoutVerificationRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerificationRequestsInput
    upsert?: UserUpsertWithoutVerificationRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVerificationRequestsInput, UserUpdateWithoutVerificationRequestsInput>, UserUncheckedUpdateWithoutVerificationRequestsInput>
  }

  export type UserCreateNestedOneWithoutMessagesSentInput = {
    create?: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesSentInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesReceivedInput = {
    create?: XOR<UserCreateWithoutMessagesReceivedInput, UserUncheckedCreateWithoutMessagesReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMessagesSentNestedInput = {
    create?: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesSentInput
    upsert?: UserUpsertWithoutMessagesSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesSentInput, UserUpdateWithoutMessagesSentInput>, UserUncheckedUpdateWithoutMessagesSentInput>
  }

  export type UserUpdateOneRequiredWithoutMessagesReceivedNestedInput = {
    create?: XOR<UserCreateWithoutMessagesReceivedInput, UserUncheckedCreateWithoutMessagesReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesReceivedInput
    upsert?: UserUpsertWithoutMessagesReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesReceivedInput, UserUpdateWithoutMessagesReceivedInput>, UserUncheckedUpdateWithoutMessagesReceivedInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumSkillCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillCategory | EnumSkillCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SkillCategory[] | ListEnumSkillCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillCategory[] | ListEnumSkillCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillCategoryFilter<$PrismaModel> | $Enums.SkillCategory
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumSkillCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillCategory | EnumSkillCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SkillCategory[] | ListEnumSkillCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillCategory[] | ListEnumSkillCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillCategoryWithAggregatesFilter<$PrismaModel> | $Enums.SkillCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSkillCategoryFilter<$PrismaModel>
    _max?: NestedEnumSkillCategoryFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumSkillLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillLevel | EnumSkillLevelFieldRefInput<$PrismaModel>
    in?: $Enums.SkillLevel[] | ListEnumSkillLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillLevel[] | ListEnumSkillLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillLevelFilter<$PrismaModel> | $Enums.SkillLevel
  }

  export type NestedEnumSkillLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillLevel | EnumSkillLevelFieldRefInput<$PrismaModel>
    in?: $Enums.SkillLevel[] | ListEnumSkillLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillLevel[] | ListEnumSkillLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillLevelWithAggregatesFilter<$PrismaModel> | $Enums.SkillLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSkillLevelFilter<$PrismaModel>
    _max?: NestedEnumSkillLevelFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumCredentialTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CredentialType | EnumCredentialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CredentialType[] | ListEnumCredentialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CredentialType[] | ListEnumCredentialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCredentialTypeFilter<$PrismaModel> | $Enums.CredentialType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumCredentialTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CredentialType | EnumCredentialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CredentialType[] | ListEnumCredentialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CredentialType[] | ListEnumCredentialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCredentialTypeWithAggregatesFilter<$PrismaModel> | $Enums.CredentialType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCredentialTypeFilter<$PrismaModel>
    _max?: NestedEnumCredentialTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumProjectVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectVisibility | EnumProjectVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectVisibility[] | ListEnumProjectVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectVisibility[] | ListEnumProjectVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectVisibilityFilter<$PrismaModel> | $Enums.ProjectVisibility
  }

  export type NestedEnumProjectVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectVisibility | EnumProjectVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectVisibility[] | ListEnumProjectVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectVisibility[] | ListEnumProjectVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.ProjectVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectVisibilityFilter<$PrismaModel>
    _max?: NestedEnumProjectVisibilityFilter<$PrismaModel>
  }

  export type NestedEnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type NestedEnumOpportunityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityType | EnumOpportunityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityType[] | ListEnumOpportunityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityType[] | ListEnumOpportunityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityTypeFilter<$PrismaModel> | $Enums.OpportunityType
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedEnumOpportunityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityType | EnumOpportunityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityType[] | ListEnumOpportunityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityType[] | ListEnumOpportunityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityTypeWithAggregatesFilter<$PrismaModel> | $Enums.OpportunityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOpportunityTypeFilter<$PrismaModel>
    _max?: NestedEnumOpportunityTypeFilter<$PrismaModel>
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type NestedEnumConnectionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConnectionType | EnumConnectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConnectionType[] | ListEnumConnectionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConnectionType[] | ListEnumConnectionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConnectionTypeFilter<$PrismaModel> | $Enums.ConnectionType
  }

  export type NestedEnumConnectionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConnectionType | EnumConnectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConnectionType[] | ListEnumConnectionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConnectionType[] | ListEnumConnectionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConnectionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ConnectionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConnectionTypeFilter<$PrismaModel>
    _max?: NestedEnumConnectionTypeFilter<$PrismaModel>
  }

  export type NestedEnumConnectionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConnectionStatus | EnumConnectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConnectionStatus[] | ListEnumConnectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConnectionStatus[] | ListEnumConnectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConnectionStatusFilter<$PrismaModel> | $Enums.ConnectionStatus
  }

  export type NestedEnumConnectionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConnectionStatus | EnumConnectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConnectionStatus[] | ListEnumConnectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConnectionStatus[] | ListEnumConnectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConnectionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConnectionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConnectionStatusFilter<$PrismaModel>
    _max?: NestedEnumConnectionStatusFilter<$PrismaModel>
  }

  export type NestedEnumFeedItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedItemType | EnumFeedItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedItemType[] | ListEnumFeedItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedItemType[] | ListEnumFeedItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedItemTypeFilter<$PrismaModel> | $Enums.FeedItemType
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedEnumFeedItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedItemType | EnumFeedItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedItemType[] | ListEnumFeedItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedItemType[] | ListEnumFeedItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeedItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedItemTypeFilter<$PrismaModel>
    _max?: NestedEnumFeedItemTypeFilter<$PrismaModel>
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type LearnerProfileCreateWithoutUserInput = {
    bio?: string | null
    location?: string | null
    university?: string | null
    major?: string | null
    graduationYear?: number | null
    skillsMatchPercentage?: number
    verificationStatus?: $Enums.VerificationStatus
  }

  export type LearnerProfileUncheckedCreateWithoutUserInput = {
    bio?: string | null
    location?: string | null
    university?: string | null
    major?: string | null
    graduationYear?: number | null
    skillsMatchPercentage?: number
    verificationStatus?: $Enums.VerificationStatus
  }

  export type LearnerProfileCreateOrConnectWithoutUserInput = {
    where: LearnerProfileWhereUniqueInput
    create: XOR<LearnerProfileCreateWithoutUserInput, LearnerProfileUncheckedCreateWithoutUserInput>
  }

  export type UserSkillCreateWithoutUserInput = {
    id?: string
    level: $Enums.SkillLevel
    endorsements?: number
    verified?: boolean
    addedAt?: Date | string
    skill: SkillCreateNestedOneWithoutUserSkillsInput
  }

  export type UserSkillUncheckedCreateWithoutUserInput = {
    id?: string
    skillId: string
    level: $Enums.SkillLevel
    endorsements?: number
    verified?: boolean
    addedAt?: Date | string
  }

  export type UserSkillCreateOrConnectWithoutUserInput = {
    where: UserSkillWhereUniqueInput
    create: XOR<UserSkillCreateWithoutUserInput, UserSkillUncheckedCreateWithoutUserInput>
  }

  export type UserSkillCreateManyUserInputEnvelope = {
    data: UserSkillCreateManyUserInput | UserSkillCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CredentialCreateWithoutUserInput = {
    id?: string
    title: string
    issuer: string
    type: $Enums.CredentialType
    issueDate: Date | string
    expiryDate?: Date | string | null
    verified?: boolean
    blockchainHash?: string | null
    qrCode?: string | null
    createdAt?: Date | string
    skills?: CredentialSkillCreateNestedManyWithoutCredentialInput
    verificationRequests?: VerificationRequestCreateNestedManyWithoutCredentialInput
  }

  export type CredentialUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    issuer: string
    type: $Enums.CredentialType
    issueDate: Date | string
    expiryDate?: Date | string | null
    verified?: boolean
    blockchainHash?: string | null
    qrCode?: string | null
    createdAt?: Date | string
    skills?: CredentialSkillUncheckedCreateNestedManyWithoutCredentialInput
    verificationRequests?: VerificationRequestUncheckedCreateNestedManyWithoutCredentialInput
  }

  export type CredentialCreateOrConnectWithoutUserInput = {
    where: CredentialWhereUniqueInput
    create: XOR<CredentialCreateWithoutUserInput, CredentialUncheckedCreateWithoutUserInput>
  }

  export type CredentialCreateManyUserInputEnvelope = {
    data: CredentialCreateManyUserInput | CredentialCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutUserInput = {
    id?: string
    title: string
    description: string
    visibility: $Enums.ProjectVisibility
    verified?: boolean
    githubUrl?: string | null
    liveUrl?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: ProjectMediaCreateNestedManyWithoutProjectInput
    skills?: ProjectSkillCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorCreateNestedManyWithoutProjectInput
    endorsements?: EndorsementCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description: string
    visibility: $Enums.ProjectVisibility
    verified?: boolean
    githubUrl?: string | null
    liveUrl?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: ProjectMediaUncheckedCreateNestedManyWithoutProjectInput
    skills?: ProjectSkillUncheckedCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorUncheckedCreateNestedManyWithoutProjectInput
    endorsements?: EndorsementUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutUserInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput>
  }

  export type ProjectCreateManyUserInputEnvelope = {
    data: ProjectCreateManyUserInput | ProjectCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ApplicationCreateWithoutUserInput = {
    id?: string
    status: $Enums.ApplicationStatus
    coverLetter?: string | null
    resumeUrl?: string | null
    appliedAt?: Date | string
    updatedAt?: Date | string
    opportunity: OpportunityCreateNestedOneWithoutApplicationsInput
  }

  export type ApplicationUncheckedCreateWithoutUserInput = {
    id?: string
    opportunityId: string
    status: $Enums.ApplicationStatus
    coverLetter?: string | null
    resumeUrl?: string | null
    appliedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApplicationCreateOrConnectWithoutUserInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutUserInput, ApplicationUncheckedCreateWithoutUserInput>
  }

  export type ApplicationCreateManyUserInputEnvelope = {
    data: ApplicationCreateManyUserInput | ApplicationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConnectionCreateWithoutUserInput = {
    id?: string
    type: $Enums.ConnectionType
    mutualConnections?: number
    connectedAt?: Date | string
    connectedUser: UserCreateNestedOneWithoutConnectionsReceivedInput
  }

  export type ConnectionUncheckedCreateWithoutUserInput = {
    id?: string
    connectedUserId: string
    type: $Enums.ConnectionType
    mutualConnections?: number
    connectedAt?: Date | string
  }

  export type ConnectionCreateOrConnectWithoutUserInput = {
    where: ConnectionWhereUniqueInput
    create: XOR<ConnectionCreateWithoutUserInput, ConnectionUncheckedCreateWithoutUserInput>
  }

  export type ConnectionCreateManyUserInputEnvelope = {
    data: ConnectionCreateManyUserInput | ConnectionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConnectionCreateWithoutConnectedUserInput = {
    id?: string
    type: $Enums.ConnectionType
    mutualConnections?: number
    connectedAt?: Date | string
    user: UserCreateNestedOneWithoutConnectionsSentInput
  }

  export type ConnectionUncheckedCreateWithoutConnectedUserInput = {
    id?: string
    userId: string
    type: $Enums.ConnectionType
    mutualConnections?: number
    connectedAt?: Date | string
  }

  export type ConnectionCreateOrConnectWithoutConnectedUserInput = {
    where: ConnectionWhereUniqueInput
    create: XOR<ConnectionCreateWithoutConnectedUserInput, ConnectionUncheckedCreateWithoutConnectedUserInput>
  }

  export type ConnectionCreateManyConnectedUserInputEnvelope = {
    data: ConnectionCreateManyConnectedUserInput | ConnectionCreateManyConnectedUserInput[]
    skipDuplicates?: boolean
  }

  export type ConnectionRequestCreateWithoutSenderInput = {
    id?: string
    message?: string | null
    status: $Enums.ConnectionStatus
    requestedAt?: Date | string
    respondedAt?: Date | string | null
    receiver: UserCreateNestedOneWithoutConnectionRequestsReceivedInput
  }

  export type ConnectionRequestUncheckedCreateWithoutSenderInput = {
    id?: string
    receiverId: string
    message?: string | null
    status: $Enums.ConnectionStatus
    requestedAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type ConnectionRequestCreateOrConnectWithoutSenderInput = {
    where: ConnectionRequestWhereUniqueInput
    create: XOR<ConnectionRequestCreateWithoutSenderInput, ConnectionRequestUncheckedCreateWithoutSenderInput>
  }

  export type ConnectionRequestCreateManySenderInputEnvelope = {
    data: ConnectionRequestCreateManySenderInput | ConnectionRequestCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type ConnectionRequestCreateWithoutReceiverInput = {
    id?: string
    message?: string | null
    status: $Enums.ConnectionStatus
    requestedAt?: Date | string
    respondedAt?: Date | string | null
    sender: UserCreateNestedOneWithoutConnectionRequestsSentInput
  }

  export type ConnectionRequestUncheckedCreateWithoutReceiverInput = {
    id?: string
    senderId: string
    message?: string | null
    status: $Enums.ConnectionStatus
    requestedAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type ConnectionRequestCreateOrConnectWithoutReceiverInput = {
    where: ConnectionRequestWhereUniqueInput
    create: XOR<ConnectionRequestCreateWithoutReceiverInput, ConnectionRequestUncheckedCreateWithoutReceiverInput>
  }

  export type ConnectionRequestCreateManyReceiverInputEnvelope = {
    data: ConnectionRequestCreateManyReceiverInput | ConnectionRequestCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type FeedItemCreateWithoutUserInput = {
    id?: string
    type: $Enums.FeedItemType
    priority: $Enums.Priority
    title: string
    description: string
    image?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type FeedItemUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.FeedItemType
    priority: $Enums.Priority
    title: string
    description: string
    image?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type FeedItemCreateOrConnectWithoutUserInput = {
    where: FeedItemWhereUniqueInput
    create: XOR<FeedItemCreateWithoutUserInput, FeedItemUncheckedCreateWithoutUserInput>
  }

  export type FeedItemCreateManyUserInputEnvelope = {
    data: FeedItemCreateManyUserInput | FeedItemCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionUrl?: string | null
    icon?: string | null
    timestamp?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionUrl?: string | null
    icon?: string | null
    timestamp?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CareerPathCreateWithoutUserInput = {
    id?: string
    currentRole: string
    targetRole: string
    estimatedDuration: number
    createdAt?: Date | string
    nodes?: CareerPathNodeCreateNestedManyWithoutCareerPathInput
    skillGaps?: SkillGapCreateNestedManyWithoutCareerPathInput
  }

  export type CareerPathUncheckedCreateWithoutUserInput = {
    id?: string
    currentRole: string
    targetRole: string
    estimatedDuration: number
    createdAt?: Date | string
    nodes?: CareerPathNodeUncheckedCreateNestedManyWithoutCareerPathInput
    skillGaps?: SkillGapUncheckedCreateNestedManyWithoutCareerPathInput
  }

  export type CareerPathCreateOrConnectWithoutUserInput = {
    where: CareerPathWhereUniqueInput
    create: XOR<CareerPathCreateWithoutUserInput, CareerPathUncheckedCreateWithoutUserInput>
  }

  export type CareerPathCreateManyUserInputEnvelope = {
    data: CareerPathCreateManyUserInput | CareerPathCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content: string
    read?: boolean
    sentAt?: Date | string
    receiver: UserCreateNestedOneWithoutMessagesReceivedInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    receiverId: string
    content: string
    read?: boolean
    sentAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutReceiverInput = {
    id?: string
    content: string
    read?: boolean
    sentAt?: Date | string
    sender: UserCreateNestedOneWithoutMessagesSentInput
  }

  export type MessageUncheckedCreateWithoutReceiverInput = {
    id?: string
    senderId: string
    content: string
    read?: boolean
    sentAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageCreateManyReceiverInputEnvelope = {
    data: MessageCreateManyReceiverInput | MessageCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCollaboratorCreateWithoutUserInput = {
    role?: string | null
    joinedAt?: Date | string
    project: ProjectCreateNestedOneWithoutCollaboratorsInput
  }

  export type ProjectCollaboratorUncheckedCreateWithoutUserInput = {
    projectId: string
    role?: string | null
    joinedAt?: Date | string
  }

  export type ProjectCollaboratorCreateOrConnectWithoutUserInput = {
    where: ProjectCollaboratorWhereUniqueInput
    create: XOR<ProjectCollaboratorCreateWithoutUserInput, ProjectCollaboratorUncheckedCreateWithoutUserInput>
  }

  export type ProjectCollaboratorCreateManyUserInputEnvelope = {
    data: ProjectCollaboratorCreateManyUserInput | ProjectCollaboratorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EndorsementCreateWithoutEndorserInput = {
    id?: string
    comment?: string | null
    createdAt?: Date | string
    project?: ProjectCreateNestedOneWithoutEndorsementsInput
  }

  export type EndorsementUncheckedCreateWithoutEndorserInput = {
    id?: string
    comment?: string | null
    createdAt?: Date | string
    projectId?: string | null
  }

  export type EndorsementCreateOrConnectWithoutEndorserInput = {
    where: EndorsementWhereUniqueInput
    create: XOR<EndorsementCreateWithoutEndorserInput, EndorsementUncheckedCreateWithoutEndorserInput>
  }

  export type EndorsementCreateManyEndorserInputEnvelope = {
    data: EndorsementCreateManyEndorserInput | EndorsementCreateManyEndorserInput[]
    skipDuplicates?: boolean
  }

  export type VerificationRequestCreateWithoutRequesterInput = {
    id?: string
    status: $Enums.VerificationStatus
    blockchainHash?: string | null
    requestedAt?: Date | string
    processedAt?: Date | string | null
    credential: CredentialCreateNestedOneWithoutVerificationRequestsInput
  }

  export type VerificationRequestUncheckedCreateWithoutRequesterInput = {
    id?: string
    credentialId: string
    status: $Enums.VerificationStatus
    blockchainHash?: string | null
    requestedAt?: Date | string
    processedAt?: Date | string | null
  }

  export type VerificationRequestCreateOrConnectWithoutRequesterInput = {
    where: VerificationRequestWhereUniqueInput
    create: XOR<VerificationRequestCreateWithoutRequesterInput, VerificationRequestUncheckedCreateWithoutRequesterInput>
  }

  export type VerificationRequestCreateManyRequesterInputEnvelope = {
    data: VerificationRequestCreateManyRequesterInput | VerificationRequestCreateManyRequesterInput[]
    skipDuplicates?: boolean
  }

  export type LearnerProfileUpsertWithoutUserInput = {
    update: XOR<LearnerProfileUpdateWithoutUserInput, LearnerProfileUncheckedUpdateWithoutUserInput>
    create: XOR<LearnerProfileCreateWithoutUserInput, LearnerProfileUncheckedCreateWithoutUserInput>
    where?: LearnerProfileWhereInput
  }

  export type LearnerProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: LearnerProfileWhereInput
    data: XOR<LearnerProfileUpdateWithoutUserInput, LearnerProfileUncheckedUpdateWithoutUserInput>
  }

  export type LearnerProfileUpdateWithoutUserInput = {
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    university?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    skillsMatchPercentage?: IntFieldUpdateOperationsInput | number
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
  }

  export type LearnerProfileUncheckedUpdateWithoutUserInput = {
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    university?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    skillsMatchPercentage?: IntFieldUpdateOperationsInput | number
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
  }

  export type UserSkillUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSkillWhereUniqueInput
    update: XOR<UserSkillUpdateWithoutUserInput, UserSkillUncheckedUpdateWithoutUserInput>
    create: XOR<UserSkillCreateWithoutUserInput, UserSkillUncheckedCreateWithoutUserInput>
  }

  export type UserSkillUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSkillWhereUniqueInput
    data: XOR<UserSkillUpdateWithoutUserInput, UserSkillUncheckedUpdateWithoutUserInput>
  }

  export type UserSkillUpdateManyWithWhereWithoutUserInput = {
    where: UserSkillScalarWhereInput
    data: XOR<UserSkillUpdateManyMutationInput, UserSkillUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSkillScalarWhereInput = {
    AND?: UserSkillScalarWhereInput | UserSkillScalarWhereInput[]
    OR?: UserSkillScalarWhereInput[]
    NOT?: UserSkillScalarWhereInput | UserSkillScalarWhereInput[]
    id?: StringFilter<"UserSkill"> | string
    userId?: StringFilter<"UserSkill"> | string
    skillId?: StringFilter<"UserSkill"> | string
    level?: EnumSkillLevelFilter<"UserSkill"> | $Enums.SkillLevel
    endorsements?: IntFilter<"UserSkill"> | number
    verified?: BoolFilter<"UserSkill"> | boolean
    addedAt?: DateTimeFilter<"UserSkill"> | Date | string
  }

  export type CredentialUpsertWithWhereUniqueWithoutUserInput = {
    where: CredentialWhereUniqueInput
    update: XOR<CredentialUpdateWithoutUserInput, CredentialUncheckedUpdateWithoutUserInput>
    create: XOR<CredentialCreateWithoutUserInput, CredentialUncheckedCreateWithoutUserInput>
  }

  export type CredentialUpdateWithWhereUniqueWithoutUserInput = {
    where: CredentialWhereUniqueInput
    data: XOR<CredentialUpdateWithoutUserInput, CredentialUncheckedUpdateWithoutUserInput>
  }

  export type CredentialUpdateManyWithWhereWithoutUserInput = {
    where: CredentialScalarWhereInput
    data: XOR<CredentialUpdateManyMutationInput, CredentialUncheckedUpdateManyWithoutUserInput>
  }

  export type CredentialScalarWhereInput = {
    AND?: CredentialScalarWhereInput | CredentialScalarWhereInput[]
    OR?: CredentialScalarWhereInput[]
    NOT?: CredentialScalarWhereInput | CredentialScalarWhereInput[]
    id?: StringFilter<"Credential"> | string
    userId?: StringFilter<"Credential"> | string
    title?: StringFilter<"Credential"> | string
    issuer?: StringFilter<"Credential"> | string
    type?: EnumCredentialTypeFilter<"Credential"> | $Enums.CredentialType
    issueDate?: DateTimeFilter<"Credential"> | Date | string
    expiryDate?: DateTimeNullableFilter<"Credential"> | Date | string | null
    verified?: BoolFilter<"Credential"> | boolean
    blockchainHash?: StringNullableFilter<"Credential"> | string | null
    qrCode?: StringNullableFilter<"Credential"> | string | null
    createdAt?: DateTimeFilter<"Credential"> | Date | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutUserInput, ProjectUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutUserInput, ProjectUncheckedUpdateWithoutUserInput>
  }

  export type ProjectUpdateManyWithWhereWithoutUserInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    userId?: StringFilter<"Project"> | string
    title?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    visibility?: EnumProjectVisibilityFilter<"Project"> | $Enums.ProjectVisibility
    verified?: BoolFilter<"Project"> | boolean
    githubUrl?: StringNullableFilter<"Project"> | string | null
    liveUrl?: StringNullableFilter<"Project"> | string | null
    startDate?: DateTimeFilter<"Project"> | Date | string
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
  }

  export type ApplicationUpsertWithWhereUniqueWithoutUserInput = {
    where: ApplicationWhereUniqueInput
    update: XOR<ApplicationUpdateWithoutUserInput, ApplicationUncheckedUpdateWithoutUserInput>
    create: XOR<ApplicationCreateWithoutUserInput, ApplicationUncheckedCreateWithoutUserInput>
  }

  export type ApplicationUpdateWithWhereUniqueWithoutUserInput = {
    where: ApplicationWhereUniqueInput
    data: XOR<ApplicationUpdateWithoutUserInput, ApplicationUncheckedUpdateWithoutUserInput>
  }

  export type ApplicationUpdateManyWithWhereWithoutUserInput = {
    where: ApplicationScalarWhereInput
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyWithoutUserInput>
  }

  export type ApplicationScalarWhereInput = {
    AND?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
    OR?: ApplicationScalarWhereInput[]
    NOT?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
    id?: StringFilter<"Application"> | string
    userId?: StringFilter<"Application"> | string
    opportunityId?: StringFilter<"Application"> | string
    status?: EnumApplicationStatusFilter<"Application"> | $Enums.ApplicationStatus
    coverLetter?: StringNullableFilter<"Application"> | string | null
    resumeUrl?: StringNullableFilter<"Application"> | string | null
    appliedAt?: DateTimeFilter<"Application"> | Date | string
    updatedAt?: DateTimeFilter<"Application"> | Date | string
  }

  export type ConnectionUpsertWithWhereUniqueWithoutUserInput = {
    where: ConnectionWhereUniqueInput
    update: XOR<ConnectionUpdateWithoutUserInput, ConnectionUncheckedUpdateWithoutUserInput>
    create: XOR<ConnectionCreateWithoutUserInput, ConnectionUncheckedCreateWithoutUserInput>
  }

  export type ConnectionUpdateWithWhereUniqueWithoutUserInput = {
    where: ConnectionWhereUniqueInput
    data: XOR<ConnectionUpdateWithoutUserInput, ConnectionUncheckedUpdateWithoutUserInput>
  }

  export type ConnectionUpdateManyWithWhereWithoutUserInput = {
    where: ConnectionScalarWhereInput
    data: XOR<ConnectionUpdateManyMutationInput, ConnectionUncheckedUpdateManyWithoutUserInput>
  }

  export type ConnectionScalarWhereInput = {
    AND?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
    OR?: ConnectionScalarWhereInput[]
    NOT?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
    id?: StringFilter<"Connection"> | string
    userId?: StringFilter<"Connection"> | string
    connectedUserId?: StringFilter<"Connection"> | string
    type?: EnumConnectionTypeFilter<"Connection"> | $Enums.ConnectionType
    mutualConnections?: IntFilter<"Connection"> | number
    connectedAt?: DateTimeFilter<"Connection"> | Date | string
  }

  export type ConnectionUpsertWithWhereUniqueWithoutConnectedUserInput = {
    where: ConnectionWhereUniqueInput
    update: XOR<ConnectionUpdateWithoutConnectedUserInput, ConnectionUncheckedUpdateWithoutConnectedUserInput>
    create: XOR<ConnectionCreateWithoutConnectedUserInput, ConnectionUncheckedCreateWithoutConnectedUserInput>
  }

  export type ConnectionUpdateWithWhereUniqueWithoutConnectedUserInput = {
    where: ConnectionWhereUniqueInput
    data: XOR<ConnectionUpdateWithoutConnectedUserInput, ConnectionUncheckedUpdateWithoutConnectedUserInput>
  }

  export type ConnectionUpdateManyWithWhereWithoutConnectedUserInput = {
    where: ConnectionScalarWhereInput
    data: XOR<ConnectionUpdateManyMutationInput, ConnectionUncheckedUpdateManyWithoutConnectedUserInput>
  }

  export type ConnectionRequestUpsertWithWhereUniqueWithoutSenderInput = {
    where: ConnectionRequestWhereUniqueInput
    update: XOR<ConnectionRequestUpdateWithoutSenderInput, ConnectionRequestUncheckedUpdateWithoutSenderInput>
    create: XOR<ConnectionRequestCreateWithoutSenderInput, ConnectionRequestUncheckedCreateWithoutSenderInput>
  }

  export type ConnectionRequestUpdateWithWhereUniqueWithoutSenderInput = {
    where: ConnectionRequestWhereUniqueInput
    data: XOR<ConnectionRequestUpdateWithoutSenderInput, ConnectionRequestUncheckedUpdateWithoutSenderInput>
  }

  export type ConnectionRequestUpdateManyWithWhereWithoutSenderInput = {
    where: ConnectionRequestScalarWhereInput
    data: XOR<ConnectionRequestUpdateManyMutationInput, ConnectionRequestUncheckedUpdateManyWithoutSenderInput>
  }

  export type ConnectionRequestScalarWhereInput = {
    AND?: ConnectionRequestScalarWhereInput | ConnectionRequestScalarWhereInput[]
    OR?: ConnectionRequestScalarWhereInput[]
    NOT?: ConnectionRequestScalarWhereInput | ConnectionRequestScalarWhereInput[]
    id?: StringFilter<"ConnectionRequest"> | string
    senderId?: StringFilter<"ConnectionRequest"> | string
    receiverId?: StringFilter<"ConnectionRequest"> | string
    message?: StringNullableFilter<"ConnectionRequest"> | string | null
    status?: EnumConnectionStatusFilter<"ConnectionRequest"> | $Enums.ConnectionStatus
    requestedAt?: DateTimeFilter<"ConnectionRequest"> | Date | string
    respondedAt?: DateTimeNullableFilter<"ConnectionRequest"> | Date | string | null
  }

  export type ConnectionRequestUpsertWithWhereUniqueWithoutReceiverInput = {
    where: ConnectionRequestWhereUniqueInput
    update: XOR<ConnectionRequestUpdateWithoutReceiverInput, ConnectionRequestUncheckedUpdateWithoutReceiverInput>
    create: XOR<ConnectionRequestCreateWithoutReceiverInput, ConnectionRequestUncheckedCreateWithoutReceiverInput>
  }

  export type ConnectionRequestUpdateWithWhereUniqueWithoutReceiverInput = {
    where: ConnectionRequestWhereUniqueInput
    data: XOR<ConnectionRequestUpdateWithoutReceiverInput, ConnectionRequestUncheckedUpdateWithoutReceiverInput>
  }

  export type ConnectionRequestUpdateManyWithWhereWithoutReceiverInput = {
    where: ConnectionRequestScalarWhereInput
    data: XOR<ConnectionRequestUpdateManyMutationInput, ConnectionRequestUncheckedUpdateManyWithoutReceiverInput>
  }

  export type FeedItemUpsertWithWhereUniqueWithoutUserInput = {
    where: FeedItemWhereUniqueInput
    update: XOR<FeedItemUpdateWithoutUserInput, FeedItemUncheckedUpdateWithoutUserInput>
    create: XOR<FeedItemCreateWithoutUserInput, FeedItemUncheckedCreateWithoutUserInput>
  }

  export type FeedItemUpdateWithWhereUniqueWithoutUserInput = {
    where: FeedItemWhereUniqueInput
    data: XOR<FeedItemUpdateWithoutUserInput, FeedItemUncheckedUpdateWithoutUserInput>
  }

  export type FeedItemUpdateManyWithWhereWithoutUserInput = {
    where: FeedItemScalarWhereInput
    data: XOR<FeedItemUpdateManyMutationInput, FeedItemUncheckedUpdateManyWithoutUserInput>
  }

  export type FeedItemScalarWhereInput = {
    AND?: FeedItemScalarWhereInput | FeedItemScalarWhereInput[]
    OR?: FeedItemScalarWhereInput[]
    NOT?: FeedItemScalarWhereInput | FeedItemScalarWhereInput[]
    id?: StringFilter<"FeedItem"> | string
    type?: EnumFeedItemTypeFilter<"FeedItem"> | $Enums.FeedItemType
    userId?: StringFilter<"FeedItem"> | string
    priority?: EnumPriorityFilter<"FeedItem"> | $Enums.Priority
    title?: StringFilter<"FeedItem"> | string
    description?: StringFilter<"FeedItem"> | string
    image?: StringNullableFilter<"FeedItem"> | string | null
    data?: JsonNullableFilter<"FeedItem">
    timestamp?: DateTimeFilter<"FeedItem"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    icon?: StringNullableFilter<"Notification"> | string | null
    timestamp?: DateTimeFilter<"Notification"> | Date | string
  }

  export type CareerPathUpsertWithWhereUniqueWithoutUserInput = {
    where: CareerPathWhereUniqueInput
    update: XOR<CareerPathUpdateWithoutUserInput, CareerPathUncheckedUpdateWithoutUserInput>
    create: XOR<CareerPathCreateWithoutUserInput, CareerPathUncheckedCreateWithoutUserInput>
  }

  export type CareerPathUpdateWithWhereUniqueWithoutUserInput = {
    where: CareerPathWhereUniqueInput
    data: XOR<CareerPathUpdateWithoutUserInput, CareerPathUncheckedUpdateWithoutUserInput>
  }

  export type CareerPathUpdateManyWithWhereWithoutUserInput = {
    where: CareerPathScalarWhereInput
    data: XOR<CareerPathUpdateManyMutationInput, CareerPathUncheckedUpdateManyWithoutUserInput>
  }

  export type CareerPathScalarWhereInput = {
    AND?: CareerPathScalarWhereInput | CareerPathScalarWhereInput[]
    OR?: CareerPathScalarWhereInput[]
    NOT?: CareerPathScalarWhereInput | CareerPathScalarWhereInput[]
    id?: StringFilter<"CareerPath"> | string
    userId?: StringFilter<"CareerPath"> | string
    currentRole?: StringFilter<"CareerPath"> | string
    targetRole?: StringFilter<"CareerPath"> | string
    estimatedDuration?: IntFilter<"CareerPath"> | number
    createdAt?: DateTimeFilter<"CareerPath"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    read?: BoolFilter<"Message"> | boolean
    sentAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
  }

  export type MessageUpdateManyWithWhereWithoutReceiverInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutReceiverInput>
  }

  export type ProjectCollaboratorUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectCollaboratorWhereUniqueInput
    update: XOR<ProjectCollaboratorUpdateWithoutUserInput, ProjectCollaboratorUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectCollaboratorCreateWithoutUserInput, ProjectCollaboratorUncheckedCreateWithoutUserInput>
  }

  export type ProjectCollaboratorUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectCollaboratorWhereUniqueInput
    data: XOR<ProjectCollaboratorUpdateWithoutUserInput, ProjectCollaboratorUncheckedUpdateWithoutUserInput>
  }

  export type ProjectCollaboratorUpdateManyWithWhereWithoutUserInput = {
    where: ProjectCollaboratorScalarWhereInput
    data: XOR<ProjectCollaboratorUpdateManyMutationInput, ProjectCollaboratorUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectCollaboratorScalarWhereInput = {
    AND?: ProjectCollaboratorScalarWhereInput | ProjectCollaboratorScalarWhereInput[]
    OR?: ProjectCollaboratorScalarWhereInput[]
    NOT?: ProjectCollaboratorScalarWhereInput | ProjectCollaboratorScalarWhereInput[]
    projectId?: StringFilter<"ProjectCollaborator"> | string
    userId?: StringFilter<"ProjectCollaborator"> | string
    role?: StringNullableFilter<"ProjectCollaborator"> | string | null
    joinedAt?: DateTimeFilter<"ProjectCollaborator"> | Date | string
  }

  export type EndorsementUpsertWithWhereUniqueWithoutEndorserInput = {
    where: EndorsementWhereUniqueInput
    update: XOR<EndorsementUpdateWithoutEndorserInput, EndorsementUncheckedUpdateWithoutEndorserInput>
    create: XOR<EndorsementCreateWithoutEndorserInput, EndorsementUncheckedCreateWithoutEndorserInput>
  }

  export type EndorsementUpdateWithWhereUniqueWithoutEndorserInput = {
    where: EndorsementWhereUniqueInput
    data: XOR<EndorsementUpdateWithoutEndorserInput, EndorsementUncheckedUpdateWithoutEndorserInput>
  }

  export type EndorsementUpdateManyWithWhereWithoutEndorserInput = {
    where: EndorsementScalarWhereInput
    data: XOR<EndorsementUpdateManyMutationInput, EndorsementUncheckedUpdateManyWithoutEndorserInput>
  }

  export type EndorsementScalarWhereInput = {
    AND?: EndorsementScalarWhereInput | EndorsementScalarWhereInput[]
    OR?: EndorsementScalarWhereInput[]
    NOT?: EndorsementScalarWhereInput | EndorsementScalarWhereInput[]
    id?: StringFilter<"Endorsement"> | string
    endorserId?: StringFilter<"Endorsement"> | string
    comment?: StringNullableFilter<"Endorsement"> | string | null
    createdAt?: DateTimeFilter<"Endorsement"> | Date | string
    projectId?: StringNullableFilter<"Endorsement"> | string | null
  }

  export type VerificationRequestUpsertWithWhereUniqueWithoutRequesterInput = {
    where: VerificationRequestWhereUniqueInput
    update: XOR<VerificationRequestUpdateWithoutRequesterInput, VerificationRequestUncheckedUpdateWithoutRequesterInput>
    create: XOR<VerificationRequestCreateWithoutRequesterInput, VerificationRequestUncheckedCreateWithoutRequesterInput>
  }

  export type VerificationRequestUpdateWithWhereUniqueWithoutRequesterInput = {
    where: VerificationRequestWhereUniqueInput
    data: XOR<VerificationRequestUpdateWithoutRequesterInput, VerificationRequestUncheckedUpdateWithoutRequesterInput>
  }

  export type VerificationRequestUpdateManyWithWhereWithoutRequesterInput = {
    where: VerificationRequestScalarWhereInput
    data: XOR<VerificationRequestUpdateManyMutationInput, VerificationRequestUncheckedUpdateManyWithoutRequesterInput>
  }

  export type VerificationRequestScalarWhereInput = {
    AND?: VerificationRequestScalarWhereInput | VerificationRequestScalarWhereInput[]
    OR?: VerificationRequestScalarWhereInput[]
    NOT?: VerificationRequestScalarWhereInput | VerificationRequestScalarWhereInput[]
    id?: StringFilter<"VerificationRequest"> | string
    credentialId?: StringFilter<"VerificationRequest"> | string
    requestedBy?: StringFilter<"VerificationRequest"> | string
    status?: EnumVerificationStatusFilter<"VerificationRequest"> | $Enums.VerificationStatus
    blockchainHash?: StringNullableFilter<"VerificationRequest"> | string | null
    requestedAt?: DateTimeFilter<"VerificationRequest"> | Date | string
    processedAt?: DateTimeNullableFilter<"VerificationRequest"> | Date | string | null
  }

  export type UserCreateWithoutLearnerProfileInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    credentials?: CredentialCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    applications?: ApplicationCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathCreateNestedManyWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    endorsements?: EndorsementCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestCreateNestedManyWithoutRequesterInput
  }

  export type UserUncheckedCreateWithoutLearnerProfileInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    credentials?: CredentialUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionUncheckedCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionUncheckedCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestUncheckedCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestUncheckedCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    endorsements?: EndorsementUncheckedCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type UserCreateOrConnectWithoutLearnerProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLearnerProfileInput, UserUncheckedCreateWithoutLearnerProfileInput>
  }

  export type UserUpsertWithoutLearnerProfileInput = {
    update: XOR<UserUpdateWithoutLearnerProfileInput, UserUncheckedUpdateWithoutLearnerProfileInput>
    create: XOR<UserCreateWithoutLearnerProfileInput, UserUncheckedCreateWithoutLearnerProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLearnerProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLearnerProfileInput, UserUncheckedUpdateWithoutLearnerProfileInput>
  }

  export type UserUpdateWithoutLearnerProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    credentials?: CredentialUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    applications?: ApplicationUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUpdateManyWithoutRequesterNestedInput
  }

  export type UserUncheckedUpdateWithoutLearnerProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    credentials?: CredentialUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUncheckedUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUncheckedUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUncheckedUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUncheckedUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUncheckedUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUncheckedUpdateManyWithoutRequesterNestedInput
  }

  export type UserSkillCreateWithoutSkillInput = {
    id?: string
    level: $Enums.SkillLevel
    endorsements?: number
    verified?: boolean
    addedAt?: Date | string
    user: UserCreateNestedOneWithoutUserSkillsInput
  }

  export type UserSkillUncheckedCreateWithoutSkillInput = {
    id?: string
    userId: string
    level: $Enums.SkillLevel
    endorsements?: number
    verified?: boolean
    addedAt?: Date | string
  }

  export type UserSkillCreateOrConnectWithoutSkillInput = {
    where: UserSkillWhereUniqueInput
    create: XOR<UserSkillCreateWithoutSkillInput, UserSkillUncheckedCreateWithoutSkillInput>
  }

  export type UserSkillCreateManySkillInputEnvelope = {
    data: UserSkillCreateManySkillInput | UserSkillCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type CredentialSkillCreateWithoutSkillInput = {
    credential: CredentialCreateNestedOneWithoutSkillsInput
  }

  export type CredentialSkillUncheckedCreateWithoutSkillInput = {
    credentialId: string
  }

  export type CredentialSkillCreateOrConnectWithoutSkillInput = {
    where: CredentialSkillWhereUniqueInput
    create: XOR<CredentialSkillCreateWithoutSkillInput, CredentialSkillUncheckedCreateWithoutSkillInput>
  }

  export type CredentialSkillCreateManySkillInputEnvelope = {
    data: CredentialSkillCreateManySkillInput | CredentialSkillCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type ProjectSkillCreateWithoutSkillInput = {
    project: ProjectCreateNestedOneWithoutSkillsInput
  }

  export type ProjectSkillUncheckedCreateWithoutSkillInput = {
    projectId: string
  }

  export type ProjectSkillCreateOrConnectWithoutSkillInput = {
    where: ProjectSkillWhereUniqueInput
    create: XOR<ProjectSkillCreateWithoutSkillInput, ProjectSkillUncheckedCreateWithoutSkillInput>
  }

  export type ProjectSkillCreateManySkillInputEnvelope = {
    data: ProjectSkillCreateManySkillInput | ProjectSkillCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type OpportunitySkillCreateWithoutSkillInput = {
    opportunity: OpportunityCreateNestedOneWithoutSkillsInput
  }

  export type OpportunitySkillUncheckedCreateWithoutSkillInput = {
    opportunityId: string
  }

  export type OpportunitySkillCreateOrConnectWithoutSkillInput = {
    where: OpportunitySkillWhereUniqueInput
    create: XOR<OpportunitySkillCreateWithoutSkillInput, OpportunitySkillUncheckedCreateWithoutSkillInput>
  }

  export type OpportunitySkillCreateManySkillInputEnvelope = {
    data: OpportunitySkillCreateManySkillInput | OpportunitySkillCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type CourseSkillCreateWithoutSkillInput = {
    course: CourseCreateNestedOneWithoutSkillsInput
  }

  export type CourseSkillUncheckedCreateWithoutSkillInput = {
    courseId: string
  }

  export type CourseSkillCreateOrConnectWithoutSkillInput = {
    where: CourseSkillWhereUniqueInput
    create: XOR<CourseSkillCreateWithoutSkillInput, CourseSkillUncheckedCreateWithoutSkillInput>
  }

  export type CourseSkillCreateManySkillInputEnvelope = {
    data: CourseSkillCreateManySkillInput | CourseSkillCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type TrendingSkillCreateWithoutSkillInput = {
    demandPercentage: Decimal | DecimalJsLike | number | string
    growthRate: Decimal | DecimalJsLike | number | string
    averageSalary: bigint | number
    openPositions: number
    updatedAt?: Date | string
  }

  export type TrendingSkillUncheckedCreateWithoutSkillInput = {
    demandPercentage: Decimal | DecimalJsLike | number | string
    growthRate: Decimal | DecimalJsLike | number | string
    averageSalary: bigint | number
    openPositions: number
    updatedAt?: Date | string
  }

  export type TrendingSkillCreateOrConnectWithoutSkillInput = {
    where: TrendingSkillWhereUniqueInput
    create: XOR<TrendingSkillCreateWithoutSkillInput, TrendingSkillUncheckedCreateWithoutSkillInput>
  }

  export type SkillGapCreateWithoutSkillInput = {
    id?: string
    currentLevel: $Enums.SkillLevel
    targetLevel: $Enums.SkillLevel
    priority: $Enums.Priority
    careerPath: CareerPathCreateNestedOneWithoutSkillGapsInput
  }

  export type SkillGapUncheckedCreateWithoutSkillInput = {
    id?: string
    careerPathId: string
    currentLevel: $Enums.SkillLevel
    targetLevel: $Enums.SkillLevel
    priority: $Enums.Priority
  }

  export type SkillGapCreateOrConnectWithoutSkillInput = {
    where: SkillGapWhereUniqueInput
    create: XOR<SkillGapCreateWithoutSkillInput, SkillGapUncheckedCreateWithoutSkillInput>
  }

  export type SkillGapCreateManySkillInputEnvelope = {
    data: SkillGapCreateManySkillInput | SkillGapCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type UserSkillUpsertWithWhereUniqueWithoutSkillInput = {
    where: UserSkillWhereUniqueInput
    update: XOR<UserSkillUpdateWithoutSkillInput, UserSkillUncheckedUpdateWithoutSkillInput>
    create: XOR<UserSkillCreateWithoutSkillInput, UserSkillUncheckedCreateWithoutSkillInput>
  }

  export type UserSkillUpdateWithWhereUniqueWithoutSkillInput = {
    where: UserSkillWhereUniqueInput
    data: XOR<UserSkillUpdateWithoutSkillInput, UserSkillUncheckedUpdateWithoutSkillInput>
  }

  export type UserSkillUpdateManyWithWhereWithoutSkillInput = {
    where: UserSkillScalarWhereInput
    data: XOR<UserSkillUpdateManyMutationInput, UserSkillUncheckedUpdateManyWithoutSkillInput>
  }

  export type CredentialSkillUpsertWithWhereUniqueWithoutSkillInput = {
    where: CredentialSkillWhereUniqueInput
    update: XOR<CredentialSkillUpdateWithoutSkillInput, CredentialSkillUncheckedUpdateWithoutSkillInput>
    create: XOR<CredentialSkillCreateWithoutSkillInput, CredentialSkillUncheckedCreateWithoutSkillInput>
  }

  export type CredentialSkillUpdateWithWhereUniqueWithoutSkillInput = {
    where: CredentialSkillWhereUniqueInput
    data: XOR<CredentialSkillUpdateWithoutSkillInput, CredentialSkillUncheckedUpdateWithoutSkillInput>
  }

  export type CredentialSkillUpdateManyWithWhereWithoutSkillInput = {
    where: CredentialSkillScalarWhereInput
    data: XOR<CredentialSkillUpdateManyMutationInput, CredentialSkillUncheckedUpdateManyWithoutSkillInput>
  }

  export type CredentialSkillScalarWhereInput = {
    AND?: CredentialSkillScalarWhereInput | CredentialSkillScalarWhereInput[]
    OR?: CredentialSkillScalarWhereInput[]
    NOT?: CredentialSkillScalarWhereInput | CredentialSkillScalarWhereInput[]
    credentialId?: StringFilter<"CredentialSkill"> | string
    skillId?: StringFilter<"CredentialSkill"> | string
  }

  export type ProjectSkillUpsertWithWhereUniqueWithoutSkillInput = {
    where: ProjectSkillWhereUniqueInput
    update: XOR<ProjectSkillUpdateWithoutSkillInput, ProjectSkillUncheckedUpdateWithoutSkillInput>
    create: XOR<ProjectSkillCreateWithoutSkillInput, ProjectSkillUncheckedCreateWithoutSkillInput>
  }

  export type ProjectSkillUpdateWithWhereUniqueWithoutSkillInput = {
    where: ProjectSkillWhereUniqueInput
    data: XOR<ProjectSkillUpdateWithoutSkillInput, ProjectSkillUncheckedUpdateWithoutSkillInput>
  }

  export type ProjectSkillUpdateManyWithWhereWithoutSkillInput = {
    where: ProjectSkillScalarWhereInput
    data: XOR<ProjectSkillUpdateManyMutationInput, ProjectSkillUncheckedUpdateManyWithoutSkillInput>
  }

  export type ProjectSkillScalarWhereInput = {
    AND?: ProjectSkillScalarWhereInput | ProjectSkillScalarWhereInput[]
    OR?: ProjectSkillScalarWhereInput[]
    NOT?: ProjectSkillScalarWhereInput | ProjectSkillScalarWhereInput[]
    projectId?: StringFilter<"ProjectSkill"> | string
    skillId?: StringFilter<"ProjectSkill"> | string
  }

  export type OpportunitySkillUpsertWithWhereUniqueWithoutSkillInput = {
    where: OpportunitySkillWhereUniqueInput
    update: XOR<OpportunitySkillUpdateWithoutSkillInput, OpportunitySkillUncheckedUpdateWithoutSkillInput>
    create: XOR<OpportunitySkillCreateWithoutSkillInput, OpportunitySkillUncheckedCreateWithoutSkillInput>
  }

  export type OpportunitySkillUpdateWithWhereUniqueWithoutSkillInput = {
    where: OpportunitySkillWhereUniqueInput
    data: XOR<OpportunitySkillUpdateWithoutSkillInput, OpportunitySkillUncheckedUpdateWithoutSkillInput>
  }

  export type OpportunitySkillUpdateManyWithWhereWithoutSkillInput = {
    where: OpportunitySkillScalarWhereInput
    data: XOR<OpportunitySkillUpdateManyMutationInput, OpportunitySkillUncheckedUpdateManyWithoutSkillInput>
  }

  export type OpportunitySkillScalarWhereInput = {
    AND?: OpportunitySkillScalarWhereInput | OpportunitySkillScalarWhereInput[]
    OR?: OpportunitySkillScalarWhereInput[]
    NOT?: OpportunitySkillScalarWhereInput | OpportunitySkillScalarWhereInput[]
    opportunityId?: StringFilter<"OpportunitySkill"> | string
    skillId?: StringFilter<"OpportunitySkill"> | string
  }

  export type CourseSkillUpsertWithWhereUniqueWithoutSkillInput = {
    where: CourseSkillWhereUniqueInput
    update: XOR<CourseSkillUpdateWithoutSkillInput, CourseSkillUncheckedUpdateWithoutSkillInput>
    create: XOR<CourseSkillCreateWithoutSkillInput, CourseSkillUncheckedCreateWithoutSkillInput>
  }

  export type CourseSkillUpdateWithWhereUniqueWithoutSkillInput = {
    where: CourseSkillWhereUniqueInput
    data: XOR<CourseSkillUpdateWithoutSkillInput, CourseSkillUncheckedUpdateWithoutSkillInput>
  }

  export type CourseSkillUpdateManyWithWhereWithoutSkillInput = {
    where: CourseSkillScalarWhereInput
    data: XOR<CourseSkillUpdateManyMutationInput, CourseSkillUncheckedUpdateManyWithoutSkillInput>
  }

  export type CourseSkillScalarWhereInput = {
    AND?: CourseSkillScalarWhereInput | CourseSkillScalarWhereInput[]
    OR?: CourseSkillScalarWhereInput[]
    NOT?: CourseSkillScalarWhereInput | CourseSkillScalarWhereInput[]
    courseId?: StringFilter<"CourseSkill"> | string
    skillId?: StringFilter<"CourseSkill"> | string
  }

  export type TrendingSkillUpsertWithoutSkillInput = {
    update: XOR<TrendingSkillUpdateWithoutSkillInput, TrendingSkillUncheckedUpdateWithoutSkillInput>
    create: XOR<TrendingSkillCreateWithoutSkillInput, TrendingSkillUncheckedCreateWithoutSkillInput>
    where?: TrendingSkillWhereInput
  }

  export type TrendingSkillUpdateToOneWithWhereWithoutSkillInput = {
    where?: TrendingSkillWhereInput
    data: XOR<TrendingSkillUpdateWithoutSkillInput, TrendingSkillUncheckedUpdateWithoutSkillInput>
  }

  export type TrendingSkillUpdateWithoutSkillInput = {
    demandPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    growthRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    averageSalary?: BigIntFieldUpdateOperationsInput | bigint | number
    openPositions?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrendingSkillUncheckedUpdateWithoutSkillInput = {
    demandPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    growthRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    averageSalary?: BigIntFieldUpdateOperationsInput | bigint | number
    openPositions?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillGapUpsertWithWhereUniqueWithoutSkillInput = {
    where: SkillGapWhereUniqueInput
    update: XOR<SkillGapUpdateWithoutSkillInput, SkillGapUncheckedUpdateWithoutSkillInput>
    create: XOR<SkillGapCreateWithoutSkillInput, SkillGapUncheckedCreateWithoutSkillInput>
  }

  export type SkillGapUpdateWithWhereUniqueWithoutSkillInput = {
    where: SkillGapWhereUniqueInput
    data: XOR<SkillGapUpdateWithoutSkillInput, SkillGapUncheckedUpdateWithoutSkillInput>
  }

  export type SkillGapUpdateManyWithWhereWithoutSkillInput = {
    where: SkillGapScalarWhereInput
    data: XOR<SkillGapUpdateManyMutationInput, SkillGapUncheckedUpdateManyWithoutSkillInput>
  }

  export type SkillGapScalarWhereInput = {
    AND?: SkillGapScalarWhereInput | SkillGapScalarWhereInput[]
    OR?: SkillGapScalarWhereInput[]
    NOT?: SkillGapScalarWhereInput | SkillGapScalarWhereInput[]
    id?: StringFilter<"SkillGap"> | string
    careerPathId?: StringFilter<"SkillGap"> | string
    skillId?: StringFilter<"SkillGap"> | string
    currentLevel?: EnumSkillLevelFilter<"SkillGap"> | $Enums.SkillLevel
    targetLevel?: EnumSkillLevelFilter<"SkillGap"> | $Enums.SkillLevel
    priority?: EnumPriorityFilter<"SkillGap"> | $Enums.Priority
  }

  export type UserCreateWithoutUserSkillsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileCreateNestedOneWithoutUserInput
    credentials?: CredentialCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    applications?: ApplicationCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathCreateNestedManyWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    endorsements?: EndorsementCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestCreateNestedManyWithoutRequesterInput
  }

  export type UserUncheckedCreateWithoutUserSkillsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileUncheckedCreateNestedOneWithoutUserInput
    credentials?: CredentialUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionUncheckedCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionUncheckedCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestUncheckedCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestUncheckedCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    endorsements?: EndorsementUncheckedCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type UserCreateOrConnectWithoutUserSkillsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserSkillsInput, UserUncheckedCreateWithoutUserSkillsInput>
  }

  export type SkillCreateWithoutUserSkillsInput = {
    id?: string
    name: string
    category: $Enums.SkillCategory
    description?: string | null
    verified?: boolean
    trending?: boolean
    credentialSkills?: CredentialSkillCreateNestedManyWithoutSkillInput
    projectSkills?: ProjectSkillCreateNestedManyWithoutSkillInput
    opportunitySkills?: OpportunitySkillCreateNestedManyWithoutSkillInput
    courseSkills?: CourseSkillCreateNestedManyWithoutSkillInput
    trendingData?: TrendingSkillCreateNestedOneWithoutSkillInput
    skillGaps?: SkillGapCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutUserSkillsInput = {
    id?: string
    name: string
    category: $Enums.SkillCategory
    description?: string | null
    verified?: boolean
    trending?: boolean
    credentialSkills?: CredentialSkillUncheckedCreateNestedManyWithoutSkillInput
    projectSkills?: ProjectSkillUncheckedCreateNestedManyWithoutSkillInput
    opportunitySkills?: OpportunitySkillUncheckedCreateNestedManyWithoutSkillInput
    courseSkills?: CourseSkillUncheckedCreateNestedManyWithoutSkillInput
    trendingData?: TrendingSkillUncheckedCreateNestedOneWithoutSkillInput
    skillGaps?: SkillGapUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutUserSkillsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutUserSkillsInput, SkillUncheckedCreateWithoutUserSkillsInput>
  }

  export type UserUpsertWithoutUserSkillsInput = {
    update: XOR<UserUpdateWithoutUserSkillsInput, UserUncheckedUpdateWithoutUserSkillsInput>
    create: XOR<UserCreateWithoutUserSkillsInput, UserUncheckedCreateWithoutUserSkillsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserSkillsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserSkillsInput, UserUncheckedUpdateWithoutUserSkillsInput>
  }

  export type UserUpdateWithoutUserSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUpdateOneWithoutUserNestedInput
    credentials?: CredentialUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    applications?: ApplicationUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUpdateManyWithoutRequesterNestedInput
  }

  export type UserUncheckedUpdateWithoutUserSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUncheckedUpdateOneWithoutUserNestedInput
    credentials?: CredentialUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUncheckedUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUncheckedUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUncheckedUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUncheckedUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUncheckedUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUncheckedUpdateManyWithoutRequesterNestedInput
  }

  export type SkillUpsertWithoutUserSkillsInput = {
    update: XOR<SkillUpdateWithoutUserSkillsInput, SkillUncheckedUpdateWithoutUserSkillsInput>
    create: XOR<SkillCreateWithoutUserSkillsInput, SkillUncheckedCreateWithoutUserSkillsInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutUserSkillsInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutUserSkillsInput, SkillUncheckedUpdateWithoutUserSkillsInput>
  }

  export type SkillUpdateWithoutUserSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    credentialSkills?: CredentialSkillUpdateManyWithoutSkillNestedInput
    projectSkills?: ProjectSkillUpdateManyWithoutSkillNestedInput
    opportunitySkills?: OpportunitySkillUpdateManyWithoutSkillNestedInput
    courseSkills?: CourseSkillUpdateManyWithoutSkillNestedInput
    trendingData?: TrendingSkillUpdateOneWithoutSkillNestedInput
    skillGaps?: SkillGapUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutUserSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    credentialSkills?: CredentialSkillUncheckedUpdateManyWithoutSkillNestedInput
    projectSkills?: ProjectSkillUncheckedUpdateManyWithoutSkillNestedInput
    opportunitySkills?: OpportunitySkillUncheckedUpdateManyWithoutSkillNestedInput
    courseSkills?: CourseSkillUncheckedUpdateManyWithoutSkillNestedInput
    trendingData?: TrendingSkillUncheckedUpdateOneWithoutSkillNestedInput
    skillGaps?: SkillGapUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type SkillCreateWithoutTrendingDataInput = {
    id?: string
    name: string
    category: $Enums.SkillCategory
    description?: string | null
    verified?: boolean
    trending?: boolean
    userSkills?: UserSkillCreateNestedManyWithoutSkillInput
    credentialSkills?: CredentialSkillCreateNestedManyWithoutSkillInput
    projectSkills?: ProjectSkillCreateNestedManyWithoutSkillInput
    opportunitySkills?: OpportunitySkillCreateNestedManyWithoutSkillInput
    courseSkills?: CourseSkillCreateNestedManyWithoutSkillInput
    skillGaps?: SkillGapCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutTrendingDataInput = {
    id?: string
    name: string
    category: $Enums.SkillCategory
    description?: string | null
    verified?: boolean
    trending?: boolean
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutSkillInput
    credentialSkills?: CredentialSkillUncheckedCreateNestedManyWithoutSkillInput
    projectSkills?: ProjectSkillUncheckedCreateNestedManyWithoutSkillInput
    opportunitySkills?: OpportunitySkillUncheckedCreateNestedManyWithoutSkillInput
    courseSkills?: CourseSkillUncheckedCreateNestedManyWithoutSkillInput
    skillGaps?: SkillGapUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutTrendingDataInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutTrendingDataInput, SkillUncheckedCreateWithoutTrendingDataInput>
  }

  export type SkillUpsertWithoutTrendingDataInput = {
    update: XOR<SkillUpdateWithoutTrendingDataInput, SkillUncheckedUpdateWithoutTrendingDataInput>
    create: XOR<SkillCreateWithoutTrendingDataInput, SkillUncheckedCreateWithoutTrendingDataInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutTrendingDataInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutTrendingDataInput, SkillUncheckedUpdateWithoutTrendingDataInput>
  }

  export type SkillUpdateWithoutTrendingDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    userSkills?: UserSkillUpdateManyWithoutSkillNestedInput
    credentialSkills?: CredentialSkillUpdateManyWithoutSkillNestedInput
    projectSkills?: ProjectSkillUpdateManyWithoutSkillNestedInput
    opportunitySkills?: OpportunitySkillUpdateManyWithoutSkillNestedInput
    courseSkills?: CourseSkillUpdateManyWithoutSkillNestedInput
    skillGaps?: SkillGapUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutTrendingDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    userSkills?: UserSkillUncheckedUpdateManyWithoutSkillNestedInput
    credentialSkills?: CredentialSkillUncheckedUpdateManyWithoutSkillNestedInput
    projectSkills?: ProjectSkillUncheckedUpdateManyWithoutSkillNestedInput
    opportunitySkills?: OpportunitySkillUncheckedUpdateManyWithoutSkillNestedInput
    courseSkills?: CourseSkillUncheckedUpdateManyWithoutSkillNestedInput
    skillGaps?: SkillGapUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type UserCreateWithoutCredentialsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileCreateNestedOneWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    applications?: ApplicationCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathCreateNestedManyWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    endorsements?: EndorsementCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestCreateNestedManyWithoutRequesterInput
  }

  export type UserUncheckedCreateWithoutCredentialsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileUncheckedCreateNestedOneWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionUncheckedCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionUncheckedCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestUncheckedCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestUncheckedCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    endorsements?: EndorsementUncheckedCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type UserCreateOrConnectWithoutCredentialsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCredentialsInput, UserUncheckedCreateWithoutCredentialsInput>
  }

  export type CredentialSkillCreateWithoutCredentialInput = {
    skill: SkillCreateNestedOneWithoutCredentialSkillsInput
  }

  export type CredentialSkillUncheckedCreateWithoutCredentialInput = {
    skillId: string
  }

  export type CredentialSkillCreateOrConnectWithoutCredentialInput = {
    where: CredentialSkillWhereUniqueInput
    create: XOR<CredentialSkillCreateWithoutCredentialInput, CredentialSkillUncheckedCreateWithoutCredentialInput>
  }

  export type CredentialSkillCreateManyCredentialInputEnvelope = {
    data: CredentialSkillCreateManyCredentialInput | CredentialSkillCreateManyCredentialInput[]
    skipDuplicates?: boolean
  }

  export type VerificationRequestCreateWithoutCredentialInput = {
    id?: string
    status: $Enums.VerificationStatus
    blockchainHash?: string | null
    requestedAt?: Date | string
    processedAt?: Date | string | null
    requester: UserCreateNestedOneWithoutVerificationRequestsInput
  }

  export type VerificationRequestUncheckedCreateWithoutCredentialInput = {
    id?: string
    requestedBy: string
    status: $Enums.VerificationStatus
    blockchainHash?: string | null
    requestedAt?: Date | string
    processedAt?: Date | string | null
  }

  export type VerificationRequestCreateOrConnectWithoutCredentialInput = {
    where: VerificationRequestWhereUniqueInput
    create: XOR<VerificationRequestCreateWithoutCredentialInput, VerificationRequestUncheckedCreateWithoutCredentialInput>
  }

  export type VerificationRequestCreateManyCredentialInputEnvelope = {
    data: VerificationRequestCreateManyCredentialInput | VerificationRequestCreateManyCredentialInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCredentialsInput = {
    update: XOR<UserUpdateWithoutCredentialsInput, UserUncheckedUpdateWithoutCredentialsInput>
    create: XOR<UserCreateWithoutCredentialsInput, UserUncheckedCreateWithoutCredentialsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCredentialsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCredentialsInput, UserUncheckedUpdateWithoutCredentialsInput>
  }

  export type UserUpdateWithoutCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    applications?: ApplicationUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUpdateManyWithoutRequesterNestedInput
  }

  export type UserUncheckedUpdateWithoutCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUncheckedUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUncheckedUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUncheckedUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUncheckedUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUncheckedUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUncheckedUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUncheckedUpdateManyWithoutRequesterNestedInput
  }

  export type CredentialSkillUpsertWithWhereUniqueWithoutCredentialInput = {
    where: CredentialSkillWhereUniqueInput
    update: XOR<CredentialSkillUpdateWithoutCredentialInput, CredentialSkillUncheckedUpdateWithoutCredentialInput>
    create: XOR<CredentialSkillCreateWithoutCredentialInput, CredentialSkillUncheckedCreateWithoutCredentialInput>
  }

  export type CredentialSkillUpdateWithWhereUniqueWithoutCredentialInput = {
    where: CredentialSkillWhereUniqueInput
    data: XOR<CredentialSkillUpdateWithoutCredentialInput, CredentialSkillUncheckedUpdateWithoutCredentialInput>
  }

  export type CredentialSkillUpdateManyWithWhereWithoutCredentialInput = {
    where: CredentialSkillScalarWhereInput
    data: XOR<CredentialSkillUpdateManyMutationInput, CredentialSkillUncheckedUpdateManyWithoutCredentialInput>
  }

  export type VerificationRequestUpsertWithWhereUniqueWithoutCredentialInput = {
    where: VerificationRequestWhereUniqueInput
    update: XOR<VerificationRequestUpdateWithoutCredentialInput, VerificationRequestUncheckedUpdateWithoutCredentialInput>
    create: XOR<VerificationRequestCreateWithoutCredentialInput, VerificationRequestUncheckedCreateWithoutCredentialInput>
  }

  export type VerificationRequestUpdateWithWhereUniqueWithoutCredentialInput = {
    where: VerificationRequestWhereUniqueInput
    data: XOR<VerificationRequestUpdateWithoutCredentialInput, VerificationRequestUncheckedUpdateWithoutCredentialInput>
  }

  export type VerificationRequestUpdateManyWithWhereWithoutCredentialInput = {
    where: VerificationRequestScalarWhereInput
    data: XOR<VerificationRequestUpdateManyMutationInput, VerificationRequestUncheckedUpdateManyWithoutCredentialInput>
  }

  export type CredentialCreateWithoutSkillsInput = {
    id?: string
    title: string
    issuer: string
    type: $Enums.CredentialType
    issueDate: Date | string
    expiryDate?: Date | string | null
    verified?: boolean
    blockchainHash?: string | null
    qrCode?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCredentialsInput
    verificationRequests?: VerificationRequestCreateNestedManyWithoutCredentialInput
  }

  export type CredentialUncheckedCreateWithoutSkillsInput = {
    id?: string
    userId: string
    title: string
    issuer: string
    type: $Enums.CredentialType
    issueDate: Date | string
    expiryDate?: Date | string | null
    verified?: boolean
    blockchainHash?: string | null
    qrCode?: string | null
    createdAt?: Date | string
    verificationRequests?: VerificationRequestUncheckedCreateNestedManyWithoutCredentialInput
  }

  export type CredentialCreateOrConnectWithoutSkillsInput = {
    where: CredentialWhereUniqueInput
    create: XOR<CredentialCreateWithoutSkillsInput, CredentialUncheckedCreateWithoutSkillsInput>
  }

  export type SkillCreateWithoutCredentialSkillsInput = {
    id?: string
    name: string
    category: $Enums.SkillCategory
    description?: string | null
    verified?: boolean
    trending?: boolean
    userSkills?: UserSkillCreateNestedManyWithoutSkillInput
    projectSkills?: ProjectSkillCreateNestedManyWithoutSkillInput
    opportunitySkills?: OpportunitySkillCreateNestedManyWithoutSkillInput
    courseSkills?: CourseSkillCreateNestedManyWithoutSkillInput
    trendingData?: TrendingSkillCreateNestedOneWithoutSkillInput
    skillGaps?: SkillGapCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutCredentialSkillsInput = {
    id?: string
    name: string
    category: $Enums.SkillCategory
    description?: string | null
    verified?: boolean
    trending?: boolean
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutSkillInput
    projectSkills?: ProjectSkillUncheckedCreateNestedManyWithoutSkillInput
    opportunitySkills?: OpportunitySkillUncheckedCreateNestedManyWithoutSkillInput
    courseSkills?: CourseSkillUncheckedCreateNestedManyWithoutSkillInput
    trendingData?: TrendingSkillUncheckedCreateNestedOneWithoutSkillInput
    skillGaps?: SkillGapUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutCredentialSkillsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutCredentialSkillsInput, SkillUncheckedCreateWithoutCredentialSkillsInput>
  }

  export type CredentialUpsertWithoutSkillsInput = {
    update: XOR<CredentialUpdateWithoutSkillsInput, CredentialUncheckedUpdateWithoutSkillsInput>
    create: XOR<CredentialCreateWithoutSkillsInput, CredentialUncheckedCreateWithoutSkillsInput>
    where?: CredentialWhereInput
  }

  export type CredentialUpdateToOneWithWhereWithoutSkillsInput = {
    where?: CredentialWhereInput
    data: XOR<CredentialUpdateWithoutSkillsInput, CredentialUncheckedUpdateWithoutSkillsInput>
  }

  export type CredentialUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    blockchainHash?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCredentialsNestedInput
    verificationRequests?: VerificationRequestUpdateManyWithoutCredentialNestedInput
  }

  export type CredentialUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    blockchainHash?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationRequests?: VerificationRequestUncheckedUpdateManyWithoutCredentialNestedInput
  }

  export type SkillUpsertWithoutCredentialSkillsInput = {
    update: XOR<SkillUpdateWithoutCredentialSkillsInput, SkillUncheckedUpdateWithoutCredentialSkillsInput>
    create: XOR<SkillCreateWithoutCredentialSkillsInput, SkillUncheckedCreateWithoutCredentialSkillsInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutCredentialSkillsInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutCredentialSkillsInput, SkillUncheckedUpdateWithoutCredentialSkillsInput>
  }

  export type SkillUpdateWithoutCredentialSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    userSkills?: UserSkillUpdateManyWithoutSkillNestedInput
    projectSkills?: ProjectSkillUpdateManyWithoutSkillNestedInput
    opportunitySkills?: OpportunitySkillUpdateManyWithoutSkillNestedInput
    courseSkills?: CourseSkillUpdateManyWithoutSkillNestedInput
    trendingData?: TrendingSkillUpdateOneWithoutSkillNestedInput
    skillGaps?: SkillGapUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutCredentialSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    userSkills?: UserSkillUncheckedUpdateManyWithoutSkillNestedInput
    projectSkills?: ProjectSkillUncheckedUpdateManyWithoutSkillNestedInput
    opportunitySkills?: OpportunitySkillUncheckedUpdateManyWithoutSkillNestedInput
    courseSkills?: CourseSkillUncheckedUpdateManyWithoutSkillNestedInput
    trendingData?: TrendingSkillUncheckedUpdateOneWithoutSkillNestedInput
    skillGaps?: SkillGapUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type UserCreateWithoutProjectsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileCreateNestedOneWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    credentials?: CredentialCreateNestedManyWithoutUserInput
    applications?: ApplicationCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathCreateNestedManyWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    endorsements?: EndorsementCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestCreateNestedManyWithoutRequesterInput
  }

  export type UserUncheckedCreateWithoutProjectsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileUncheckedCreateNestedOneWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    credentials?: CredentialUncheckedCreateNestedManyWithoutUserInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionUncheckedCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionUncheckedCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestUncheckedCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestUncheckedCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    endorsements?: EndorsementUncheckedCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type UserCreateOrConnectWithoutProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectMediaCreateWithoutProjectInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    thumbnail?: string | null
    caption?: string | null
    displayOrder?: number
  }

  export type ProjectMediaUncheckedCreateWithoutProjectInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    thumbnail?: string | null
    caption?: string | null
    displayOrder?: number
  }

  export type ProjectMediaCreateOrConnectWithoutProjectInput = {
    where: ProjectMediaWhereUniqueInput
    create: XOR<ProjectMediaCreateWithoutProjectInput, ProjectMediaUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMediaCreateManyProjectInputEnvelope = {
    data: ProjectMediaCreateManyProjectInput | ProjectMediaCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectSkillCreateWithoutProjectInput = {
    skill: SkillCreateNestedOneWithoutProjectSkillsInput
  }

  export type ProjectSkillUncheckedCreateWithoutProjectInput = {
    skillId: string
  }

  export type ProjectSkillCreateOrConnectWithoutProjectInput = {
    where: ProjectSkillWhereUniqueInput
    create: XOR<ProjectSkillCreateWithoutProjectInput, ProjectSkillUncheckedCreateWithoutProjectInput>
  }

  export type ProjectSkillCreateManyProjectInputEnvelope = {
    data: ProjectSkillCreateManyProjectInput | ProjectSkillCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCollaboratorCreateWithoutProjectInput = {
    role?: string | null
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectCollaborationsInput
  }

  export type ProjectCollaboratorUncheckedCreateWithoutProjectInput = {
    userId: string
    role?: string | null
    joinedAt?: Date | string
  }

  export type ProjectCollaboratorCreateOrConnectWithoutProjectInput = {
    where: ProjectCollaboratorWhereUniqueInput
    create: XOR<ProjectCollaboratorCreateWithoutProjectInput, ProjectCollaboratorUncheckedCreateWithoutProjectInput>
  }

  export type ProjectCollaboratorCreateManyProjectInputEnvelope = {
    data: ProjectCollaboratorCreateManyProjectInput | ProjectCollaboratorCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type EndorsementCreateWithoutProjectInput = {
    id?: string
    comment?: string | null
    createdAt?: Date | string
    endorser: UserCreateNestedOneWithoutEndorsementsInput
  }

  export type EndorsementUncheckedCreateWithoutProjectInput = {
    id?: string
    endorserId: string
    comment?: string | null
    createdAt?: Date | string
  }

  export type EndorsementCreateOrConnectWithoutProjectInput = {
    where: EndorsementWhereUniqueInput
    create: XOR<EndorsementCreateWithoutProjectInput, EndorsementUncheckedCreateWithoutProjectInput>
  }

  export type EndorsementCreateManyProjectInputEnvelope = {
    data: EndorsementCreateManyProjectInput | EndorsementCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProjectsInput = {
    update: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type UserUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    credentials?: CredentialUpdateManyWithoutUserNestedInput
    applications?: ApplicationUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUpdateManyWithoutRequesterNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUncheckedUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    credentials?: CredentialUncheckedUpdateManyWithoutUserNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUncheckedUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUncheckedUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUncheckedUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUncheckedUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUncheckedUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUncheckedUpdateManyWithoutRequesterNestedInput
  }

  export type ProjectMediaUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectMediaWhereUniqueInput
    update: XOR<ProjectMediaUpdateWithoutProjectInput, ProjectMediaUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectMediaCreateWithoutProjectInput, ProjectMediaUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMediaUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectMediaWhereUniqueInput
    data: XOR<ProjectMediaUpdateWithoutProjectInput, ProjectMediaUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectMediaUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectMediaScalarWhereInput
    data: XOR<ProjectMediaUpdateManyMutationInput, ProjectMediaUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectMediaScalarWhereInput = {
    AND?: ProjectMediaScalarWhereInput | ProjectMediaScalarWhereInput[]
    OR?: ProjectMediaScalarWhereInput[]
    NOT?: ProjectMediaScalarWhereInput | ProjectMediaScalarWhereInput[]
    id?: StringFilter<"ProjectMedia"> | string
    projectId?: StringFilter<"ProjectMedia"> | string
    type?: EnumMediaTypeFilter<"ProjectMedia"> | $Enums.MediaType
    url?: StringFilter<"ProjectMedia"> | string
    thumbnail?: StringNullableFilter<"ProjectMedia"> | string | null
    caption?: StringNullableFilter<"ProjectMedia"> | string | null
    displayOrder?: IntFilter<"ProjectMedia"> | number
  }

  export type ProjectSkillUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectSkillWhereUniqueInput
    update: XOR<ProjectSkillUpdateWithoutProjectInput, ProjectSkillUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectSkillCreateWithoutProjectInput, ProjectSkillUncheckedCreateWithoutProjectInput>
  }

  export type ProjectSkillUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectSkillWhereUniqueInput
    data: XOR<ProjectSkillUpdateWithoutProjectInput, ProjectSkillUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectSkillUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectSkillScalarWhereInput
    data: XOR<ProjectSkillUpdateManyMutationInput, ProjectSkillUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectCollaboratorUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectCollaboratorWhereUniqueInput
    update: XOR<ProjectCollaboratorUpdateWithoutProjectInput, ProjectCollaboratorUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectCollaboratorCreateWithoutProjectInput, ProjectCollaboratorUncheckedCreateWithoutProjectInput>
  }

  export type ProjectCollaboratorUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectCollaboratorWhereUniqueInput
    data: XOR<ProjectCollaboratorUpdateWithoutProjectInput, ProjectCollaboratorUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectCollaboratorUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectCollaboratorScalarWhereInput
    data: XOR<ProjectCollaboratorUpdateManyMutationInput, ProjectCollaboratorUncheckedUpdateManyWithoutProjectInput>
  }

  export type EndorsementUpsertWithWhereUniqueWithoutProjectInput = {
    where: EndorsementWhereUniqueInput
    update: XOR<EndorsementUpdateWithoutProjectInput, EndorsementUncheckedUpdateWithoutProjectInput>
    create: XOR<EndorsementCreateWithoutProjectInput, EndorsementUncheckedCreateWithoutProjectInput>
  }

  export type EndorsementUpdateWithWhereUniqueWithoutProjectInput = {
    where: EndorsementWhereUniqueInput
    data: XOR<EndorsementUpdateWithoutProjectInput, EndorsementUncheckedUpdateWithoutProjectInput>
  }

  export type EndorsementUpdateManyWithWhereWithoutProjectInput = {
    where: EndorsementScalarWhereInput
    data: XOR<EndorsementUpdateManyMutationInput, EndorsementUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectCreateWithoutMediaInput = {
    id?: string
    title: string
    description: string
    visibility: $Enums.ProjectVisibility
    verified?: boolean
    githubUrl?: string | null
    liveUrl?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    skills?: ProjectSkillCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorCreateNestedManyWithoutProjectInput
    endorsements?: EndorsementCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMediaInput = {
    id?: string
    userId: string
    title: string
    description: string
    visibility: $Enums.ProjectVisibility
    verified?: boolean
    githubUrl?: string | null
    liveUrl?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: ProjectSkillUncheckedCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorUncheckedCreateNestedManyWithoutProjectInput
    endorsements?: EndorsementUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMediaInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMediaInput, ProjectUncheckedCreateWithoutMediaInput>
  }

  export type ProjectUpsertWithoutMediaInput = {
    update: XOR<ProjectUpdateWithoutMediaInput, ProjectUncheckedUpdateWithoutMediaInput>
    create: XOR<ProjectCreateWithoutMediaInput, ProjectUncheckedCreateWithoutMediaInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMediaInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMediaInput, ProjectUncheckedUpdateWithoutMediaInput>
  }

  export type ProjectUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    visibility?: EnumProjectVisibilityFieldUpdateOperationsInput | $Enums.ProjectVisibility
    verified?: BoolFieldUpdateOperationsInput | boolean
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    skills?: ProjectSkillUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUpdateManyWithoutProjectNestedInput
    endorsements?: EndorsementUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    visibility?: EnumProjectVisibilityFieldUpdateOperationsInput | $Enums.ProjectVisibility
    verified?: BoolFieldUpdateOperationsInput | boolean
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: ProjectSkillUncheckedUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUncheckedUpdateManyWithoutProjectNestedInput
    endorsements?: EndorsementUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutSkillsInput = {
    id?: string
    title: string
    description: string
    visibility: $Enums.ProjectVisibility
    verified?: boolean
    githubUrl?: string | null
    liveUrl?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    media?: ProjectMediaCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorCreateNestedManyWithoutProjectInput
    endorsements?: EndorsementCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSkillsInput = {
    id?: string
    userId: string
    title: string
    description: string
    visibility: $Enums.ProjectVisibility
    verified?: boolean
    githubUrl?: string | null
    liveUrl?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: ProjectMediaUncheckedCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorUncheckedCreateNestedManyWithoutProjectInput
    endorsements?: EndorsementUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSkillsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSkillsInput, ProjectUncheckedCreateWithoutSkillsInput>
  }

  export type SkillCreateWithoutProjectSkillsInput = {
    id?: string
    name: string
    category: $Enums.SkillCategory
    description?: string | null
    verified?: boolean
    trending?: boolean
    userSkills?: UserSkillCreateNestedManyWithoutSkillInput
    credentialSkills?: CredentialSkillCreateNestedManyWithoutSkillInput
    opportunitySkills?: OpportunitySkillCreateNestedManyWithoutSkillInput
    courseSkills?: CourseSkillCreateNestedManyWithoutSkillInput
    trendingData?: TrendingSkillCreateNestedOneWithoutSkillInput
    skillGaps?: SkillGapCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutProjectSkillsInput = {
    id?: string
    name: string
    category: $Enums.SkillCategory
    description?: string | null
    verified?: boolean
    trending?: boolean
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutSkillInput
    credentialSkills?: CredentialSkillUncheckedCreateNestedManyWithoutSkillInput
    opportunitySkills?: OpportunitySkillUncheckedCreateNestedManyWithoutSkillInput
    courseSkills?: CourseSkillUncheckedCreateNestedManyWithoutSkillInput
    trendingData?: TrendingSkillUncheckedCreateNestedOneWithoutSkillInput
    skillGaps?: SkillGapUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutProjectSkillsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutProjectSkillsInput, SkillUncheckedCreateWithoutProjectSkillsInput>
  }

  export type ProjectUpsertWithoutSkillsInput = {
    update: XOR<ProjectUpdateWithoutSkillsInput, ProjectUncheckedUpdateWithoutSkillsInput>
    create: XOR<ProjectCreateWithoutSkillsInput, ProjectUncheckedCreateWithoutSkillsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSkillsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSkillsInput, ProjectUncheckedUpdateWithoutSkillsInput>
  }

  export type ProjectUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    visibility?: EnumProjectVisibilityFieldUpdateOperationsInput | $Enums.ProjectVisibility
    verified?: BoolFieldUpdateOperationsInput | boolean
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    media?: ProjectMediaUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUpdateManyWithoutProjectNestedInput
    endorsements?: EndorsementUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    visibility?: EnumProjectVisibilityFieldUpdateOperationsInput | $Enums.ProjectVisibility
    verified?: BoolFieldUpdateOperationsInput | boolean
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: ProjectMediaUncheckedUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUncheckedUpdateManyWithoutProjectNestedInput
    endorsements?: EndorsementUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type SkillUpsertWithoutProjectSkillsInput = {
    update: XOR<SkillUpdateWithoutProjectSkillsInput, SkillUncheckedUpdateWithoutProjectSkillsInput>
    create: XOR<SkillCreateWithoutProjectSkillsInput, SkillUncheckedCreateWithoutProjectSkillsInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutProjectSkillsInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutProjectSkillsInput, SkillUncheckedUpdateWithoutProjectSkillsInput>
  }

  export type SkillUpdateWithoutProjectSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    userSkills?: UserSkillUpdateManyWithoutSkillNestedInput
    credentialSkills?: CredentialSkillUpdateManyWithoutSkillNestedInput
    opportunitySkills?: OpportunitySkillUpdateManyWithoutSkillNestedInput
    courseSkills?: CourseSkillUpdateManyWithoutSkillNestedInput
    trendingData?: TrendingSkillUpdateOneWithoutSkillNestedInput
    skillGaps?: SkillGapUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutProjectSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    userSkills?: UserSkillUncheckedUpdateManyWithoutSkillNestedInput
    credentialSkills?: CredentialSkillUncheckedUpdateManyWithoutSkillNestedInput
    opportunitySkills?: OpportunitySkillUncheckedUpdateManyWithoutSkillNestedInput
    courseSkills?: CourseSkillUncheckedUpdateManyWithoutSkillNestedInput
    trendingData?: TrendingSkillUncheckedUpdateOneWithoutSkillNestedInput
    skillGaps?: SkillGapUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type ProjectCreateWithoutCollaboratorsInput = {
    id?: string
    title: string
    description: string
    visibility: $Enums.ProjectVisibility
    verified?: boolean
    githubUrl?: string | null
    liveUrl?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    media?: ProjectMediaCreateNestedManyWithoutProjectInput
    skills?: ProjectSkillCreateNestedManyWithoutProjectInput
    endorsements?: EndorsementCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCollaboratorsInput = {
    id?: string
    userId: string
    title: string
    description: string
    visibility: $Enums.ProjectVisibility
    verified?: boolean
    githubUrl?: string | null
    liveUrl?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: ProjectMediaUncheckedCreateNestedManyWithoutProjectInput
    skills?: ProjectSkillUncheckedCreateNestedManyWithoutProjectInput
    endorsements?: EndorsementUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCollaboratorsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCollaboratorsInput, ProjectUncheckedCreateWithoutCollaboratorsInput>
  }

  export type UserCreateWithoutProjectCollaborationsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileCreateNestedOneWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    credentials?: CredentialCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    applications?: ApplicationCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathCreateNestedManyWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    endorsements?: EndorsementCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestCreateNestedManyWithoutRequesterInput
  }

  export type UserUncheckedCreateWithoutProjectCollaborationsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileUncheckedCreateNestedOneWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    credentials?: CredentialUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionUncheckedCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionUncheckedCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestUncheckedCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestUncheckedCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    endorsements?: EndorsementUncheckedCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type UserCreateOrConnectWithoutProjectCollaborationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectCollaborationsInput, UserUncheckedCreateWithoutProjectCollaborationsInput>
  }

  export type ProjectUpsertWithoutCollaboratorsInput = {
    update: XOR<ProjectUpdateWithoutCollaboratorsInput, ProjectUncheckedUpdateWithoutCollaboratorsInput>
    create: XOR<ProjectCreateWithoutCollaboratorsInput, ProjectUncheckedCreateWithoutCollaboratorsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutCollaboratorsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutCollaboratorsInput, ProjectUncheckedUpdateWithoutCollaboratorsInput>
  }

  export type ProjectUpdateWithoutCollaboratorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    visibility?: EnumProjectVisibilityFieldUpdateOperationsInput | $Enums.ProjectVisibility
    verified?: BoolFieldUpdateOperationsInput | boolean
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    media?: ProjectMediaUpdateManyWithoutProjectNestedInput
    skills?: ProjectSkillUpdateManyWithoutProjectNestedInput
    endorsements?: EndorsementUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCollaboratorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    visibility?: EnumProjectVisibilityFieldUpdateOperationsInput | $Enums.ProjectVisibility
    verified?: BoolFieldUpdateOperationsInput | boolean
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: ProjectMediaUncheckedUpdateManyWithoutProjectNestedInput
    skills?: ProjectSkillUncheckedUpdateManyWithoutProjectNestedInput
    endorsements?: EndorsementUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutProjectCollaborationsInput = {
    update: XOR<UserUpdateWithoutProjectCollaborationsInput, UserUncheckedUpdateWithoutProjectCollaborationsInput>
    create: XOR<UserCreateWithoutProjectCollaborationsInput, UserUncheckedCreateWithoutProjectCollaborationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectCollaborationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectCollaborationsInput, UserUncheckedUpdateWithoutProjectCollaborationsInput>
  }

  export type UserUpdateWithoutProjectCollaborationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    credentials?: CredentialUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    applications?: ApplicationUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    endorsements?: EndorsementUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUpdateManyWithoutRequesterNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectCollaborationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUncheckedUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    credentials?: CredentialUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUncheckedUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUncheckedUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUncheckedUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUncheckedUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    endorsements?: EndorsementUncheckedUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUncheckedUpdateManyWithoutRequesterNestedInput
  }

  export type UserCreateWithoutEndorsementsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileCreateNestedOneWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    credentials?: CredentialCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    applications?: ApplicationCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathCreateNestedManyWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    verificationRequests?: VerificationRequestCreateNestedManyWithoutRequesterInput
  }

  export type UserUncheckedCreateWithoutEndorsementsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileUncheckedCreateNestedOneWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    credentials?: CredentialUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionUncheckedCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionUncheckedCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestUncheckedCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestUncheckedCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    verificationRequests?: VerificationRequestUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type UserCreateOrConnectWithoutEndorsementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEndorsementsInput, UserUncheckedCreateWithoutEndorsementsInput>
  }

  export type ProjectCreateWithoutEndorsementsInput = {
    id?: string
    title: string
    description: string
    visibility: $Enums.ProjectVisibility
    verified?: boolean
    githubUrl?: string | null
    liveUrl?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    media?: ProjectMediaCreateNestedManyWithoutProjectInput
    skills?: ProjectSkillCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutEndorsementsInput = {
    id?: string
    userId: string
    title: string
    description: string
    visibility: $Enums.ProjectVisibility
    verified?: boolean
    githubUrl?: string | null
    liveUrl?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: ProjectMediaUncheckedCreateNestedManyWithoutProjectInput
    skills?: ProjectSkillUncheckedCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutEndorsementsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutEndorsementsInput, ProjectUncheckedCreateWithoutEndorsementsInput>
  }

  export type UserUpsertWithoutEndorsementsInput = {
    update: XOR<UserUpdateWithoutEndorsementsInput, UserUncheckedUpdateWithoutEndorsementsInput>
    create: XOR<UserCreateWithoutEndorsementsInput, UserUncheckedCreateWithoutEndorsementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEndorsementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEndorsementsInput, UserUncheckedUpdateWithoutEndorsementsInput>
  }

  export type UserUpdateWithoutEndorsementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    credentials?: CredentialUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    applications?: ApplicationUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    verificationRequests?: VerificationRequestUpdateManyWithoutRequesterNestedInput
  }

  export type UserUncheckedUpdateWithoutEndorsementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUncheckedUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    credentials?: CredentialUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUncheckedUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUncheckedUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUncheckedUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUncheckedUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    verificationRequests?: VerificationRequestUncheckedUpdateManyWithoutRequesterNestedInput
  }

  export type ProjectUpsertWithoutEndorsementsInput = {
    update: XOR<ProjectUpdateWithoutEndorsementsInput, ProjectUncheckedUpdateWithoutEndorsementsInput>
    create: XOR<ProjectCreateWithoutEndorsementsInput, ProjectUncheckedCreateWithoutEndorsementsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutEndorsementsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutEndorsementsInput, ProjectUncheckedUpdateWithoutEndorsementsInput>
  }

  export type ProjectUpdateWithoutEndorsementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    visibility?: EnumProjectVisibilityFieldUpdateOperationsInput | $Enums.ProjectVisibility
    verified?: BoolFieldUpdateOperationsInput | boolean
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    media?: ProjectMediaUpdateManyWithoutProjectNestedInput
    skills?: ProjectSkillUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutEndorsementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    visibility?: EnumProjectVisibilityFieldUpdateOperationsInput | $Enums.ProjectVisibility
    verified?: BoolFieldUpdateOperationsInput | boolean
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: ProjectMediaUncheckedUpdateManyWithoutProjectNestedInput
    skills?: ProjectSkillUncheckedUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type OpportunityRequirementCreateWithoutOpportunityInput = {
    id?: string
    requirement: string
    displayOrder?: number
  }

  export type OpportunityRequirementUncheckedCreateWithoutOpportunityInput = {
    id?: string
    requirement: string
    displayOrder?: number
  }

  export type OpportunityRequirementCreateOrConnectWithoutOpportunityInput = {
    where: OpportunityRequirementWhereUniqueInput
    create: XOR<OpportunityRequirementCreateWithoutOpportunityInput, OpportunityRequirementUncheckedCreateWithoutOpportunityInput>
  }

  export type OpportunityRequirementCreateManyOpportunityInputEnvelope = {
    data: OpportunityRequirementCreateManyOpportunityInput | OpportunityRequirementCreateManyOpportunityInput[]
    skipDuplicates?: boolean
  }

  export type OpportunitySkillCreateWithoutOpportunityInput = {
    skill: SkillCreateNestedOneWithoutOpportunitySkillsInput
  }

  export type OpportunitySkillUncheckedCreateWithoutOpportunityInput = {
    skillId: string
  }

  export type OpportunitySkillCreateOrConnectWithoutOpportunityInput = {
    where: OpportunitySkillWhereUniqueInput
    create: XOR<OpportunitySkillCreateWithoutOpportunityInput, OpportunitySkillUncheckedCreateWithoutOpportunityInput>
  }

  export type OpportunitySkillCreateManyOpportunityInputEnvelope = {
    data: OpportunitySkillCreateManyOpportunityInput | OpportunitySkillCreateManyOpportunityInput[]
    skipDuplicates?: boolean
  }

  export type ApplicationCreateWithoutOpportunityInput = {
    id?: string
    status: $Enums.ApplicationStatus
    coverLetter?: string | null
    resumeUrl?: string | null
    appliedAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutApplicationsInput
  }

  export type ApplicationUncheckedCreateWithoutOpportunityInput = {
    id?: string
    userId: string
    status: $Enums.ApplicationStatus
    coverLetter?: string | null
    resumeUrl?: string | null
    appliedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApplicationCreateOrConnectWithoutOpportunityInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutOpportunityInput, ApplicationUncheckedCreateWithoutOpportunityInput>
  }

  export type ApplicationCreateManyOpportunityInputEnvelope = {
    data: ApplicationCreateManyOpportunityInput | ApplicationCreateManyOpportunityInput[]
    skipDuplicates?: boolean
  }

  export type OpportunityRequirementUpsertWithWhereUniqueWithoutOpportunityInput = {
    where: OpportunityRequirementWhereUniqueInput
    update: XOR<OpportunityRequirementUpdateWithoutOpportunityInput, OpportunityRequirementUncheckedUpdateWithoutOpportunityInput>
    create: XOR<OpportunityRequirementCreateWithoutOpportunityInput, OpportunityRequirementUncheckedCreateWithoutOpportunityInput>
  }

  export type OpportunityRequirementUpdateWithWhereUniqueWithoutOpportunityInput = {
    where: OpportunityRequirementWhereUniqueInput
    data: XOR<OpportunityRequirementUpdateWithoutOpportunityInput, OpportunityRequirementUncheckedUpdateWithoutOpportunityInput>
  }

  export type OpportunityRequirementUpdateManyWithWhereWithoutOpportunityInput = {
    where: OpportunityRequirementScalarWhereInput
    data: XOR<OpportunityRequirementUpdateManyMutationInput, OpportunityRequirementUncheckedUpdateManyWithoutOpportunityInput>
  }

  export type OpportunityRequirementScalarWhereInput = {
    AND?: OpportunityRequirementScalarWhereInput | OpportunityRequirementScalarWhereInput[]
    OR?: OpportunityRequirementScalarWhereInput[]
    NOT?: OpportunityRequirementScalarWhereInput | OpportunityRequirementScalarWhereInput[]
    id?: StringFilter<"OpportunityRequirement"> | string
    opportunityId?: StringFilter<"OpportunityRequirement"> | string
    requirement?: StringFilter<"OpportunityRequirement"> | string
    displayOrder?: IntFilter<"OpportunityRequirement"> | number
  }

  export type OpportunitySkillUpsertWithWhereUniqueWithoutOpportunityInput = {
    where: OpportunitySkillWhereUniqueInput
    update: XOR<OpportunitySkillUpdateWithoutOpportunityInput, OpportunitySkillUncheckedUpdateWithoutOpportunityInput>
    create: XOR<OpportunitySkillCreateWithoutOpportunityInput, OpportunitySkillUncheckedCreateWithoutOpportunityInput>
  }

  export type OpportunitySkillUpdateWithWhereUniqueWithoutOpportunityInput = {
    where: OpportunitySkillWhereUniqueInput
    data: XOR<OpportunitySkillUpdateWithoutOpportunityInput, OpportunitySkillUncheckedUpdateWithoutOpportunityInput>
  }

  export type OpportunitySkillUpdateManyWithWhereWithoutOpportunityInput = {
    where: OpportunitySkillScalarWhereInput
    data: XOR<OpportunitySkillUpdateManyMutationInput, OpportunitySkillUncheckedUpdateManyWithoutOpportunityInput>
  }

  export type ApplicationUpsertWithWhereUniqueWithoutOpportunityInput = {
    where: ApplicationWhereUniqueInput
    update: XOR<ApplicationUpdateWithoutOpportunityInput, ApplicationUncheckedUpdateWithoutOpportunityInput>
    create: XOR<ApplicationCreateWithoutOpportunityInput, ApplicationUncheckedCreateWithoutOpportunityInput>
  }

  export type ApplicationUpdateWithWhereUniqueWithoutOpportunityInput = {
    where: ApplicationWhereUniqueInput
    data: XOR<ApplicationUpdateWithoutOpportunityInput, ApplicationUncheckedUpdateWithoutOpportunityInput>
  }

  export type ApplicationUpdateManyWithWhereWithoutOpportunityInput = {
    where: ApplicationScalarWhereInput
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyWithoutOpportunityInput>
  }

  export type OpportunityCreateWithoutRequirementsInput = {
    id?: string
    title: string
    company: string
    companyLogo?: string | null
    type: $Enums.OpportunityType
    location: string
    remote?: boolean
    description: string
    salaryMin?: bigint | number | null
    salaryMax?: bigint | number | null
    postedDate: Date | string
    deadline?: Date | string | null
    applicationUrl?: string | null
    createdAt?: Date | string
    skills?: OpportunitySkillCreateNestedManyWithoutOpportunityInput
    applications?: ApplicationCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutRequirementsInput = {
    id?: string
    title: string
    company: string
    companyLogo?: string | null
    type: $Enums.OpportunityType
    location: string
    remote?: boolean
    description: string
    salaryMin?: bigint | number | null
    salaryMax?: bigint | number | null
    postedDate: Date | string
    deadline?: Date | string | null
    applicationUrl?: string | null
    createdAt?: Date | string
    skills?: OpportunitySkillUncheckedCreateNestedManyWithoutOpportunityInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutRequirementsInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutRequirementsInput, OpportunityUncheckedCreateWithoutRequirementsInput>
  }

  export type OpportunityUpsertWithoutRequirementsInput = {
    update: XOR<OpportunityUpdateWithoutRequirementsInput, OpportunityUncheckedUpdateWithoutRequirementsInput>
    create: XOR<OpportunityCreateWithoutRequirementsInput, OpportunityUncheckedCreateWithoutRequirementsInput>
    where?: OpportunityWhereInput
  }

  export type OpportunityUpdateToOneWithWhereWithoutRequirementsInput = {
    where?: OpportunityWhereInput
    data: XOR<OpportunityUpdateWithoutRequirementsInput, OpportunityUncheckedUpdateWithoutRequirementsInput>
  }

  export type OpportunityUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOpportunityTypeFieldUpdateOperationsInput | $Enums.OpportunityType
    location?: StringFieldUpdateOperationsInput | string
    remote?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    salaryMin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salaryMax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    postedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: OpportunitySkillUpdateManyWithoutOpportunityNestedInput
    applications?: ApplicationUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOpportunityTypeFieldUpdateOperationsInput | $Enums.OpportunityType
    location?: StringFieldUpdateOperationsInput | string
    remote?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    salaryMin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salaryMax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    postedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: OpportunitySkillUncheckedUpdateManyWithoutOpportunityNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityCreateWithoutSkillsInput = {
    id?: string
    title: string
    company: string
    companyLogo?: string | null
    type: $Enums.OpportunityType
    location: string
    remote?: boolean
    description: string
    salaryMin?: bigint | number | null
    salaryMax?: bigint | number | null
    postedDate: Date | string
    deadline?: Date | string | null
    applicationUrl?: string | null
    createdAt?: Date | string
    requirements?: OpportunityRequirementCreateNestedManyWithoutOpportunityInput
    applications?: ApplicationCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutSkillsInput = {
    id?: string
    title: string
    company: string
    companyLogo?: string | null
    type: $Enums.OpportunityType
    location: string
    remote?: boolean
    description: string
    salaryMin?: bigint | number | null
    salaryMax?: bigint | number | null
    postedDate: Date | string
    deadline?: Date | string | null
    applicationUrl?: string | null
    createdAt?: Date | string
    requirements?: OpportunityRequirementUncheckedCreateNestedManyWithoutOpportunityInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutSkillsInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutSkillsInput, OpportunityUncheckedCreateWithoutSkillsInput>
  }

  export type SkillCreateWithoutOpportunitySkillsInput = {
    id?: string
    name: string
    category: $Enums.SkillCategory
    description?: string | null
    verified?: boolean
    trending?: boolean
    userSkills?: UserSkillCreateNestedManyWithoutSkillInput
    credentialSkills?: CredentialSkillCreateNestedManyWithoutSkillInput
    projectSkills?: ProjectSkillCreateNestedManyWithoutSkillInput
    courseSkills?: CourseSkillCreateNestedManyWithoutSkillInput
    trendingData?: TrendingSkillCreateNestedOneWithoutSkillInput
    skillGaps?: SkillGapCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutOpportunitySkillsInput = {
    id?: string
    name: string
    category: $Enums.SkillCategory
    description?: string | null
    verified?: boolean
    trending?: boolean
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutSkillInput
    credentialSkills?: CredentialSkillUncheckedCreateNestedManyWithoutSkillInput
    projectSkills?: ProjectSkillUncheckedCreateNestedManyWithoutSkillInput
    courseSkills?: CourseSkillUncheckedCreateNestedManyWithoutSkillInput
    trendingData?: TrendingSkillUncheckedCreateNestedOneWithoutSkillInput
    skillGaps?: SkillGapUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutOpportunitySkillsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutOpportunitySkillsInput, SkillUncheckedCreateWithoutOpportunitySkillsInput>
  }

  export type OpportunityUpsertWithoutSkillsInput = {
    update: XOR<OpportunityUpdateWithoutSkillsInput, OpportunityUncheckedUpdateWithoutSkillsInput>
    create: XOR<OpportunityCreateWithoutSkillsInput, OpportunityUncheckedCreateWithoutSkillsInput>
    where?: OpportunityWhereInput
  }

  export type OpportunityUpdateToOneWithWhereWithoutSkillsInput = {
    where?: OpportunityWhereInput
    data: XOR<OpportunityUpdateWithoutSkillsInput, OpportunityUncheckedUpdateWithoutSkillsInput>
  }

  export type OpportunityUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOpportunityTypeFieldUpdateOperationsInput | $Enums.OpportunityType
    location?: StringFieldUpdateOperationsInput | string
    remote?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    salaryMin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salaryMax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    postedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirements?: OpportunityRequirementUpdateManyWithoutOpportunityNestedInput
    applications?: ApplicationUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOpportunityTypeFieldUpdateOperationsInput | $Enums.OpportunityType
    location?: StringFieldUpdateOperationsInput | string
    remote?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    salaryMin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salaryMax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    postedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirements?: OpportunityRequirementUncheckedUpdateManyWithoutOpportunityNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type SkillUpsertWithoutOpportunitySkillsInput = {
    update: XOR<SkillUpdateWithoutOpportunitySkillsInput, SkillUncheckedUpdateWithoutOpportunitySkillsInput>
    create: XOR<SkillCreateWithoutOpportunitySkillsInput, SkillUncheckedCreateWithoutOpportunitySkillsInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutOpportunitySkillsInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutOpportunitySkillsInput, SkillUncheckedUpdateWithoutOpportunitySkillsInput>
  }

  export type SkillUpdateWithoutOpportunitySkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    userSkills?: UserSkillUpdateManyWithoutSkillNestedInput
    credentialSkills?: CredentialSkillUpdateManyWithoutSkillNestedInput
    projectSkills?: ProjectSkillUpdateManyWithoutSkillNestedInput
    courseSkills?: CourseSkillUpdateManyWithoutSkillNestedInput
    trendingData?: TrendingSkillUpdateOneWithoutSkillNestedInput
    skillGaps?: SkillGapUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutOpportunitySkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    userSkills?: UserSkillUncheckedUpdateManyWithoutSkillNestedInput
    credentialSkills?: CredentialSkillUncheckedUpdateManyWithoutSkillNestedInput
    projectSkills?: ProjectSkillUncheckedUpdateManyWithoutSkillNestedInput
    courseSkills?: CourseSkillUncheckedUpdateManyWithoutSkillNestedInput
    trendingData?: TrendingSkillUncheckedUpdateOneWithoutSkillNestedInput
    skillGaps?: SkillGapUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type UserCreateWithoutApplicationsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileCreateNestedOneWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    credentials?: CredentialCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathCreateNestedManyWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    endorsements?: EndorsementCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestCreateNestedManyWithoutRequesterInput
  }

  export type UserUncheckedCreateWithoutApplicationsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileUncheckedCreateNestedOneWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    credentials?: CredentialUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionUncheckedCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionUncheckedCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestUncheckedCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestUncheckedCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    endorsements?: EndorsementUncheckedCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type UserCreateOrConnectWithoutApplicationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
  }

  export type OpportunityCreateWithoutApplicationsInput = {
    id?: string
    title: string
    company: string
    companyLogo?: string | null
    type: $Enums.OpportunityType
    location: string
    remote?: boolean
    description: string
    salaryMin?: bigint | number | null
    salaryMax?: bigint | number | null
    postedDate: Date | string
    deadline?: Date | string | null
    applicationUrl?: string | null
    createdAt?: Date | string
    requirements?: OpportunityRequirementCreateNestedManyWithoutOpportunityInput
    skills?: OpportunitySkillCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutApplicationsInput = {
    id?: string
    title: string
    company: string
    companyLogo?: string | null
    type: $Enums.OpportunityType
    location: string
    remote?: boolean
    description: string
    salaryMin?: bigint | number | null
    salaryMax?: bigint | number | null
    postedDate: Date | string
    deadline?: Date | string | null
    applicationUrl?: string | null
    createdAt?: Date | string
    requirements?: OpportunityRequirementUncheckedCreateNestedManyWithoutOpportunityInput
    skills?: OpportunitySkillUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutApplicationsInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutApplicationsInput, OpportunityUncheckedCreateWithoutApplicationsInput>
  }

  export type UserUpsertWithoutApplicationsInput = {
    update: XOR<UserUpdateWithoutApplicationsInput, UserUncheckedUpdateWithoutApplicationsInput>
    create: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApplicationsInput, UserUncheckedUpdateWithoutApplicationsInput>
  }

  export type UserUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    credentials?: CredentialUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUpdateManyWithoutRequesterNestedInput
  }

  export type UserUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUncheckedUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    credentials?: CredentialUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUncheckedUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUncheckedUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUncheckedUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUncheckedUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUncheckedUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUncheckedUpdateManyWithoutRequesterNestedInput
  }

  export type OpportunityUpsertWithoutApplicationsInput = {
    update: XOR<OpportunityUpdateWithoutApplicationsInput, OpportunityUncheckedUpdateWithoutApplicationsInput>
    create: XOR<OpportunityCreateWithoutApplicationsInput, OpportunityUncheckedCreateWithoutApplicationsInput>
    where?: OpportunityWhereInput
  }

  export type OpportunityUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: OpportunityWhereInput
    data: XOR<OpportunityUpdateWithoutApplicationsInput, OpportunityUncheckedUpdateWithoutApplicationsInput>
  }

  export type OpportunityUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOpportunityTypeFieldUpdateOperationsInput | $Enums.OpportunityType
    location?: StringFieldUpdateOperationsInput | string
    remote?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    salaryMin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salaryMax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    postedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirements?: OpportunityRequirementUpdateManyWithoutOpportunityNestedInput
    skills?: OpportunitySkillUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOpportunityTypeFieldUpdateOperationsInput | $Enums.OpportunityType
    location?: StringFieldUpdateOperationsInput | string
    remote?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    salaryMin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salaryMax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    postedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirements?: OpportunityRequirementUncheckedUpdateManyWithoutOpportunityNestedInput
    skills?: OpportunitySkillUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type UserCreateWithoutConnectionsSentInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileCreateNestedOneWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    credentials?: CredentialCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    applications?: ApplicationCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathCreateNestedManyWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    endorsements?: EndorsementCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestCreateNestedManyWithoutRequesterInput
  }

  export type UserUncheckedCreateWithoutConnectionsSentInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileUncheckedCreateNestedOneWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    credentials?: CredentialUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionUncheckedCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestUncheckedCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestUncheckedCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    endorsements?: EndorsementUncheckedCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type UserCreateOrConnectWithoutConnectionsSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConnectionsSentInput, UserUncheckedCreateWithoutConnectionsSentInput>
  }

  export type UserCreateWithoutConnectionsReceivedInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileCreateNestedOneWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    credentials?: CredentialCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    applications?: ApplicationCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionCreateNestedManyWithoutUserInput
    connectionRequestsSent?: ConnectionRequestCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathCreateNestedManyWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    endorsements?: EndorsementCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestCreateNestedManyWithoutRequesterInput
  }

  export type UserUncheckedCreateWithoutConnectionsReceivedInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileUncheckedCreateNestedOneWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    credentials?: CredentialUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionUncheckedCreateNestedManyWithoutUserInput
    connectionRequestsSent?: ConnectionRequestUncheckedCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestUncheckedCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    endorsements?: EndorsementUncheckedCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type UserCreateOrConnectWithoutConnectionsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConnectionsReceivedInput, UserUncheckedCreateWithoutConnectionsReceivedInput>
  }

  export type UserUpsertWithoutConnectionsSentInput = {
    update: XOR<UserUpdateWithoutConnectionsSentInput, UserUncheckedUpdateWithoutConnectionsSentInput>
    create: XOR<UserCreateWithoutConnectionsSentInput, UserUncheckedCreateWithoutConnectionsSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConnectionsSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConnectionsSentInput, UserUncheckedUpdateWithoutConnectionsSentInput>
  }

  export type UserUpdateWithoutConnectionsSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    credentials?: CredentialUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    applications?: ApplicationUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUpdateManyWithoutRequesterNestedInput
  }

  export type UserUncheckedUpdateWithoutConnectionsSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUncheckedUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    credentials?: CredentialUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUncheckedUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUncheckedUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUncheckedUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUncheckedUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUncheckedUpdateManyWithoutRequesterNestedInput
  }

  export type UserUpsertWithoutConnectionsReceivedInput = {
    update: XOR<UserUpdateWithoutConnectionsReceivedInput, UserUncheckedUpdateWithoutConnectionsReceivedInput>
    create: XOR<UserCreateWithoutConnectionsReceivedInput, UserUncheckedCreateWithoutConnectionsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConnectionsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConnectionsReceivedInput, UserUncheckedUpdateWithoutConnectionsReceivedInput>
  }

  export type UserUpdateWithoutConnectionsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    credentials?: CredentialUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    applications?: ApplicationUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUpdateManyWithoutUserNestedInput
    connectionRequestsSent?: ConnectionRequestUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUpdateManyWithoutRequesterNestedInput
  }

  export type UserUncheckedUpdateWithoutConnectionsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUncheckedUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    credentials?: CredentialUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUncheckedUpdateManyWithoutUserNestedInput
    connectionRequestsSent?: ConnectionRequestUncheckedUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUncheckedUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUncheckedUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUncheckedUpdateManyWithoutRequesterNestedInput
  }

  export type UserCreateWithoutConnectionRequestsSentInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileCreateNestedOneWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    credentials?: CredentialCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    applications?: ApplicationCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionCreateNestedManyWithoutConnectedUserInput
    connectionRequestsReceived?: ConnectionRequestCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathCreateNestedManyWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    endorsements?: EndorsementCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestCreateNestedManyWithoutRequesterInput
  }

  export type UserUncheckedCreateWithoutConnectionRequestsSentInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileUncheckedCreateNestedOneWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    credentials?: CredentialUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionUncheckedCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionUncheckedCreateNestedManyWithoutConnectedUserInput
    connectionRequestsReceived?: ConnectionRequestUncheckedCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    endorsements?: EndorsementUncheckedCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type UserCreateOrConnectWithoutConnectionRequestsSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConnectionRequestsSentInput, UserUncheckedCreateWithoutConnectionRequestsSentInput>
  }

  export type UserCreateWithoutConnectionRequestsReceivedInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileCreateNestedOneWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    credentials?: CredentialCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    applications?: ApplicationCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestCreateNestedManyWithoutSenderInput
    feedItems?: FeedItemCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathCreateNestedManyWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    endorsements?: EndorsementCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestCreateNestedManyWithoutRequesterInput
  }

  export type UserUncheckedCreateWithoutConnectionRequestsReceivedInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileUncheckedCreateNestedOneWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    credentials?: CredentialUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionUncheckedCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionUncheckedCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestUncheckedCreateNestedManyWithoutSenderInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    endorsements?: EndorsementUncheckedCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type UserCreateOrConnectWithoutConnectionRequestsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConnectionRequestsReceivedInput, UserUncheckedCreateWithoutConnectionRequestsReceivedInput>
  }

  export type UserUpsertWithoutConnectionRequestsSentInput = {
    update: XOR<UserUpdateWithoutConnectionRequestsSentInput, UserUncheckedUpdateWithoutConnectionRequestsSentInput>
    create: XOR<UserCreateWithoutConnectionRequestsSentInput, UserUncheckedCreateWithoutConnectionRequestsSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConnectionRequestsSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConnectionRequestsSentInput, UserUncheckedUpdateWithoutConnectionRequestsSentInput>
  }

  export type UserUpdateWithoutConnectionRequestsSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    credentials?: CredentialUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    applications?: ApplicationUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsReceived?: ConnectionRequestUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUpdateManyWithoutRequesterNestedInput
  }

  export type UserUncheckedUpdateWithoutConnectionRequestsSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUncheckedUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    credentials?: CredentialUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUncheckedUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUncheckedUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsReceived?: ConnectionRequestUncheckedUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUncheckedUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUncheckedUpdateManyWithoutRequesterNestedInput
  }

  export type UserUpsertWithoutConnectionRequestsReceivedInput = {
    update: XOR<UserUpdateWithoutConnectionRequestsReceivedInput, UserUncheckedUpdateWithoutConnectionRequestsReceivedInput>
    create: XOR<UserCreateWithoutConnectionRequestsReceivedInput, UserUncheckedCreateWithoutConnectionRequestsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConnectionRequestsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConnectionRequestsReceivedInput, UserUncheckedUpdateWithoutConnectionRequestsReceivedInput>
  }

  export type UserUpdateWithoutConnectionRequestsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    credentials?: CredentialUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    applications?: ApplicationUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUpdateManyWithoutSenderNestedInput
    feedItems?: FeedItemUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUpdateManyWithoutRequesterNestedInput
  }

  export type UserUncheckedUpdateWithoutConnectionRequestsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUncheckedUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    credentials?: CredentialUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUncheckedUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUncheckedUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUncheckedUpdateManyWithoutSenderNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUncheckedUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUncheckedUpdateManyWithoutRequesterNestedInput
  }

  export type UserCreateWithoutFeedItemsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileCreateNestedOneWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    credentials?: CredentialCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    applications?: ApplicationCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestCreateNestedManyWithoutReceiverInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathCreateNestedManyWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    endorsements?: EndorsementCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestCreateNestedManyWithoutRequesterInput
  }

  export type UserUncheckedCreateWithoutFeedItemsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileUncheckedCreateNestedOneWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    credentials?: CredentialUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionUncheckedCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionUncheckedCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestUncheckedCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestUncheckedCreateNestedManyWithoutReceiverInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    endorsements?: EndorsementUncheckedCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type UserCreateOrConnectWithoutFeedItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedItemsInput, UserUncheckedCreateWithoutFeedItemsInput>
  }

  export type UserUpsertWithoutFeedItemsInput = {
    update: XOR<UserUpdateWithoutFeedItemsInput, UserUncheckedUpdateWithoutFeedItemsInput>
    create: XOR<UserCreateWithoutFeedItemsInput, UserUncheckedCreateWithoutFeedItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedItemsInput, UserUncheckedUpdateWithoutFeedItemsInput>
  }

  export type UserUpdateWithoutFeedItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    credentials?: CredentialUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    applications?: ApplicationUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUpdateManyWithoutReceiverNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUpdateManyWithoutRequesterNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUncheckedUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    credentials?: CredentialUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUncheckedUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUncheckedUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUncheckedUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUncheckedUpdateManyWithoutReceiverNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUncheckedUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUncheckedUpdateManyWithoutRequesterNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileCreateNestedOneWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    credentials?: CredentialCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    applications?: ApplicationCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathCreateNestedManyWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    endorsements?: EndorsementCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestCreateNestedManyWithoutRequesterInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileUncheckedCreateNestedOneWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    credentials?: CredentialUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionUncheckedCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionUncheckedCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestUncheckedCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestUncheckedCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    endorsements?: EndorsementUncheckedCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    credentials?: CredentialUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    applications?: ApplicationUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUpdateManyWithoutRequesterNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUncheckedUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    credentials?: CredentialUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUncheckedUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUncheckedUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUncheckedUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUncheckedUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUncheckedUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUncheckedUpdateManyWithoutRequesterNestedInput
  }

  export type UserCreateWithoutCareerPathsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileCreateNestedOneWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    credentials?: CredentialCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    applications?: ApplicationCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    endorsements?: EndorsementCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestCreateNestedManyWithoutRequesterInput
  }

  export type UserUncheckedCreateWithoutCareerPathsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileUncheckedCreateNestedOneWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    credentials?: CredentialUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionUncheckedCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionUncheckedCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestUncheckedCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestUncheckedCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    endorsements?: EndorsementUncheckedCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type UserCreateOrConnectWithoutCareerPathsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCareerPathsInput, UserUncheckedCreateWithoutCareerPathsInput>
  }

  export type CareerPathNodeCreateWithoutCareerPathInput = {
    id?: string
    stageNumber: number
    title: string
    duration: number
    completed?: boolean
  }

  export type CareerPathNodeUncheckedCreateWithoutCareerPathInput = {
    id?: string
    stageNumber: number
    title: string
    duration: number
    completed?: boolean
  }

  export type CareerPathNodeCreateOrConnectWithoutCareerPathInput = {
    where: CareerPathNodeWhereUniqueInput
    create: XOR<CareerPathNodeCreateWithoutCareerPathInput, CareerPathNodeUncheckedCreateWithoutCareerPathInput>
  }

  export type CareerPathNodeCreateManyCareerPathInputEnvelope = {
    data: CareerPathNodeCreateManyCareerPathInput | CareerPathNodeCreateManyCareerPathInput[]
    skipDuplicates?: boolean
  }

  export type SkillGapCreateWithoutCareerPathInput = {
    id?: string
    currentLevel: $Enums.SkillLevel
    targetLevel: $Enums.SkillLevel
    priority: $Enums.Priority
    skill: SkillCreateNestedOneWithoutSkillGapsInput
  }

  export type SkillGapUncheckedCreateWithoutCareerPathInput = {
    id?: string
    skillId: string
    currentLevel: $Enums.SkillLevel
    targetLevel: $Enums.SkillLevel
    priority: $Enums.Priority
  }

  export type SkillGapCreateOrConnectWithoutCareerPathInput = {
    where: SkillGapWhereUniqueInput
    create: XOR<SkillGapCreateWithoutCareerPathInput, SkillGapUncheckedCreateWithoutCareerPathInput>
  }

  export type SkillGapCreateManyCareerPathInputEnvelope = {
    data: SkillGapCreateManyCareerPathInput | SkillGapCreateManyCareerPathInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCareerPathsInput = {
    update: XOR<UserUpdateWithoutCareerPathsInput, UserUncheckedUpdateWithoutCareerPathsInput>
    create: XOR<UserCreateWithoutCareerPathsInput, UserUncheckedCreateWithoutCareerPathsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCareerPathsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCareerPathsInput, UserUncheckedUpdateWithoutCareerPathsInput>
  }

  export type UserUpdateWithoutCareerPathsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    credentials?: CredentialUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    applications?: ApplicationUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUpdateManyWithoutRequesterNestedInput
  }

  export type UserUncheckedUpdateWithoutCareerPathsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUncheckedUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    credentials?: CredentialUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUncheckedUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUncheckedUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUncheckedUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUncheckedUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUncheckedUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUncheckedUpdateManyWithoutRequesterNestedInput
  }

  export type CareerPathNodeUpsertWithWhereUniqueWithoutCareerPathInput = {
    where: CareerPathNodeWhereUniqueInput
    update: XOR<CareerPathNodeUpdateWithoutCareerPathInput, CareerPathNodeUncheckedUpdateWithoutCareerPathInput>
    create: XOR<CareerPathNodeCreateWithoutCareerPathInput, CareerPathNodeUncheckedCreateWithoutCareerPathInput>
  }

  export type CareerPathNodeUpdateWithWhereUniqueWithoutCareerPathInput = {
    where: CareerPathNodeWhereUniqueInput
    data: XOR<CareerPathNodeUpdateWithoutCareerPathInput, CareerPathNodeUncheckedUpdateWithoutCareerPathInput>
  }

  export type CareerPathNodeUpdateManyWithWhereWithoutCareerPathInput = {
    where: CareerPathNodeScalarWhereInput
    data: XOR<CareerPathNodeUpdateManyMutationInput, CareerPathNodeUncheckedUpdateManyWithoutCareerPathInput>
  }

  export type CareerPathNodeScalarWhereInput = {
    AND?: CareerPathNodeScalarWhereInput | CareerPathNodeScalarWhereInput[]
    OR?: CareerPathNodeScalarWhereInput[]
    NOT?: CareerPathNodeScalarWhereInput | CareerPathNodeScalarWhereInput[]
    id?: StringFilter<"CareerPathNode"> | string
    careerPathId?: StringFilter<"CareerPathNode"> | string
    stageNumber?: IntFilter<"CareerPathNode"> | number
    title?: StringFilter<"CareerPathNode"> | string
    duration?: IntFilter<"CareerPathNode"> | number
    completed?: BoolFilter<"CareerPathNode"> | boolean
  }

  export type SkillGapUpsertWithWhereUniqueWithoutCareerPathInput = {
    where: SkillGapWhereUniqueInput
    update: XOR<SkillGapUpdateWithoutCareerPathInput, SkillGapUncheckedUpdateWithoutCareerPathInput>
    create: XOR<SkillGapCreateWithoutCareerPathInput, SkillGapUncheckedCreateWithoutCareerPathInput>
  }

  export type SkillGapUpdateWithWhereUniqueWithoutCareerPathInput = {
    where: SkillGapWhereUniqueInput
    data: XOR<SkillGapUpdateWithoutCareerPathInput, SkillGapUncheckedUpdateWithoutCareerPathInput>
  }

  export type SkillGapUpdateManyWithWhereWithoutCareerPathInput = {
    where: SkillGapScalarWhereInput
    data: XOR<SkillGapUpdateManyMutationInput, SkillGapUncheckedUpdateManyWithoutCareerPathInput>
  }

  export type CareerPathCreateWithoutNodesInput = {
    id?: string
    currentRole: string
    targetRole: string
    estimatedDuration: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCareerPathsInput
    skillGaps?: SkillGapCreateNestedManyWithoutCareerPathInput
  }

  export type CareerPathUncheckedCreateWithoutNodesInput = {
    id?: string
    userId: string
    currentRole: string
    targetRole: string
    estimatedDuration: number
    createdAt?: Date | string
    skillGaps?: SkillGapUncheckedCreateNestedManyWithoutCareerPathInput
  }

  export type CareerPathCreateOrConnectWithoutNodesInput = {
    where: CareerPathWhereUniqueInput
    create: XOR<CareerPathCreateWithoutNodesInput, CareerPathUncheckedCreateWithoutNodesInput>
  }

  export type CareerPathUpsertWithoutNodesInput = {
    update: XOR<CareerPathUpdateWithoutNodesInput, CareerPathUncheckedUpdateWithoutNodesInput>
    create: XOR<CareerPathCreateWithoutNodesInput, CareerPathUncheckedCreateWithoutNodesInput>
    where?: CareerPathWhereInput
  }

  export type CareerPathUpdateToOneWithWhereWithoutNodesInput = {
    where?: CareerPathWhereInput
    data: XOR<CareerPathUpdateWithoutNodesInput, CareerPathUncheckedUpdateWithoutNodesInput>
  }

  export type CareerPathUpdateWithoutNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentRole?: StringFieldUpdateOperationsInput | string
    targetRole?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCareerPathsNestedInput
    skillGaps?: SkillGapUpdateManyWithoutCareerPathNestedInput
  }

  export type CareerPathUncheckedUpdateWithoutNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentRole?: StringFieldUpdateOperationsInput | string
    targetRole?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skillGaps?: SkillGapUncheckedUpdateManyWithoutCareerPathNestedInput
  }

  export type CareerPathCreateWithoutSkillGapsInput = {
    id?: string
    currentRole: string
    targetRole: string
    estimatedDuration: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCareerPathsInput
    nodes?: CareerPathNodeCreateNestedManyWithoutCareerPathInput
  }

  export type CareerPathUncheckedCreateWithoutSkillGapsInput = {
    id?: string
    userId: string
    currentRole: string
    targetRole: string
    estimatedDuration: number
    createdAt?: Date | string
    nodes?: CareerPathNodeUncheckedCreateNestedManyWithoutCareerPathInput
  }

  export type CareerPathCreateOrConnectWithoutSkillGapsInput = {
    where: CareerPathWhereUniqueInput
    create: XOR<CareerPathCreateWithoutSkillGapsInput, CareerPathUncheckedCreateWithoutSkillGapsInput>
  }

  export type SkillCreateWithoutSkillGapsInput = {
    id?: string
    name: string
    category: $Enums.SkillCategory
    description?: string | null
    verified?: boolean
    trending?: boolean
    userSkills?: UserSkillCreateNestedManyWithoutSkillInput
    credentialSkills?: CredentialSkillCreateNestedManyWithoutSkillInput
    projectSkills?: ProjectSkillCreateNestedManyWithoutSkillInput
    opportunitySkills?: OpportunitySkillCreateNestedManyWithoutSkillInput
    courseSkills?: CourseSkillCreateNestedManyWithoutSkillInput
    trendingData?: TrendingSkillCreateNestedOneWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutSkillGapsInput = {
    id?: string
    name: string
    category: $Enums.SkillCategory
    description?: string | null
    verified?: boolean
    trending?: boolean
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutSkillInput
    credentialSkills?: CredentialSkillUncheckedCreateNestedManyWithoutSkillInput
    projectSkills?: ProjectSkillUncheckedCreateNestedManyWithoutSkillInput
    opportunitySkills?: OpportunitySkillUncheckedCreateNestedManyWithoutSkillInput
    courseSkills?: CourseSkillUncheckedCreateNestedManyWithoutSkillInput
    trendingData?: TrendingSkillUncheckedCreateNestedOneWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutSkillGapsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutSkillGapsInput, SkillUncheckedCreateWithoutSkillGapsInput>
  }

  export type CareerPathUpsertWithoutSkillGapsInput = {
    update: XOR<CareerPathUpdateWithoutSkillGapsInput, CareerPathUncheckedUpdateWithoutSkillGapsInput>
    create: XOR<CareerPathCreateWithoutSkillGapsInput, CareerPathUncheckedCreateWithoutSkillGapsInput>
    where?: CareerPathWhereInput
  }

  export type CareerPathUpdateToOneWithWhereWithoutSkillGapsInput = {
    where?: CareerPathWhereInput
    data: XOR<CareerPathUpdateWithoutSkillGapsInput, CareerPathUncheckedUpdateWithoutSkillGapsInput>
  }

  export type CareerPathUpdateWithoutSkillGapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentRole?: StringFieldUpdateOperationsInput | string
    targetRole?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCareerPathsNestedInput
    nodes?: CareerPathNodeUpdateManyWithoutCareerPathNestedInput
  }

  export type CareerPathUncheckedUpdateWithoutSkillGapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentRole?: StringFieldUpdateOperationsInput | string
    targetRole?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: CareerPathNodeUncheckedUpdateManyWithoutCareerPathNestedInput
  }

  export type SkillUpsertWithoutSkillGapsInput = {
    update: XOR<SkillUpdateWithoutSkillGapsInput, SkillUncheckedUpdateWithoutSkillGapsInput>
    create: XOR<SkillCreateWithoutSkillGapsInput, SkillUncheckedCreateWithoutSkillGapsInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutSkillGapsInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutSkillGapsInput, SkillUncheckedUpdateWithoutSkillGapsInput>
  }

  export type SkillUpdateWithoutSkillGapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    userSkills?: UserSkillUpdateManyWithoutSkillNestedInput
    credentialSkills?: CredentialSkillUpdateManyWithoutSkillNestedInput
    projectSkills?: ProjectSkillUpdateManyWithoutSkillNestedInput
    opportunitySkills?: OpportunitySkillUpdateManyWithoutSkillNestedInput
    courseSkills?: CourseSkillUpdateManyWithoutSkillNestedInput
    trendingData?: TrendingSkillUpdateOneWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutSkillGapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    userSkills?: UserSkillUncheckedUpdateManyWithoutSkillNestedInput
    credentialSkills?: CredentialSkillUncheckedUpdateManyWithoutSkillNestedInput
    projectSkills?: ProjectSkillUncheckedUpdateManyWithoutSkillNestedInput
    opportunitySkills?: OpportunitySkillUncheckedUpdateManyWithoutSkillNestedInput
    courseSkills?: CourseSkillUncheckedUpdateManyWithoutSkillNestedInput
    trendingData?: TrendingSkillUncheckedUpdateOneWithoutSkillNestedInput
  }

  export type CourseSkillCreateWithoutCourseInput = {
    skill: SkillCreateNestedOneWithoutCourseSkillsInput
  }

  export type CourseSkillUncheckedCreateWithoutCourseInput = {
    skillId: string
  }

  export type CourseSkillCreateOrConnectWithoutCourseInput = {
    where: CourseSkillWhereUniqueInput
    create: XOR<CourseSkillCreateWithoutCourseInput, CourseSkillUncheckedCreateWithoutCourseInput>
  }

  export type CourseSkillCreateManyCourseInputEnvelope = {
    data: CourseSkillCreateManyCourseInput | CourseSkillCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseSkillUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseSkillWhereUniqueInput
    update: XOR<CourseSkillUpdateWithoutCourseInput, CourseSkillUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseSkillCreateWithoutCourseInput, CourseSkillUncheckedCreateWithoutCourseInput>
  }

  export type CourseSkillUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseSkillWhereUniqueInput
    data: XOR<CourseSkillUpdateWithoutCourseInput, CourseSkillUncheckedUpdateWithoutCourseInput>
  }

  export type CourseSkillUpdateManyWithWhereWithoutCourseInput = {
    where: CourseSkillScalarWhereInput
    data: XOR<CourseSkillUpdateManyMutationInput, CourseSkillUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseCreateWithoutSkillsInput = {
    id?: string
    title: string
    provider: string
    description: string
    thumbnail?: string | null
    duration: number
    level: $Enums.SkillLevel
    rating?: Decimal | DecimalJsLike | number | string
    reviewCount?: number
    price: bigint | number
    url: string
  }

  export type CourseUncheckedCreateWithoutSkillsInput = {
    id?: string
    title: string
    provider: string
    description: string
    thumbnail?: string | null
    duration: number
    level: $Enums.SkillLevel
    rating?: Decimal | DecimalJsLike | number | string
    reviewCount?: number
    price: bigint | number
    url: string
  }

  export type CourseCreateOrConnectWithoutSkillsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutSkillsInput, CourseUncheckedCreateWithoutSkillsInput>
  }

  export type SkillCreateWithoutCourseSkillsInput = {
    id?: string
    name: string
    category: $Enums.SkillCategory
    description?: string | null
    verified?: boolean
    trending?: boolean
    userSkills?: UserSkillCreateNestedManyWithoutSkillInput
    credentialSkills?: CredentialSkillCreateNestedManyWithoutSkillInput
    projectSkills?: ProjectSkillCreateNestedManyWithoutSkillInput
    opportunitySkills?: OpportunitySkillCreateNestedManyWithoutSkillInput
    trendingData?: TrendingSkillCreateNestedOneWithoutSkillInput
    skillGaps?: SkillGapCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutCourseSkillsInput = {
    id?: string
    name: string
    category: $Enums.SkillCategory
    description?: string | null
    verified?: boolean
    trending?: boolean
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutSkillInput
    credentialSkills?: CredentialSkillUncheckedCreateNestedManyWithoutSkillInput
    projectSkills?: ProjectSkillUncheckedCreateNestedManyWithoutSkillInput
    opportunitySkills?: OpportunitySkillUncheckedCreateNestedManyWithoutSkillInput
    trendingData?: TrendingSkillUncheckedCreateNestedOneWithoutSkillInput
    skillGaps?: SkillGapUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutCourseSkillsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutCourseSkillsInput, SkillUncheckedCreateWithoutCourseSkillsInput>
  }

  export type CourseUpsertWithoutSkillsInput = {
    update: XOR<CourseUpdateWithoutSkillsInput, CourseUncheckedUpdateWithoutSkillsInput>
    create: XOR<CourseCreateWithoutSkillsInput, CourseUncheckedCreateWithoutSkillsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutSkillsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutSkillsInput, CourseUncheckedUpdateWithoutSkillsInput>
  }

  export type CourseUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reviewCount?: IntFieldUpdateOperationsInput | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type CourseUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reviewCount?: IntFieldUpdateOperationsInput | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SkillUpsertWithoutCourseSkillsInput = {
    update: XOR<SkillUpdateWithoutCourseSkillsInput, SkillUncheckedUpdateWithoutCourseSkillsInput>
    create: XOR<SkillCreateWithoutCourseSkillsInput, SkillUncheckedCreateWithoutCourseSkillsInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutCourseSkillsInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutCourseSkillsInput, SkillUncheckedUpdateWithoutCourseSkillsInput>
  }

  export type SkillUpdateWithoutCourseSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    userSkills?: UserSkillUpdateManyWithoutSkillNestedInput
    credentialSkills?: CredentialSkillUpdateManyWithoutSkillNestedInput
    projectSkills?: ProjectSkillUpdateManyWithoutSkillNestedInput
    opportunitySkills?: OpportunitySkillUpdateManyWithoutSkillNestedInput
    trendingData?: TrendingSkillUpdateOneWithoutSkillNestedInput
    skillGaps?: SkillGapUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutCourseSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    userSkills?: UserSkillUncheckedUpdateManyWithoutSkillNestedInput
    credentialSkills?: CredentialSkillUncheckedUpdateManyWithoutSkillNestedInput
    projectSkills?: ProjectSkillUncheckedUpdateManyWithoutSkillNestedInput
    opportunitySkills?: OpportunitySkillUncheckedUpdateManyWithoutSkillNestedInput
    trendingData?: TrendingSkillUncheckedUpdateOneWithoutSkillNestedInput
    skillGaps?: SkillGapUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type CredentialCreateWithoutVerificationRequestsInput = {
    id?: string
    title: string
    issuer: string
    type: $Enums.CredentialType
    issueDate: Date | string
    expiryDate?: Date | string | null
    verified?: boolean
    blockchainHash?: string | null
    qrCode?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCredentialsInput
    skills?: CredentialSkillCreateNestedManyWithoutCredentialInput
  }

  export type CredentialUncheckedCreateWithoutVerificationRequestsInput = {
    id?: string
    userId: string
    title: string
    issuer: string
    type: $Enums.CredentialType
    issueDate: Date | string
    expiryDate?: Date | string | null
    verified?: boolean
    blockchainHash?: string | null
    qrCode?: string | null
    createdAt?: Date | string
    skills?: CredentialSkillUncheckedCreateNestedManyWithoutCredentialInput
  }

  export type CredentialCreateOrConnectWithoutVerificationRequestsInput = {
    where: CredentialWhereUniqueInput
    create: XOR<CredentialCreateWithoutVerificationRequestsInput, CredentialUncheckedCreateWithoutVerificationRequestsInput>
  }

  export type UserCreateWithoutVerificationRequestsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileCreateNestedOneWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    credentials?: CredentialCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    applications?: ApplicationCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathCreateNestedManyWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    endorsements?: EndorsementCreateNestedManyWithoutEndorserInput
  }

  export type UserUncheckedCreateWithoutVerificationRequestsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileUncheckedCreateNestedOneWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    credentials?: CredentialUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionUncheckedCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionUncheckedCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestUncheckedCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestUncheckedCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    endorsements?: EndorsementUncheckedCreateNestedManyWithoutEndorserInput
  }

  export type UserCreateOrConnectWithoutVerificationRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVerificationRequestsInput, UserUncheckedCreateWithoutVerificationRequestsInput>
  }

  export type CredentialUpsertWithoutVerificationRequestsInput = {
    update: XOR<CredentialUpdateWithoutVerificationRequestsInput, CredentialUncheckedUpdateWithoutVerificationRequestsInput>
    create: XOR<CredentialCreateWithoutVerificationRequestsInput, CredentialUncheckedCreateWithoutVerificationRequestsInput>
    where?: CredentialWhereInput
  }

  export type CredentialUpdateToOneWithWhereWithoutVerificationRequestsInput = {
    where?: CredentialWhereInput
    data: XOR<CredentialUpdateWithoutVerificationRequestsInput, CredentialUncheckedUpdateWithoutVerificationRequestsInput>
  }

  export type CredentialUpdateWithoutVerificationRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    blockchainHash?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCredentialsNestedInput
    skills?: CredentialSkillUpdateManyWithoutCredentialNestedInput
  }

  export type CredentialUncheckedUpdateWithoutVerificationRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    blockchainHash?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: CredentialSkillUncheckedUpdateManyWithoutCredentialNestedInput
  }

  export type UserUpsertWithoutVerificationRequestsInput = {
    update: XOR<UserUpdateWithoutVerificationRequestsInput, UserUncheckedUpdateWithoutVerificationRequestsInput>
    create: XOR<UserCreateWithoutVerificationRequestsInput, UserUncheckedCreateWithoutVerificationRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVerificationRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVerificationRequestsInput, UserUncheckedUpdateWithoutVerificationRequestsInput>
  }

  export type UserUpdateWithoutVerificationRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    credentials?: CredentialUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    applications?: ApplicationUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUpdateManyWithoutEndorserNestedInput
  }

  export type UserUncheckedUpdateWithoutVerificationRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUncheckedUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    credentials?: CredentialUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUncheckedUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUncheckedUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUncheckedUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUncheckedUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUncheckedUpdateManyWithoutEndorserNestedInput
  }

  export type UserCreateWithoutMessagesSentInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileCreateNestedOneWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    credentials?: CredentialCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    applications?: ApplicationCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathCreateNestedManyWithoutUserInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    endorsements?: EndorsementCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestCreateNestedManyWithoutRequesterInput
  }

  export type UserUncheckedCreateWithoutMessagesSentInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileUncheckedCreateNestedOneWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    credentials?: CredentialUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionUncheckedCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionUncheckedCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestUncheckedCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestUncheckedCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathUncheckedCreateNestedManyWithoutUserInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    endorsements?: EndorsementUncheckedCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type UserCreateOrConnectWithoutMessagesSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
  }

  export type UserCreateWithoutMessagesReceivedInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileCreateNestedOneWithoutUserInput
    userSkills?: UserSkillCreateNestedManyWithoutUserInput
    credentials?: CredentialCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    applications?: ApplicationCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathCreateNestedManyWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    endorsements?: EndorsementCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestCreateNestedManyWithoutRequesterInput
  }

  export type UserUncheckedCreateWithoutMessagesReceivedInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    learnerProfile?: LearnerProfileUncheckedCreateNestedOneWithoutUserInput
    userSkills?: UserSkillUncheckedCreateNestedManyWithoutUserInput
    credentials?: CredentialUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutUserInput
    connectionsSent?: ConnectionUncheckedCreateNestedManyWithoutUserInput
    connectionsReceived?: ConnectionUncheckedCreateNestedManyWithoutConnectedUserInput
    connectionRequestsSent?: ConnectionRequestUncheckedCreateNestedManyWithoutSenderInput
    connectionRequestsReceived?: ConnectionRequestUncheckedCreateNestedManyWithoutReceiverInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    careerPaths?: CareerPathUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    endorsements?: EndorsementUncheckedCreateNestedManyWithoutEndorserInput
    verificationRequests?: VerificationRequestUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type UserCreateOrConnectWithoutMessagesReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesReceivedInput, UserUncheckedCreateWithoutMessagesReceivedInput>
  }

  export type UserUpsertWithoutMessagesSentInput = {
    update: XOR<UserUpdateWithoutMessagesSentInput, UserUncheckedUpdateWithoutMessagesSentInput>
    create: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesSentInput, UserUncheckedUpdateWithoutMessagesSentInput>
  }

  export type UserUpdateWithoutMessagesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    credentials?: CredentialUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    applications?: ApplicationUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUpdateManyWithoutUserNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUpdateManyWithoutRequesterNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUncheckedUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    credentials?: CredentialUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUncheckedUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUncheckedUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUncheckedUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUncheckedUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUncheckedUpdateManyWithoutUserNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUncheckedUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUncheckedUpdateManyWithoutRequesterNestedInput
  }

  export type UserUpsertWithoutMessagesReceivedInput = {
    update: XOR<UserUpdateWithoutMessagesReceivedInput, UserUncheckedUpdateWithoutMessagesReceivedInput>
    create: XOR<UserCreateWithoutMessagesReceivedInput, UserUncheckedCreateWithoutMessagesReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesReceivedInput, UserUncheckedUpdateWithoutMessagesReceivedInput>
  }

  export type UserUpdateWithoutMessagesReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUpdateManyWithoutUserNestedInput
    credentials?: CredentialUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    applications?: ApplicationUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUpdateManyWithoutRequesterNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learnerProfile?: LearnerProfileUncheckedUpdateOneWithoutUserNestedInput
    userSkills?: UserSkillUncheckedUpdateManyWithoutUserNestedInput
    credentials?: CredentialUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutUserNestedInput
    connectionsSent?: ConnectionUncheckedUpdateManyWithoutUserNestedInput
    connectionsReceived?: ConnectionUncheckedUpdateManyWithoutConnectedUserNestedInput
    connectionRequestsSent?: ConnectionRequestUncheckedUpdateManyWithoutSenderNestedInput
    connectionRequestsReceived?: ConnectionRequestUncheckedUpdateManyWithoutReceiverNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    careerPaths?: CareerPathUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    endorsements?: EndorsementUncheckedUpdateManyWithoutEndorserNestedInput
    verificationRequests?: VerificationRequestUncheckedUpdateManyWithoutRequesterNestedInput
  }

  export type UserSkillCreateManyUserInput = {
    id?: string
    skillId: string
    level: $Enums.SkillLevel
    endorsements?: number
    verified?: boolean
    addedAt?: Date | string
  }

  export type CredentialCreateManyUserInput = {
    id?: string
    title: string
    issuer: string
    type: $Enums.CredentialType
    issueDate: Date | string
    expiryDate?: Date | string | null
    verified?: boolean
    blockchainHash?: string | null
    qrCode?: string | null
    createdAt?: Date | string
  }

  export type ProjectCreateManyUserInput = {
    id?: string
    title: string
    description: string
    visibility: $Enums.ProjectVisibility
    verified?: boolean
    githubUrl?: string | null
    liveUrl?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApplicationCreateManyUserInput = {
    id?: string
    opportunityId: string
    status: $Enums.ApplicationStatus
    coverLetter?: string | null
    resumeUrl?: string | null
    appliedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConnectionCreateManyUserInput = {
    id?: string
    connectedUserId: string
    type: $Enums.ConnectionType
    mutualConnections?: number
    connectedAt?: Date | string
  }

  export type ConnectionCreateManyConnectedUserInput = {
    id?: string
    userId: string
    type: $Enums.ConnectionType
    mutualConnections?: number
    connectedAt?: Date | string
  }

  export type ConnectionRequestCreateManySenderInput = {
    id?: string
    receiverId: string
    message?: string | null
    status: $Enums.ConnectionStatus
    requestedAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type ConnectionRequestCreateManyReceiverInput = {
    id?: string
    senderId: string
    message?: string | null
    status: $Enums.ConnectionStatus
    requestedAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type FeedItemCreateManyUserInput = {
    id?: string
    type: $Enums.FeedItemType
    priority: $Enums.Priority
    title: string
    description: string
    image?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionUrl?: string | null
    icon?: string | null
    timestamp?: Date | string
  }

  export type CareerPathCreateManyUserInput = {
    id?: string
    currentRole: string
    targetRole: string
    estimatedDuration: number
    createdAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    receiverId: string
    content: string
    read?: boolean
    sentAt?: Date | string
  }

  export type MessageCreateManyReceiverInput = {
    id?: string
    senderId: string
    content: string
    read?: boolean
    sentAt?: Date | string
  }

  export type ProjectCollaboratorCreateManyUserInput = {
    projectId: string
    role?: string | null
    joinedAt?: Date | string
  }

  export type EndorsementCreateManyEndorserInput = {
    id?: string
    comment?: string | null
    createdAt?: Date | string
    projectId?: string | null
  }

  export type VerificationRequestCreateManyRequesterInput = {
    id?: string
    credentialId: string
    status: $Enums.VerificationStatus
    blockchainHash?: string | null
    requestedAt?: Date | string
    processedAt?: Date | string | null
  }

  export type UserSkillUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    endorsements?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skill?: SkillUpdateOneRequiredWithoutUserSkillsNestedInput
  }

  export type UserSkillUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    endorsements?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSkillUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    endorsements?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CredentialUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    blockchainHash?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: CredentialSkillUpdateManyWithoutCredentialNestedInput
    verificationRequests?: VerificationRequestUpdateManyWithoutCredentialNestedInput
  }

  export type CredentialUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    blockchainHash?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: CredentialSkillUncheckedUpdateManyWithoutCredentialNestedInput
    verificationRequests?: VerificationRequestUncheckedUpdateManyWithoutCredentialNestedInput
  }

  export type CredentialUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    blockchainHash?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    visibility?: EnumProjectVisibilityFieldUpdateOperationsInput | $Enums.ProjectVisibility
    verified?: BoolFieldUpdateOperationsInput | boolean
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: ProjectMediaUpdateManyWithoutProjectNestedInput
    skills?: ProjectSkillUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUpdateManyWithoutProjectNestedInput
    endorsements?: EndorsementUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    visibility?: EnumProjectVisibilityFieldUpdateOperationsInput | $Enums.ProjectVisibility
    verified?: BoolFieldUpdateOperationsInput | boolean
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: ProjectMediaUncheckedUpdateManyWithoutProjectNestedInput
    skills?: ProjectSkillUncheckedUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUncheckedUpdateManyWithoutProjectNestedInput
    endorsements?: EndorsementUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    visibility?: EnumProjectVisibilityFieldUpdateOperationsInput | $Enums.ProjectVisibility
    verified?: BoolFieldUpdateOperationsInput | boolean
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunity?: OpportunityUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType
    mutualConnections?: IntFieldUpdateOperationsInput | number
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectedUser?: UserUpdateOneRequiredWithoutConnectionsReceivedNestedInput
  }

  export type ConnectionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectedUserId?: StringFieldUpdateOperationsInput | string
    type?: EnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType
    mutualConnections?: IntFieldUpdateOperationsInput | number
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectedUserId?: StringFieldUpdateOperationsInput | string
    type?: EnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType
    mutualConnections?: IntFieldUpdateOperationsInput | number
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectionUpdateWithoutConnectedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType
    mutualConnections?: IntFieldUpdateOperationsInput | number
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConnectionsSentNestedInput
  }

  export type ConnectionUncheckedUpdateWithoutConnectedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType
    mutualConnections?: IntFieldUpdateOperationsInput | number
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectionUncheckedUpdateManyWithoutConnectedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType
    mutualConnections?: IntFieldUpdateOperationsInput | number
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectionRequestUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConnectionStatusFieldUpdateOperationsInput | $Enums.ConnectionStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiver?: UserUpdateOneRequiredWithoutConnectionRequestsReceivedNestedInput
  }

  export type ConnectionRequestUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConnectionStatusFieldUpdateOperationsInput | $Enums.ConnectionStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConnectionRequestUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConnectionStatusFieldUpdateOperationsInput | $Enums.ConnectionStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConnectionRequestUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConnectionStatusFieldUpdateOperationsInput | $Enums.ConnectionStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender?: UserUpdateOneRequiredWithoutConnectionRequestsSentNestedInput
  }

  export type ConnectionRequestUncheckedUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConnectionStatusFieldUpdateOperationsInput | $Enums.ConnectionStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConnectionRequestUncheckedUpdateManyWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConnectionStatusFieldUpdateOperationsInput | $Enums.ConnectionStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FeedItemUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedItemTypeFieldUpdateOperationsInput | $Enums.FeedItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedItemUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedItemTypeFieldUpdateOperationsInput | $Enums.FeedItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedItemUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedItemTypeFieldUpdateOperationsInput | $Enums.FeedItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerPathUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentRole?: StringFieldUpdateOperationsInput | string
    targetRole?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: CareerPathNodeUpdateManyWithoutCareerPathNestedInput
    skillGaps?: SkillGapUpdateManyWithoutCareerPathNestedInput
  }

  export type CareerPathUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentRole?: StringFieldUpdateOperationsInput | string
    targetRole?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: CareerPathNodeUncheckedUpdateManyWithoutCareerPathNestedInput
    skillGaps?: SkillGapUncheckedUpdateManyWithoutCareerPathNestedInput
  }

  export type CareerPathUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentRole?: StringFieldUpdateOperationsInput | string
    targetRole?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutMessagesReceivedNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
  }

  export type MessageUncheckedUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCollaboratorUpdateWithoutUserInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutCollaboratorsNestedInput
  }

  export type ProjectCollaboratorUncheckedUpdateWithoutUserInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCollaboratorUncheckedUpdateManyWithoutUserInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EndorsementUpdateWithoutEndorserInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutEndorsementsNestedInput
  }

  export type EndorsementUncheckedUpdateWithoutEndorserInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EndorsementUncheckedUpdateManyWithoutEndorserInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerificationRequestUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    blockchainHash?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    credential?: CredentialUpdateOneRequiredWithoutVerificationRequestsNestedInput
  }

  export type VerificationRequestUncheckedUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    blockchainHash?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationRequestUncheckedUpdateManyWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    blockchainHash?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSkillCreateManySkillInput = {
    id?: string
    userId: string
    level: $Enums.SkillLevel
    endorsements?: number
    verified?: boolean
    addedAt?: Date | string
  }

  export type CredentialSkillCreateManySkillInput = {
    credentialId: string
  }

  export type ProjectSkillCreateManySkillInput = {
    projectId: string
  }

  export type OpportunitySkillCreateManySkillInput = {
    opportunityId: string
  }

  export type CourseSkillCreateManySkillInput = {
    courseId: string
  }

  export type SkillGapCreateManySkillInput = {
    id?: string
    careerPathId: string
    currentLevel: $Enums.SkillLevel
    targetLevel: $Enums.SkillLevel
    priority: $Enums.Priority
  }

  export type UserSkillUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    endorsements?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserSkillsNestedInput
  }

  export type UserSkillUncheckedUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    endorsements?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSkillUncheckedUpdateManyWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    endorsements?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CredentialSkillUpdateWithoutSkillInput = {
    credential?: CredentialUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type CredentialSkillUncheckedUpdateWithoutSkillInput = {
    credentialId?: StringFieldUpdateOperationsInput | string
  }

  export type CredentialSkillUncheckedUpdateManyWithoutSkillInput = {
    credentialId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectSkillUpdateWithoutSkillInput = {
    project?: ProjectUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type ProjectSkillUncheckedUpdateWithoutSkillInput = {
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectSkillUncheckedUpdateManyWithoutSkillInput = {
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type OpportunitySkillUpdateWithoutSkillInput = {
    opportunity?: OpportunityUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type OpportunitySkillUncheckedUpdateWithoutSkillInput = {
    opportunityId?: StringFieldUpdateOperationsInput | string
  }

  export type OpportunitySkillUncheckedUpdateManyWithoutSkillInput = {
    opportunityId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseSkillUpdateWithoutSkillInput = {
    course?: CourseUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type CourseSkillUncheckedUpdateWithoutSkillInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseSkillUncheckedUpdateManyWithoutSkillInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type SkillGapUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    targetLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    careerPath?: CareerPathUpdateOneRequiredWithoutSkillGapsNestedInput
  }

  export type SkillGapUncheckedUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    careerPathId?: StringFieldUpdateOperationsInput | string
    currentLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    targetLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
  }

  export type SkillGapUncheckedUpdateManyWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    careerPathId?: StringFieldUpdateOperationsInput | string
    currentLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    targetLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
  }

  export type CredentialSkillCreateManyCredentialInput = {
    skillId: string
  }

  export type VerificationRequestCreateManyCredentialInput = {
    id?: string
    requestedBy: string
    status: $Enums.VerificationStatus
    blockchainHash?: string | null
    requestedAt?: Date | string
    processedAt?: Date | string | null
  }

  export type CredentialSkillUpdateWithoutCredentialInput = {
    skill?: SkillUpdateOneRequiredWithoutCredentialSkillsNestedInput
  }

  export type CredentialSkillUncheckedUpdateWithoutCredentialInput = {
    skillId?: StringFieldUpdateOperationsInput | string
  }

  export type CredentialSkillUncheckedUpdateManyWithoutCredentialInput = {
    skillId?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationRequestUpdateWithoutCredentialInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    blockchainHash?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requester?: UserUpdateOneRequiredWithoutVerificationRequestsNestedInput
  }

  export type VerificationRequestUncheckedUpdateWithoutCredentialInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    blockchainHash?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationRequestUncheckedUpdateManyWithoutCredentialInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    blockchainHash?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectMediaCreateManyProjectInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    thumbnail?: string | null
    caption?: string | null
    displayOrder?: number
  }

  export type ProjectSkillCreateManyProjectInput = {
    skillId: string
  }

  export type ProjectCollaboratorCreateManyProjectInput = {
    userId: string
    role?: string | null
    joinedAt?: Date | string
  }

  export type EndorsementCreateManyProjectInput = {
    id?: string
    endorserId: string
    comment?: string | null
    createdAt?: Date | string
  }

  export type ProjectMediaUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectMediaUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectMediaUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectSkillUpdateWithoutProjectInput = {
    skill?: SkillUpdateOneRequiredWithoutProjectSkillsNestedInput
  }

  export type ProjectSkillUncheckedUpdateWithoutProjectInput = {
    skillId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectSkillUncheckedUpdateManyWithoutProjectInput = {
    skillId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCollaboratorUpdateWithoutProjectInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectCollaborationsNestedInput
  }

  export type ProjectCollaboratorUncheckedUpdateWithoutProjectInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCollaboratorUncheckedUpdateManyWithoutProjectInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EndorsementUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endorser?: UserUpdateOneRequiredWithoutEndorsementsNestedInput
  }

  export type EndorsementUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    endorserId?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EndorsementUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    endorserId?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityRequirementCreateManyOpportunityInput = {
    id?: string
    requirement: string
    displayOrder?: number
  }

  export type OpportunitySkillCreateManyOpportunityInput = {
    skillId: string
  }

  export type ApplicationCreateManyOpportunityInput = {
    id?: string
    userId: string
    status: $Enums.ApplicationStatus
    coverLetter?: string | null
    resumeUrl?: string | null
    appliedAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpportunityRequirementUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirement?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
  }

  export type OpportunityRequirementUncheckedUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirement?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
  }

  export type OpportunityRequirementUncheckedUpdateManyWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirement?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
  }

  export type OpportunitySkillUpdateWithoutOpportunityInput = {
    skill?: SkillUpdateOneRequiredWithoutOpportunitySkillsNestedInput
  }

  export type OpportunitySkillUncheckedUpdateWithoutOpportunityInput = {
    skillId?: StringFieldUpdateOperationsInput | string
  }

  export type OpportunitySkillUncheckedUpdateManyWithoutOpportunityInput = {
    skillId?: StringFieldUpdateOperationsInput | string
  }

  export type ApplicationUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationUncheckedUpdateManyWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerPathNodeCreateManyCareerPathInput = {
    id?: string
    stageNumber: number
    title: string
    duration: number
    completed?: boolean
  }

  export type SkillGapCreateManyCareerPathInput = {
    id?: string
    skillId: string
    currentLevel: $Enums.SkillLevel
    targetLevel: $Enums.SkillLevel
    priority: $Enums.Priority
  }

  export type CareerPathNodeUpdateWithoutCareerPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CareerPathNodeUncheckedUpdateWithoutCareerPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CareerPathNodeUncheckedUpdateManyWithoutCareerPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SkillGapUpdateWithoutCareerPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    targetLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    skill?: SkillUpdateOneRequiredWithoutSkillGapsNestedInput
  }

  export type SkillGapUncheckedUpdateWithoutCareerPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    currentLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    targetLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
  }

  export type SkillGapUncheckedUpdateManyWithoutCareerPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    currentLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    targetLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
  }

  export type CourseSkillCreateManyCourseInput = {
    skillId: string
  }

  export type CourseSkillUpdateWithoutCourseInput = {
    skill?: SkillUpdateOneRequiredWithoutCourseSkillsNestedInput
  }

  export type CourseSkillUncheckedUpdateWithoutCourseInput = {
    skillId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseSkillUncheckedUpdateManyWithoutCourseInput = {
    skillId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkillCountOutputTypeDefaultArgs instead
     */
    export type SkillCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkillCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CredentialCountOutputTypeDefaultArgs instead
     */
    export type CredentialCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CredentialCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectCountOutputTypeDefaultArgs instead
     */
    export type ProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OpportunityCountOutputTypeDefaultArgs instead
     */
    export type OpportunityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OpportunityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CareerPathCountOutputTypeDefaultArgs instead
     */
    export type CareerPathCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CareerPathCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseCountOutputTypeDefaultArgs instead
     */
    export type CourseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LearnerProfileDefaultArgs instead
     */
    export type LearnerProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LearnerProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkillDefaultArgs instead
     */
    export type SkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserSkillDefaultArgs instead
     */
    export type UserSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserSkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrendingSkillDefaultArgs instead
     */
    export type TrendingSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrendingSkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CredentialDefaultArgs instead
     */
    export type CredentialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CredentialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CredentialSkillDefaultArgs instead
     */
    export type CredentialSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CredentialSkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDefaultArgs instead
     */
    export type ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectMediaDefaultArgs instead
     */
    export type ProjectMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectMediaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectSkillDefaultArgs instead
     */
    export type ProjectSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectSkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectCollaboratorDefaultArgs instead
     */
    export type ProjectCollaboratorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCollaboratorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EndorsementDefaultArgs instead
     */
    export type EndorsementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EndorsementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OpportunityDefaultArgs instead
     */
    export type OpportunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OpportunityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OpportunityRequirementDefaultArgs instead
     */
    export type OpportunityRequirementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OpportunityRequirementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OpportunitySkillDefaultArgs instead
     */
    export type OpportunitySkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OpportunitySkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApplicationDefaultArgs instead
     */
    export type ApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApplicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConnectionDefaultArgs instead
     */
    export type ConnectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConnectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConnectionRequestDefaultArgs instead
     */
    export type ConnectionRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConnectionRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeedItemDefaultArgs instead
     */
    export type FeedItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeedItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CareerPathDefaultArgs instead
     */
    export type CareerPathArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CareerPathDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CareerPathNodeDefaultArgs instead
     */
    export type CareerPathNodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CareerPathNodeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkillGapDefaultArgs instead
     */
    export type SkillGapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkillGapDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseDefaultArgs instead
     */
    export type CourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseSkillDefaultArgs instead
     */
    export type CourseSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseSkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VerificationRequestDefaultArgs instead
     */
    export type VerificationRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VerificationRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}